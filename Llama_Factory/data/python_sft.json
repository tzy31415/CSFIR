[
    {
        "input": "def process_results(self, rows):\n        '''\n        This function takes a list of database results and iterates over,\n        merging them into a dict form.\n        '''\n        listify = OrderedDict()\n        listify_dicts = OrderedDict()\n        for ret in rows:\n            # crd is the Current Return Data level, to make this non-recursive.\n            crd = self.focus\n            # Walk and create dicts above the final layer\n            for i in range(0, self.depth-1):\n                # At the end we'll use listify to find values to make a list of\n                if i+1 in self.with_lists:\n                    if id(crd) not in listify:\n                        listify[id(crd)] = []\n                        listify_dicts[id(crd)] = crd\n                    if ret[i] not in listify[id(crd)]:\n                        listify[id(crd)].append(ret[i])\n                if ret[i] not in crd:\n                    # Key missing\n                    crd[ret[i]] = {}\n                    crd = crd[ret[i]]\n                else:\n                    # Check type of collision\n                    ty = type(crd[ret[i]])\n                    if ty is list:\n                        # Already made list\n                        temp = {}\n                        crd[ret[i]].append(temp)\n                        crd = temp\n                    elif ty is not dict:\n                        # Not a list, not a dict\n                        if self.as_list:\n                            # Make list\n                            temp = {}\n                            crd[ret[i]] = [crd[ret[i]], temp]\n                            crd = temp\n                        else:\n                            # Overwrite\n                            crd[ret[i]] = {}\n                            crd = crd[ret[i]]\n                    else:\n                        # dict, descend.\n                        crd = crd[ret[i]]\n\n            # If this test is true, the penultimate field is the key\n            if self.depth == self.num_fields - 1:\n                nk = self.num_fields-2  # Aka, self.depth-1\n                # Should we and will we have a list at the end?\n                if ((self.as_list and (ret[nk] in crd)) or\n                        (nk+1 in self.with_lists)):\n                    if ret[nk] in crd:\n                        if not isinstance(crd[ret[nk]], list):\n                            crd[ret[nk]] = [crd[ret[nk]]]\n                        # if it's already a list, do nothing\n                    else:\n                        crd[ret[nk]] = []\n                    crd[ret[nk]].append(ret[self.num_fields-1])\n                else:\n                    if not self.ignore_null or ret[self.num_fields-1] is not None:\n                        crd[ret[nk]] = ret[self.num_fields-1]\n            else:\n                # Otherwise, the field name is the key but we have a spare.\n                # The spare results because of {c: d} vs {c: {\"d\": d, \"e\": e }}\n                # So, make that last dict\n                if ret[self.depth-1] not in crd:\n                    crd[ret[self.depth-1]] = {}\n                # This bit doesn't escape listify\n                if self.depth in self.with_lists:\n                    if id(crd) not in listify:\n                        listify[id(crd)] = []\n                        listify_dicts[id(crd)] = crd\n                    if ret[self.depth-1] not in listify[id(crd)]:\n                        listify[id(crd)].append(ret[self.depth-1])\n                crd = crd[ret[self.depth-1]]\n                # Now for the remaining keys, we put them into the dict\n                for i in range(self.depth, self.num_fields):\n                    nk = self.field_names[i]\n                    # Listify\n                    if i+1 in self.with_lists:\n                        if id(crd) not in listify:\n                            listify[id(crd)] = []\n                            listify_dicts[id(crd)] = crd\n                        if nk not in listify[id(crd)]:\n                            listify[id(crd)].append(nk)\n                    # Collision detection\n                    if self.as_list and (nk in crd):\n                        # Same as before...\n                        if isinstance(crd[nk], list):\n                            crd[nk].append(ret[i])\n                        else:\n                            crd[nk] = [crd[nk], ret[i]]\n                    else:\n                        if not self.ignore_null or ret[i] is not None:\n                            crd[nk] = ret[i]\n        # Get key list and work backwards.  This is inner-out processing\n        ks = list(listify_dicts.keys())\n        ks.reverse()\n        for i in ks:\n            d = listify_dicts[i]\n            for k in listify[i]:\n                if isinstance(d[k], dict):\n                    d[k] = list(d[k].values())\n                elif isinstance(d[k], list):\n                    d[k] = [d[k]]",
        "history": [],
        "output": "This function takes a list of database results and iterates over,\n        merging them into a dict form.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def list_datasets(self, project_id):\n        \"\"\"Returns the list of datasets in a given project.\n\n           :param project_id:\n           :type project_id: str\n        \"\"\"\n\n        request = self.client.datasets().list(projectId=project_id,\n                                              maxResults=1000)\n        response = request.execute()\n\n        while response is not None:\n            for ds in response.get('datasets', []):\n                yield ds['datasetReference']['datasetId']\n\n            request = self.client.datasets().list_next(request, response)\n            if request is None:\n                break\n\n            response = request.execute()",
        "history": [],
        "output": "Returns the list of datasets in a given project.\n\n           :param project_id:\n           :type project_id: str",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def update(self):\n        \"\"\"Updates parameters according to installed optimizer and the gradient computed\n        in the previous forward-backward cycle.\n        \"\"\"\n        assert self.binded and self.params_initialized and self.optimizer_initialized\n\n        for module in self._modules:\n            module.update()",
        "history": [],
        "output": "Updates parameters according to installed optimizer and the gradient computed\n        in the previous forward-backward cycle.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def from_arrow_type(at):\n    \"\"\" Convert pyarrow type to Spark data type.\n    \"\"\"\n    import pyarrow.types as types\n    if types.is_boolean(at):\n        spark_type = BooleanType()\n    elif types.is_int8(at):\n        spark_type = ByteType()\n    elif types.is_int16(at):\n        spark_type = ShortType()\n    elif types.is_int32(at):\n        spark_type = IntegerType()\n    elif types.is_int64(at):\n        spark_type = LongType()\n    elif types.is_float32(at):\n        spark_type = FloatType()\n    elif types.is_float64(at):\n        spark_type = DoubleType()\n    elif types.is_decimal(at):\n        spark_type = DecimalType(precision=at.precision, scale=at.scale)\n    elif types.is_string(at):\n        spark_type = StringType()\n    elif types.is_binary(at):\n        spark_type = BinaryType()\n    elif types.is_date32(at):\n        spark_type = DateType()\n    elif types.is_timestamp(at):\n        spark_type = TimestampType()\n    elif types.is_list(at):\n        if types.is_timestamp(at.value_type):\n            raise TypeError(\"Unsupported type in conversion from Arrow: \" + str(at))\n        spark_type = ArrayType(from_arrow_type(at.value_type))\n    elif types.is_struct(at):\n        if any(types.is_struct(field.type) for field in at):\n            raise TypeError(\"Nested StructType not supported in conversion from Arrow: \" + str(at))\n        return StructType(\n            [StructField(field.name, from_arrow_type(field.type), nullable=field.nullable)\n             for field in at])\n    else:\n        raise TypeError(\"Unsupported type in conversion from Arrow: \" + str(at))\n    return spark_type",
        "history": [],
        "output": "Convert pyarrow type to Spark data type.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def show_lowstate(**kwargs):\n    '''\n    List out the low data that will be applied to this minion\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' state.show_lowstate\n    '''\n    __opts__['grains'] = __grains__\n    opts = salt.utils.state.get_sls_opts(__opts__, **kwargs)\n    st_ = salt.client.ssh.state.SSHHighState(\n            opts,\n            __pillar__,\n            __salt__,\n            __context__['fileclient'])\n    st_.push_active()\n    chunks = st_.compile_low_chunks()\n    _cleanup_slsmod_low_data(chunks)\n    return chunks",
        "history": [],
        "output": "List out the low data that will be applied to this minion\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' state.show_lowstate",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def convert_dropout(node, **kwargs):\n    \"\"\"Map MXNet's Dropout operator attributes to onnx's Dropout operator\n    and return the created node.\n    \"\"\"\n    name, input_nodes, attrs = get_inputs(node, kwargs)\n\n    probability = float(attrs.get(\"p\", 0.5))\n\n    dropout_node = onnx.helper.make_node(\n        \"Dropout\",\n        input_nodes,\n        [name],\n        ratio=probability,\n        name=name\n    )\n    return [dropout_node]",
        "history": [],
        "output": "Map MXNet's Dropout operator attributes to onnx's Dropout operator\n    and return the created node.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def on_step_begin(self, step, logs={}):\n        \"\"\" Called at beginning of each step for each callback in callbackList\"\"\"\n        for callback in self.callbacks:\n            # Check if callback supports the more appropriate `on_step_begin` callback.\n            # If not, fall back to `on_batch_begin` to be compatible with built-in Keras callbacks.\n            if callable(getattr(callback, 'on_step_begin', None)):\n                callback.on_step_begin(step, logs=logs)\n            else:\n                callback.on_batch_begin(step, logs=logs)",
        "history": [],
        "output": "Called at beginning of each step for each callback in callbackList",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def fullversion():\n    '''\n    Shows installed version of dnsmasq and compile options.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' dnsmasq.fullversion\n    '''\n    cmd = 'dnsmasq -v'\n    out = __salt__['cmd.run'](cmd).splitlines()\n    comps = out[0].split()\n    version_num = comps[2]\n    comps = out[1].split()\n    return {'version': version_num,\n            'compile options': comps[3:]}",
        "history": [],
        "output": "Shows installed version of dnsmasq and compile options.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' dnsmasq.fullversion",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def pq(self) -> PyQuery:\n        \"\"\"`PyQuery <https://pythonhosted.org/pyquery/>`_ representation\n        of the :class:`Element <Element>` or :class:`HTML <HTML>`.\n        \"\"\"\n        if self._pq is None:\n            self._pq = PyQuery(self.lxml)\n\n        return self._pq",
        "history": [],
        "output": "`PyQuery <https://pythonhosted.org/pyquery/>`_ representation\n        of the :class:`Element <Element>` or :class:`HTML <HTML>`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _process_all_any(self, func, **kwargs):\n        \"\"\"Calculates if any or all the values are true.\n\n        Return:\n            A new QueryCompiler object containing boolean values or boolean.\n        \"\"\"\n        axis = kwargs.get(\"axis\", 0)\n        axis = 0 if axis is None else axis\n        kwargs[\"axis\"] = axis\n        builder_func = self._build_mapreduce_func(func, **kwargs)\n        return self._full_reduce(axis, builder_func)",
        "history": [],
        "output": "Calculates if any or all the values are true.\n\n        Return:\n            A new QueryCompiler object containing boolean values or boolean.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def add_experiment(self, id, port, time, file_name, platform):\n        '''set {key:value} paris to self.experiment'''\n        self.experiments[id] = {}\n        self.experiments[id]['port'] = port\n        self.experiments[id]['startTime'] = time\n        self.experiments[id]['endTime'] = 'N/A'\n        self.experiments[id]['status'] = 'INITIALIZED'\n        self.experiments[id]['fileName'] = file_name\n        self.experiments[id]['platform'] = platform\n        self.write_file()",
        "history": [],
        "output": "set {key:value} paris to self.experiment",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def absent(name,\n           runas=None):\n    '''\n    Ensure the named user is absent\n\n    name\n        The name of the user to remove\n    runas\n        User to run the command\n    '''\n    ret = {'name': name, 'result': False, 'comment': '', 'changes': {}}\n\n    try:\n        user_exists = __salt__['rabbitmq.user_exists'](name, runas=runas)\n    except CommandExecutionError as err:\n        ret['comment'] = 'Error: {0}'.format(err)\n        return ret\n\n    if user_exists:\n        if not __opts__['test']:\n            try:\n                __salt__['rabbitmq.delete_user'](name, runas=runas)\n            except CommandExecutionError as err:\n                ret['comment'] = 'Error: {0}'.format(err)\n                return ret\n        ret['changes'].update({'name':\n                              {'old': name,\n                               'new': ''}})\n    else:\n        ret['result'] = True\n        ret['comment'] = 'The user \\'{0}\\' is not present.'.format(name)\n        return ret\n\n    if __opts__['test'] and ret['changes']:\n        ret['result'] = None\n        ret['comment'] = 'The user \\'{0}\\' will be removed.'.format(name)\n        return ret\n\n    ret['result'] = True\n    ret['comment'] = 'The user \\'{0}\\' was removed.'.format(name)\n    return ret",
        "history": [],
        "output": "Ensure the named user is absent\n\n    name\n        The name of the user to remove\n    runas\n        User to run the command",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _create_secret(namespace, name, data, apiserver_url):\n    ''' create namespace on the defined k8s cluster '''\n    # Prepare URL\n    url = \"{0}/api/v1/namespaces/{1}/secrets\".format(apiserver_url, namespace)\n    # Prepare data\n    request = {\n        \"apiVersion\": \"v1\",\n        \"kind\": \"Secret\",\n        \"metadata\": {\n            \"name\": name,\n            \"namespace\": namespace,\n        },\n        \"data\": data\n    }\n    # Make request\n    ret = _kpost(url, request)\n    return ret",
        "history": [],
        "output": "create namespace on the defined k8s cluster",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def renamed(self, source, dest):\r\n        \"\"\"File was renamed in file explorer widget or in project explorer\"\"\"\r\n        filename = osp.abspath(to_text_string(source))\r\n        index = self.editorstacks[0].has_filename(filename)\r\n        if index is not None:\r\n            for editorstack in self.editorstacks:\r\n                editorstack.rename_in_data(filename,\r\n                                           new_filename=to_text_string(dest))",
        "history": [],
        "output": "File was renamed in file explorer widget or in project explorer",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def rlmb_long_stochastic_discrete_100steps():\n  \"\"\"Long setting with stochastic discrete model, changed ppo steps.\"\"\"\n  hparams = rlmb_long_stochastic_discrete()\n  hparams.ppo_epoch_length = 100\n  hparams.simulated_rollout_length = 100\n  hparams.simulated_batch_size = 8\n  return hparams",
        "history": [],
        "output": "Long setting with stochastic discrete model, changed ppo steps.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_data_schema(self):\n        \"\"\"\n        Returns a dictionary of (column : type) for the data used in the\n        model.\n        \"\"\"\n\n        if not hasattr(self, \"_data_schema\"):\n            response = self.__proxy__.get_data_schema()\n\n            self._data_schema = {k : _turicreate._cython.cy_flexible_type.pytype_from_type_name(v)\n                                 for k, v in response[\"schema\"].items()}\n\n        return self._data_schema",
        "history": [],
        "output": "Returns a dictionary of (column : type) for the data used in the\n        model.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _parse_date_columns(data_frame, parse_dates):\n    \"\"\"\n    Force non-datetime columns to be read as such.\n    Supports both string formatted and integer timestamp columns.\n    \"\"\"\n    parse_dates = _process_parse_dates_argument(parse_dates)\n\n    # we want to coerce datetime64_tz dtypes for now to UTC\n    # we could in theory do a 'nice' conversion from a FixedOffset tz\n    # GH11216\n    for col_name, df_col in data_frame.iteritems():\n        if is_datetime64tz_dtype(df_col) or col_name in parse_dates:\n            try:\n                fmt = parse_dates[col_name]\n            except TypeError:\n                fmt = None\n            data_frame[col_name] = _handle_date_column(df_col, format=fmt)\n\n    return data_frame",
        "history": [],
        "output": "Force non-datetime columns to be read as such.\n    Supports both string formatted and integer timestamp columns.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def submit_job(self, job_definition, parameters, job_name=None, queue=None):\n        \"\"\"Wrap submit_job with useful defaults\"\"\"\n        if job_name is None:\n            job_name = _random_id()\n        response = self._client.submit_job(\n            jobName=job_name,\n            jobQueue=queue or self.get_active_queue(),\n            jobDefinition=job_definition,\n            parameters=parameters\n        )\n        return response['jobId']",
        "history": [],
        "output": "Wrap submit_job with useful defaults",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def update_floatingip(self, floatingip_id, port=None):\n        '''\n        Updates a floatingip, disassociates the floating ip if\n        port is set to `None`\n        '''\n        if port is None:\n            body = {'floatingip': {}}\n        else:\n            port_id = self._find_port_id(port)\n            body = {'floatingip': {'port_id': port_id}}\n        return self.network_conn.update_floatingip(\n            floatingip=floatingip_id, body=body)",
        "history": [],
        "output": "Updates a floatingip, disassociates the floating ip if\n        port is set to `None`",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def set_sid_attrs(self, sid, **kwargs):\n        \"\"\"Write all the supplied kwargs as attributes of the sid's file.\n        \"\"\"\n        table = self._ensure_ctable(sid)\n        for k, v in kwargs.items():\n            table.attrs[k] = v",
        "history": [],
        "output": "Write all the supplied kwargs as attributes of the sid's file.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def set_bookmark(self, slot_num):\r\n        \"\"\"Bookmark current position to given slot.\"\"\"\r\n        if self.data:\r\n            editor = self.get_current_editor()\r\n            editor.add_bookmark(slot_num)",
        "history": [],
        "output": "Bookmark current position to given slot.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def set_role(username, role):\n    '''\n    Assign role to username\n\n    .. code-block:: bash\n\n        salt '*' onyx.cmd set_role username=daniel role=vdc-admin\n    '''\n    try:\n        sendline('config terminal')\n        role_line = 'username {0} role {1}'.format(username, role)\n        ret = sendline(role_line)\n        sendline('end')\n        sendline('copy running-config startup-config')\n        return '\\n'.join([role_line, ret])\n    except TerminalException as e:\n        log.error(e)\n        return 'Failed to set password'",
        "history": [],
        "output": "Assign role to username\n\n    .. code-block:: bash\n\n        salt '*' onyx.cmd set_role username=daniel role=vdc-admin",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _length_hint(obj):\n    \"\"\"Returns the length hint of an object.\"\"\"\n    try:\n        return len(obj)\n    except (AttributeError, TypeError):\n        try:\n            get_hint = type(obj).__length_hint__\n        except AttributeError:\n            return None\n        try:\n            hint = get_hint(obj)\n        except TypeError:\n            return None\n        if hint is NotImplemented or \\\n           not isinstance(hint, int_types) or \\\n           hint < 0:\n            return None\n        return hint",
        "history": [],
        "output": "Returns the length hint of an object.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _find_keep_files(root, keep):\n    '''\n    Compile a list of valid keep files (and directories).\n    Used by _clean_dir()\n    '''\n    real_keep = set()\n    real_keep.add(root)\n    if isinstance(keep, list):\n        for fn_ in keep:\n            if not os.path.isabs(fn_):\n                continue\n            fn_ = os.path.normcase(os.path.abspath(fn_))\n            real_keep.add(fn_)\n            while True:\n                fn_ = os.path.abspath(os.path.dirname(fn_))\n                real_keep.add(fn_)\n                drive, path = os.path.splitdrive(fn_)\n                if not path.lstrip(os.sep):\n                    break\n    return real_keep",
        "history": [],
        "output": "Compile a list of valid keep files (and directories).\n    Used by _clean_dir()",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def count(self):\n        \"\"\" Compute count of group, excluding missing values \"\"\"\n        from pandas.core.dtypes.missing import _isna_ndarraylike as _isna\n\n        data, _ = self._get_data_to_aggregate()\n        ids, _, ngroups = self.grouper.group_info\n        mask = ids != -1\n\n        val = ((mask & ~_isna(np.atleast_2d(blk.get_values())))\n               for blk in data.blocks)\n        loc = (blk.mgr_locs for blk in data.blocks)\n\n        counter = partial(\n            lib.count_level_2d, labels=ids, max_bin=ngroups, axis=1)\n        blk = map(make_block, map(counter, val), loc)\n\n        return self._wrap_agged_blocks(data.items, list(blk))",
        "history": [],
        "output": "Compute count of group, excluding missing values",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def soft_convert_objects(values, datetime=True, numeric=True, timedelta=True,\n                         coerce=False, copy=True):\n    \"\"\" if we have an object dtype, try to coerce dates and/or numbers \"\"\"\n\n    conversion_count = sum((datetime, numeric, timedelta))\n    if conversion_count == 0:\n        raise ValueError('At least one of datetime, numeric or timedelta must '\n                         'be True.')\n    elif conversion_count > 1 and coerce:\n        raise ValueError(\"Only one of 'datetime', 'numeric' or \"\n                         \"'timedelta' can be True when when coerce=True.\")\n\n    if isinstance(values, (list, tuple)):\n        # List or scalar\n        values = np.array(values, dtype=np.object_)\n    elif not hasattr(values, 'dtype'):\n        values = np.array([values], dtype=np.object_)\n    elif not is_object_dtype(values.dtype):\n        # If not object, do not attempt conversion\n        values = values.copy() if copy else values\n        return values\n\n    # If 1 flag is coerce, ensure 2 others are False\n    if coerce:\n        # Immediate return if coerce\n        if datetime:\n            from pandas import to_datetime\n            return to_datetime(values, errors='coerce').to_numpy()\n        elif timedelta:\n            from pandas import to_timedelta\n            return to_timedelta(values, errors='coerce').to_numpy()\n        elif numeric:\n            from pandas import to_numeric\n            return to_numeric(values, errors='coerce')\n\n    # Soft conversions\n    if datetime:\n        # GH 20380, when datetime is beyond year 2262, hence outside\n        # bound of nanosecond-resolution 64-bit integers.\n        try:\n            values = lib.maybe_convert_objects(values,\n                                               convert_datetime=datetime)\n        except OutOfBoundsDatetime:\n            pass\n\n    if timedelta and is_object_dtype(values.dtype):\n        # Object check to ensure only run if previous did not convert\n        values = lib.maybe_convert_objects(values, convert_timedelta=timedelta)\n\n    if numeric and is_object_dtype(values.dtype):\n        try:\n            converted = lib.maybe_convert_numeric(values, set(),\n                                                  coerce_numeric=True)\n            # If all NaNs, then do not-alter\n            values = converted if not isna(converted).all() else values\n            values = values.copy() if copy else values\n        except Exception:\n            pass\n\n    return values",
        "history": [],
        "output": "if we have an object dtype, try to coerce dates and/or numbers",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _allowed_to_proceed(self, verbose):\n        \"\"\"Display which files would be deleted and prompt for confirmation\n        \"\"\"\n\n        def _display(msg, paths):\n            if not paths:\n                return\n\n            logger.info(msg)\n            with indent_log():\n                for path in sorted(compact(paths)):\n                    logger.info(path)\n\n        if not verbose:\n            will_remove, will_skip = compress_for_output_listing(self.paths)\n        else:\n            # In verbose mode, display all the files that are going to be\n            # deleted.\n            will_remove = list(self.paths)\n            will_skip = set()\n\n        _display('Would remove:', will_remove)\n        _display('Would not remove (might be manually added):', will_skip)\n        _display('Would not remove (outside of prefix):', self._refuse)\n        if verbose:\n            _display('Will actually move:', compress_for_rename(self.paths))\n\n        return ask('Proceed (y/n)? ', ('y', 'n')) == 'y'",
        "history": [],
        "output": "Display which files would be deleted and prompt for confirmation",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def gather_blocks_2d(x, indices):\n  \"\"\"Gathers flattened blocks from x.\"\"\"\n  x_shape = common_layers.shape_list(x)\n  x = reshape_range(x, 2, 4, [tf.reduce_prod(x_shape[2:4])])\n  # [length, batch, heads, dim]\n  x_t = tf.transpose(x, [2, 0, 1, 3])\n  x_new = tf.gather(x_t, indices)\n  # returns [batch, heads, num_blocks, block_length ** 2, dim]\n  return tf.transpose(x_new, [2, 3, 0, 1, 4])",
        "history": [],
        "output": "Gathers flattened blocks from x.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def split_from_df(self, col:IntsOrStrs=2):\n        \"Split the data from the `col` in the dataframe in `self.inner_df`.\"\n        valid_idx = np.where(self.inner_df.iloc[:,df_names_to_idx(col, self.inner_df)])[0]\n        return self.split_by_idx(valid_idx)",
        "history": [],
        "output": "Split the data from the `col` in the dataframe in `self.inner_df`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def notification_channel_path(cls, project, notification_channel):\n        \"\"\"Return a fully-qualified notification_channel string.\"\"\"\n        return google.api_core.path_template.expand(\n            \"projects/{project}/notificationChannels/{notification_channel}\",\n            project=project,\n            notification_channel=notification_channel,\n        )",
        "history": [],
        "output": "Return a fully-qualified notification_channel string.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def load_data_with_word2vec(word2vec_list):\n    \"\"\"Loads and preprocessed data for the MR dataset.\n    Returns input vectors, labels, vocabulary, and inverse vocabulary.\n    \"\"\"\n    # Load and preprocess data\n    sentences, labels = load_data_and_labels()\n    sentences_padded = pad_sentences(sentences)\n    # vocabulary, vocabulary_inv = build_vocab(sentences_padded)\n    return build_input_data_with_word2vec(sentences_padded, labels, word2vec_list)",
        "history": [],
        "output": "Loads and preprocessed data for the MR dataset.\n    Returns input vectors, labels, vocabulary, and inverse vocabulary.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def create(self, msgtype, *args, **kwargs):\n        ''' Create a new Message instance for the given type.\n\n        Args:\n            msgtype (str) :\n\n        '''\n        if msgtype not in self._messages:\n            raise ProtocolError(\"Unknown message type %r for protocol version %s\" % (msgtype, self._version))\n        return self._messages[msgtype].create(*args, **kwargs)",
        "history": [],
        "output": "Create a new Message instance for the given type.\n\n        Args:\n            msgtype (str) :",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_dtype_counts(self):\r\n        \"\"\"Get the counts of dtypes in this object.\r\n\r\n        Returns:\r\n            The counts of dtypes in this object.\r\n        \"\"\"\r\n        if hasattr(self, \"dtype\"):\r\n            return pandas.Series({str(self.dtype): 1})\r\n        result = self.dtypes.value_counts()\r\n        result.index = result.index.map(lambda x: str(x))\r\n        return result",
        "history": [],
        "output": "Get the counts of dtypes in this object.\r\n\r\n        Returns:\r\n            The counts of dtypes in this object.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _html_to_img_tuples(html:str, format:str='jpg', n_images:int=10) -> list:    \n    \"Parse the google images html to img tuples containining `(fname, url)`\"\n    bs = BeautifulSoup(html, 'html.parser')\n    img_tags = bs.find_all('div', {'class': 'rg_meta'})\n    metadata_dicts = (json.loads(e.text) for e in img_tags)\n    img_tuples = ((_img_fname(d['ou']), d['ou']) for d in metadata_dicts if d['ity'] == format)\n    return list(itertools.islice(img_tuples, n_images))",
        "history": [],
        "output": "Parse the google images html to img tuples containining `(fname, url)`",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_word_at(self, coordinates):\r\n        \"\"\"Return word at *coordinates* (QPoint)\"\"\"\r\n        cursor = self.cursorForPosition(coordinates)\r\n        cursor.select(QTextCursor.WordUnderCursor)\r\n        return to_text_string(cursor.selectedText())",
        "history": [],
        "output": "Return word at *coordinates* (QPoint)",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_domain_name(self, domain_name, route53=True):\n        \"\"\"\n        Scan our hosted zones for the record of a given name.\n\n        Returns the record entry, else None.\n\n        \"\"\"\n        # Make sure api gateway domain is present\n        try:\n            self.apigateway_client.get_domain_name(domainName=domain_name)\n        except Exception:\n            return None\n\n        if not route53:\n            return True\n\n        try:\n            zones = self.get_all_zones()\n            for zone in zones['HostedZones']:\n                records = self.route53.list_resource_record_sets(HostedZoneId=zone['Id'])\n                for record in records['ResourceRecordSets']:\n                    if record['Type'] in ('CNAME', 'A') and record['Name'][:-1] == domain_name:\n                        return record\n\n        except Exception as e:\n            return None\n\n        ##\n        # Old, automatic logic.\n        # If re-introduced, should be moved to a new function.\n        # Related ticket: https://github.com/Miserlou/Zappa/pull/458\n        ##\n\n        # We may be in a position where Route53 doesn't have a domain, but the API Gateway does.\n        # We need to delete this before we can create the new Route53.\n        # try:\n        #     api_gateway_domain = self.apigateway_client.get_domain_name(domainName=domain_name)\n        #     self.apigateway_client.delete_domain_name(domainName=domain_name)\n        # except Exception:\n        #     pass\n\n        return None",
        "history": [],
        "output": "Scan our hosted zones for the record of a given name.\n\n        Returns the record entry, else None.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def copy(self, path, dest, raise_if_exists=False):\n        \"\"\"\n        Copies the contents of a single file path to dest\n        \"\"\"\n        if raise_if_exists and dest in self.get_all_data():\n            raise RuntimeError('Destination exists: %s' % path)\n        contents = self.get_all_data()[path]\n        self.get_all_data()[dest] = contents",
        "history": [],
        "output": "Copies the contents of a single file path to dest",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def imageFields(self):\n        \"\"\"\n        Returns field names of image columns.\n\n        :return: a list of field names.\n\n        .. versionadded:: 2.3.0\n        \"\"\"\n\n        if self._imageFields is None:\n            ctx = SparkContext._active_spark_context\n            self._imageFields = list(ctx._jvm.org.apache.spark.ml.image.ImageSchema.imageFields())\n        return self._imageFields",
        "history": [],
        "output": "Returns field names of image columns.\n\n        :return: a list of field names.\n\n        .. versionadded:: 2.3.0",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def run_oldstyle(self):\n        '''\n        Make the salt client call in old-style all-in-one call method\n        '''\n        arg = [self._load_files(), self.opts['dest']]\n        local = salt.client.get_local_client(self.opts['conf_file'])\n        args = [self.opts['tgt'],\n                'cp.recv',\n                arg,\n                self.opts['timeout'],\n                ]\n\n        selected_target_option = self.opts.get('selected_target_option', None)\n        if selected_target_option is not None:\n            args.append(selected_target_option)\n\n        return local.cmd(*args)",
        "history": [],
        "output": "Make the salt client call in old-style all-in-one call method",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def on_trial_remove(self, trial_runner, trial):\n        \"\"\"Notification when trial terminates.\n\n        Trial info is removed from bracket. Triggers halving if bracket is\n        not finished.\"\"\"\n        bracket, _ = self._trial_info[trial]\n        bracket.cleanup_trial(trial)\n        if not bracket.finished():\n            self._process_bracket(trial_runner, bracket, trial)",
        "history": [],
        "output": "Notification when trial terminates.\n\n        Trial info is removed from bracket. Triggers halving if bracket is\n        not finished.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _extract_submission(self, filename):\n    \"\"\"Extracts submission and moves it into self._extracted_submission_dir.\"\"\"\n    # verify filesize\n    file_size = os.path.getsize(filename)\n    if file_size > MAX_SUBMISSION_SIZE_ZIPPED:\n      logging.error('Submission archive size %d is exceeding limit %d',\n                    file_size, MAX_SUBMISSION_SIZE_ZIPPED)\n      return False\n    # determime archive type\n    exctract_command_tmpl = get_extract_command_template(filename)\n    if not exctract_command_tmpl:\n      logging.error('Input file has to be zip, tar or tar.gz archive; however '\n                    'found: %s', filename)\n      return False\n    # extract archive\n    submission_dir = os.path.dirname(filename)\n    submission_basename = os.path.basename(filename)\n    logging.info('Extracting archive %s', filename)\n    retval = shell_call(\n        ['docker', 'run',\n         '--network=none',\n         '-v', '{0}:/input_dir'.format(submission_dir),\n         '-v', '{0}:/output_dir'.format(self._tmp_extracted_dir),\n         'busybox:1.27.2'] + exctract_command_tmpl,\n        src=os.path.join('/input_dir', submission_basename),\n        dst='/output_dir')\n    if not retval:\n      logging.error('Failed to extract submission from file %s', filename)\n      return False\n    if not make_directory_writable(self._tmp_extracted_dir):\n      return False\n    # find submission root\n    root_dir = self._tmp_extracted_dir\n    root_dir_content = [d for d in os.listdir(root_dir) if d != '__MACOSX']\n    if (len(root_dir_content) == 1\n        and os.path.isdir(os.path.join(root_dir, root_dir_content[0]))):\n      logging.info('Looks like submission root is in subdirectory \"%s\" of '\n                   'the archive', root_dir_content[0])\n      root_dir = os.path.join(root_dir, root_dir_content[0])\n    # Move files to self._extracted_submission_dir.\n    # At this point self._extracted_submission_dir does not exist,\n    # so following command will simply rename root_dir into\n    # self._extracted_submission_dir\n    if not shell_call(['mv', root_dir, self._extracted_submission_dir]):\n      logging.error('Can''t move submission files from root directory')\n      return False\n    return True",
        "history": [],
        "output": "Extracts submission and moves it into self._extracted_submission_dir.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def prep_trans_tar(file_client, chunks, file_refs, pillar=None, id_=None, roster_grains=None):\n    '''\n    Generate the execution package from the saltenv file refs and a low state\n    data structure\n    '''\n    gendir = tempfile.mkdtemp()\n    trans_tar = salt.utils.files.mkstemp()\n    lowfn = os.path.join(gendir, 'lowstate.json')\n    pillarfn = os.path.join(gendir, 'pillar.json')\n    roster_grainsfn = os.path.join(gendir, 'roster_grains.json')\n    sync_refs = [\n            [salt.utils.url.create('_modules')],\n            [salt.utils.url.create('_states')],\n            [salt.utils.url.create('_grains')],\n            [salt.utils.url.create('_renderers')],\n            [salt.utils.url.create('_returners')],\n            [salt.utils.url.create('_output')],\n            [salt.utils.url.create('_utils')],\n            ]\n    with salt.utils.files.fopen(lowfn, 'w+') as fp_:\n        salt.utils.json.dump(chunks, fp_)\n    if pillar:\n        with salt.utils.files.fopen(pillarfn, 'w+') as fp_:\n            salt.utils.json.dump(pillar, fp_)\n    if roster_grains:\n        with salt.utils.files.fopen(roster_grainsfn, 'w+') as fp_:\n            salt.utils.json.dump(roster_grains, fp_)\n\n    if id_ is None:\n        id_ = ''\n    try:\n        cachedir = os.path.join('salt-ssh', id_).rstrip(os.sep)\n    except AttributeError:\n        # Minion ID should always be a str, but don't let an int break this\n        cachedir = os.path.join('salt-ssh', six.text_type(id_)).rstrip(os.sep)\n\n    for saltenv in file_refs:\n        # Location where files in this saltenv will be cached\n        cache_dest_root = os.path.join(cachedir, 'files', saltenv)\n        file_refs[saltenv].extend(sync_refs)\n        env_root = os.path.join(gendir, saltenv)\n        if not os.path.isdir(env_root):\n            os.makedirs(env_root)\n        for ref in file_refs[saltenv]:\n            for name in ref:\n                short = salt.utils.url.parse(name)[0].lstrip('/')\n                cache_dest = os.path.join(cache_dest_root, short)\n                try:\n                    path = file_client.cache_file(name, saltenv, cachedir=cachedir)\n                except IOError:\n                    path = ''\n                if path:\n                    tgt = os.path.join(env_root, short)\n                    tgt_dir = os.path.dirname(tgt)\n                    if not os.path.isdir(tgt_dir):\n                        os.makedirs(tgt_dir)\n                    shutil.copy(path, tgt)\n                    continue\n                try:\n                    files = file_client.cache_dir(name, saltenv, cachedir=cachedir)\n                except IOError:\n                    files = ''\n                if files:\n                    for filename in files:\n                        fn = filename[len(file_client.get_cachedir(cache_dest)):].strip('/')\n                        tgt = os.path.join(\n                                env_root,\n                                short,\n                                fn,\n                                )\n                        tgt_dir = os.path.dirname(tgt)\n                        if not os.path.isdir(tgt_dir):\n                            os.makedirs(tgt_dir)\n                        shutil.copy(filename, tgt)\n                    continue\n    try:\n        # cwd may not exist if it was removed but salt was run from it\n        cwd = os.getcwd()\n    except OSError:\n        cwd = None\n    os.chdir(gendir)\n    with closing(tarfile.open(trans_tar, 'w:gz')) as tfp:\n        for root, dirs, files in salt.utils.path.os_walk(gendir):\n            for name in files:\n                full = os.path.join(root, name)\n                tfp.add(full[len(gendir):].lstrip(os.sep))\n    if cwd:\n        os.chdir(cwd)\n    shutil.rmtree(gendir)\n    return trans_tar",
        "history": [],
        "output": "Generate the execution package from the saltenv file refs and a low state\n    data structure",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def merge_intervals(intervals):\n    \"\"\" Merge intervals in the form of a list. \"\"\"\n    if intervals is None:\n        return None\n    intervals.sort(key=lambda i: i[0])\n    out = [intervals.pop(0)]\n    for i in intervals:\n        if out[-1][-1] >= i[0]:\n            out[-1][-1] = max(out[-1][-1], i[-1])\n        else:\n            out.append(i)\n    return out",
        "history": [],
        "output": "Merge intervals in the form of a list.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def create_masked_lm_predictions(tokens, masked_lm_prob,\n                                 max_predictions_per_seq, vocab_words, rng):\n    \"\"\"Creates the predictions for the masked LM objective.\"\"\"\n\n    cand_indexes = []\n    for (i, token) in enumerate(tokens):\n        if token in ['[CLS]', '[SEP]']:\n            continue\n        cand_indexes.append(i)\n\n    rng.shuffle(cand_indexes)\n\n    output_tokens = list(tokens)\n\n    num_to_predict = min(max_predictions_per_seq,\n                         max(1, int(round(len(tokens) * masked_lm_prob))))\n\n    masked_lms = []\n    covered_indexes = set()\n    for index in cand_indexes:\n        if len(masked_lms) >= num_to_predict:\n            break\n        if index in covered_indexes:\n            continue\n        covered_indexes.add(index)\n\n        masked_token = None\n        # 80% of the time, replace with [MASK]\n        if rng.random() < 0.8:\n            masked_token = '[MASK]'\n        else:\n            # 10% of the time, keep original\n            if rng.random() < 0.5:\n                masked_token = tokens[index]\n            # 10% of the time, replace with random word\n            else:\n                masked_token = vocab_words[rng.randint(0,\n                                                       len(vocab_words) - 1)]\n\n        output_tokens[index] = masked_token\n\n        masked_lms.append(MaskedLmInstance(index=index, label=tokens[index]))\n\n    masked_lms = sorted(masked_lms, key=lambda x: x.index)\n\n    masked_lm_positions = []\n    masked_lm_labels = []\n    for p in masked_lms:\n        masked_lm_positions.append(p.index)\n        masked_lm_labels.append(p.label)\n\n    return (output_tokens, masked_lm_positions, masked_lm_labels)",
        "history": [],
        "output": "Creates the predictions for the masked LM objective.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _check_names_match(data_names, data_shapes, name, throw):\n    \"\"\"Check that input names matches input data descriptors.\"\"\"\n    actual = [x[0] for x in data_shapes]\n    if sorted(data_names) != sorted(actual):\n        msg = \"Data provided by %s_shapes don't match names specified by %s_names (%s vs. %s)\"%(\n            name, name, str(data_shapes), str(data_names))\n        if throw:\n            raise ValueError(msg)\n        else:\n            warnings.warn(msg)",
        "history": [],
        "output": "Check that input names matches input data descriptors.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def launch():\n  \"\"\"Launch t2t_trainer on Cloud ML Engine.\"\"\"\n  validate_flags()\n  job_spec = configure_job()\n  job_name = job_spec[\"jobId\"]\n  tf.logging.info(\"Launching job %s with ML Engine spec:\\n%s\", job_name,\n                  pprint.pformat(job_spec))\n  assert confirm()\n  train_dir = FLAGS.output_dir\n  t2t_tar = tar_and_copy_t2t(train_dir)\n  configure_trainer_package(job_spec, t2t_tar)\n  if FLAGS.t2t_usr_dir:\n    usr_tar = tar_and_copy_usr_dir(FLAGS.t2t_usr_dir, train_dir)\n    configure_usr_dir(job_spec, usr_tar)\n  launch_job(job_spec)\n  tf.logging.info(\"Launched %s. See console to track: %s.\", job_name,\n                  CONSOLE_URL)\n  tf.logging.info(\"Interact with the training job from the command line:\")\n  tf.logging.info(\"Abort job: gcloud ml-engine jobs cancel %s\", job_name)\n  tf.logging.info(\"Stream logs: gcloud ml-engine jobs stream-logs %s\", job_name)\n  tf.logging.info(\"Open tensorboard: tensorboard --logdir %s\", train_dir)",
        "history": [],
        "output": "Launch t2t_trainer on Cloud ML Engine.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def score_url(self, url):\n        \"\"\"\n        Give an url a score which can be used to choose preferred URLs\n        for a given project release.\n        \"\"\"\n        t = urlparse(url)\n        basename = posixpath.basename(t.path)\n        compatible = True\n        is_wheel = basename.endswith('.whl')\n        is_downloadable = basename.endswith(self.downloadable_extensions)\n        if is_wheel:\n            compatible = is_compatible(Wheel(basename), self.wheel_tags)\n        return (t.scheme == 'https', 'pypi.python.org' in t.netloc,\n                is_downloadable, is_wheel, compatible, basename)",
        "history": [],
        "output": "Give an url a score which can be used to choose preferred URLs\n        for a given project release.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def maybe_load_model(savedir, container):\n  \"\"\"Load model if present at the specified path.\"\"\"\n  if savedir is None:\n    return\n\n  state_path = os.path.join(os.path.join(savedir, 'training_state.pkl.zip'))\n  if container is not None:\n    logger.log(\"Attempting to download model from Azure\")\n    found_model = container.get(savedir, 'training_state.pkl.zip')\n  else:\n    found_model = os.path.exists(state_path)\n  if found_model:\n    state = pickle_load(state_path, compression=True)\n    model_dir = \"model-{}\".format(state[\"num_iters\"])\n    if container is not None:\n      container.get(savedir, model_dir)\n    U.load_state(os.path.join(savedir, model_dir, \"saved\"))\n    logger.log(\"Loaded models checkpoint at {} iterations\".format(\n        state[\"num_iters\"]))\n    return state",
        "history": [],
        "output": "Load model if present at the specified path.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_collection(self):\n        \"\"\"\n        Return targeted mongo collection to query on\n        \"\"\"\n        db_mongo = self._mongo_client[self._index]\n        return db_mongo[self._collection]",
        "history": [],
        "output": "Return targeted mongo collection to query on",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def closing_plugin(self, cancelable=False):\r\n        \"\"\"Perform actions before parent main window is closed\"\"\"\r\n        self.save_history()\r\n        self.set_option('zoom_factor',\r\n                        self.pydocbrowser.webview.get_zoom_factor())\r\n        return True",
        "history": [],
        "output": "Perform actions before parent main window is closed",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def make_output_layers(self):\n        \"\"\"\n        Extract the ordering of output layers.\n        \"\"\"\n        self.output_layers = []\n        # import pytest; pytest.set_trace()\n        if hasattr(self.model, 'output_layers'):\n            # find corresponding output layers in CoreML model\n            # assume output layers are not shared\n            # Helper function to recursively extract output layers\n            # even if the model has a layer which is a nested model\n            def extract_output_layers(keras_model):\n                output_layers = []\n                for layer in keras_model.output_layers:\n                    if hasattr(layer,'output_layers'):\n                        output_layers.extend(extract_output_layers(layer))\n                    else:\n                        output_layers.append(layer)\n                return output_layers\n\n            for kl in extract_output_layers(self.model):\n                coreml_layers = self.get_coreml_layers(kl)\n                if len(coreml_layers) > 0:\n                    for cl in coreml_layers:\n                        self.output_layers.append(cl)\n        elif len(self.model.outputs) > 0:\n            for model_output in self.model.outputs:\n                for l in self.layer_list:\n                    k_layer = self.keras_layer_map[l]\n                    in_nodes = k_layer._inbound_nodes if hasattr(k_layer, '_inbound_nodes') else k_layer.inbound_nodes\n                    for idx in range(len(in_nodes)):\n                        out_tensor = k_layer.get_output_at(idx)\n                        if out_tensor == model_output or (out_tensor.name in model_output.name):\n                            self.output_layers.append(l)\n        if len(self.output_layers) == 0:\n            raise ValueError(\"No outputs can be identified\")",
        "history": [],
        "output": "Extract the ordering of output layers.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def nth_char(char_map, index):\n    \"\"\"Returns the nth character of a character->occurrence map\"\"\"\n    for char in char_map:\n        if index < char_map[char]:\n            return char\n        index = index - char_map[char]\n    return None",
        "history": [],
        "output": "Returns the nth character of a character->occurrence map",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def text_channels(self):\n        \"\"\"List[:class:`TextChannel`]: Returns the text channels that are under this category.\"\"\"\n        ret = [c for c in self.guild.channels\n            if c.category_id == self.id\n            and isinstance(c, TextChannel)]\n        ret.sort(key=lambda c: (c.position, c.id))\n        return ret",
        "history": [],
        "output": "List[:class:`TextChannel`]: Returns the text channels that are under this category.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_connection(self):\n        \"\"\"\n        Return a pair of socket object and string address.\n\n        May block!\n        \"\"\"\n        conn = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        try:\n            conn.bind(self._agent._get_filename())\n            conn.listen(1)\n            (r, addr) = conn.accept()\n            return r, addr\n        except:\n            raise",
        "history": [],
        "output": "Return a pair of socket object and string address.\n\n        May block!",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def Place(self, x, flags):\n        \"\"\"\n        Place prepends a value specified by `flags` to the Builder,\n        without checking for available space.\n        \"\"\"\n\n        N.enforce_number(x, flags)\n        self.head = self.head - flags.bytewidth\n        encode.Write(flags.packer_type, self.Bytes, self.Head(), x)",
        "history": [],
        "output": "Place prepends a value specified by `flags` to the Builder,\n        without checking for available space.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def generator(self, z):\n        \"\"\" return an image generated from z\"\"\"\n        nf = 64\n        l = FullyConnected('fc0', z, nf * 8 * 4 * 4, activation=tf.identity)\n        l = tf.reshape(l, [-1, 4, 4, nf * 8])\n        l = BNReLU(l)\n        with argscope(Conv2DTranspose, activation=BNReLU, kernel_size=4, strides=2):\n            l = Conv2DTranspose('deconv1', l, nf * 4)\n            l = Conv2DTranspose('deconv2', l, nf * 2)\n            l = Conv2DTranspose('deconv3', l, nf)\n            l = Conv2DTranspose('deconv4', l, 3, activation=tf.identity)\n            l = tf.tanh(l, name='gen')\n        return l",
        "history": [],
        "output": "return an image generated from z",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def minibatch(items, size=8):\n    \"\"\"Iterate over batches of items. `size` may be an iterator,\n    so that batch-size can vary on each step.\n    \"\"\"\n    if isinstance(size, int):\n        size_ = itertools.repeat(size)\n    else:\n        size_ = size\n    items = iter(items)\n    while True:\n        batch_size = next(size_)\n        batch = list(itertools.islice(items, int(batch_size)))\n        if len(batch) == 0:\n            break\n        yield list(batch)",
        "history": [],
        "output": "Iterate over batches of items. `size` may be an iterator,\n    so that batch-size can vary on each step.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _split_generators(self, dl_manager):\n    \"\"\"Returns SplitGenerators from the folder names.\"\"\"\n    # At data creation time, parse the folder to deduce number of splits,\n    # labels, image size,\n\n    # The splits correspond to the high level folders\n    split_names = list_folders(dl_manager.manual_dir)\n\n    # Extract all label names and associated images\n    split_label_images = {}  # dict[split_name][label_name] = list(img_paths)\n    for split_name in split_names:\n      split_dir = os.path.join(dl_manager.manual_dir, split_name)\n      split_label_images[split_name] = {\n          label_name: list_imgs(os.path.join(split_dir, label_name))\n          for label_name in list_folders(split_dir)\n      }\n\n    # Merge all label names from all splits to get the final list of labels\n    # Sorted list for determinism\n    labels = [split.keys() for split in split_label_images.values()]\n    labels = list(sorted(set(itertools.chain(*labels))))\n\n    # Could improve the automated encoding format detection\n    # Extract the list of all image paths\n    image_paths = [\n        image_paths\n        for label_images in split_label_images.values()\n        for image_paths in label_images.values()\n    ]\n    if any(f.lower().endswith(\".png\") for f in itertools.chain(*image_paths)):\n      encoding_format = \"png\"\n    else:\n      encoding_format = \"jpeg\"\n\n    # Update the info.features. Those info will be automatically resored when\n    # the dataset is re-created\n    self.info.features[\"image\"].set_encoding_format(encoding_format)\n    self.info.features[\"label\"].names = labels\n\n    def num_examples(label_images):\n      return sum(len(imgs) for imgs in label_images.values())\n\n    # Define the splits\n    return [\n        tfds.core.SplitGenerator(\n            name=split_name,\n            # The number of shards is a dynamic function of the total\n            # number of images (between 0-10)\n            num_shards=min(10, max(num_examples(label_images) // 1000, 1)),\n            gen_kwargs=dict(label_images=label_images,),\n        ) for split_name, label_images in split_label_images.items()\n    ]",
        "history": [],
        "output": "Returns SplitGenerators from the folder names.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def role_list(profile=None, **connection_args):\n    '''\n    Return a list of available roles (keystone role-list)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' keystone.role_list\n    '''\n    kstone = auth(profile, **connection_args)\n    ret = {}\n    for role in kstone.roles.list():\n        ret[role.name] = dict((value, getattr(role, value)) for value in dir(role)\n                              if not value.startswith('_') and\n                              isinstance(getattr(role, value), (six.string_types, dict, bool)))\n    return ret",
        "history": [],
        "output": "Return a list of available roles (keystone role-list)\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' keystone.role_list",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def next_frame_basic_stochastic():\n  \"\"\"Basic 2-frame conv model with stochastic tower.\"\"\"\n  hparams = basic_deterministic_params.next_frame_basic_deterministic()\n  hparams.stochastic_model = True\n  hparams.add_hparam(\"latent_channels\", 1)\n  hparams.add_hparam(\"latent_std_min\", -5.0)\n  hparams.add_hparam(\"num_iterations_1st_stage\", 15000)\n  hparams.add_hparam(\"num_iterations_2nd_stage\", 15000)\n  hparams.add_hparam(\"latent_loss_multiplier\", 1e-3)\n  hparams.add_hparam(\"latent_loss_multiplier_dynamic\", False)\n  hparams.add_hparam(\"latent_loss_multiplier_alpha\", 1e-5)\n  hparams.add_hparam(\"latent_loss_multiplier_epsilon\", 1.0)\n  hparams.add_hparam(\"latent_loss_multiplier_schedule\", \"constant\")\n  hparams.add_hparam(\"latent_num_frames\", 0)  # 0 means use all frames.\n  hparams.add_hparam(\"anneal_end\", 50000)\n  hparams.add_hparam(\"information_capacity\", 0.0)\n  return hparams",
        "history": [],
        "output": "Basic 2-frame conv model with stochastic tower.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def parse_args():\n    '''Definite the arguments users need to follow and input'''\n    parser = argparse.ArgumentParser(prog='nnictl', description='use nnictl command to control nni experiments')\n    parser.add_argument('--version', '-v', action='store_true')\n    parser.set_defaults(func=nni_info)\n\n    # create subparsers for args with sub values\n    subparsers = parser.add_subparsers()\n\n    # parse start command\n    parser_start = subparsers.add_parser('create', help='create a new experiment')\n    parser_start.add_argument('--config', '-c', required=True, dest='config', help='the path of yaml config file')\n    parser_start.add_argument('--port', '-p', default=DEFAULT_REST_PORT, dest='port', help='the port of restful server')\n    parser_start.add_argument('--debug', '-d', action='store_true', help=' set debug mode')\n    parser_start.set_defaults(func=create_experiment)\n\n    # parse resume command\n    parser_resume = subparsers.add_parser('resume', help='resume a new experiment')\n    parser_resume.add_argument('id', nargs='?', help='The id of the experiment you want to resume')\n    parser_resume.add_argument('--port', '-p', default=DEFAULT_REST_PORT, dest='port', help='the port of restful server')\n    parser_resume.add_argument('--debug', '-d', action='store_true', help=' set debug mode')\n    parser_resume.set_defaults(func=resume_experiment)\n\n    # parse update command\n    parser_updater = subparsers.add_parser('update', help='update the experiment')\n    #add subparsers for parser_updater\n    parser_updater_subparsers = parser_updater.add_subparsers()\n    parser_updater_searchspace = parser_updater_subparsers.add_parser('searchspace', help='update searchspace')\n    parser_updater_searchspace.add_argument('id', nargs='?', help='the id of experiment')\n    parser_updater_searchspace.add_argument('--filename', '-f', required=True)\n    parser_updater_searchspace.set_defaults(func=update_searchspace)\n    parser_updater_concurrency = parser_updater_subparsers.add_parser('concurrency', help='update concurrency')\n    parser_updater_concurrency.add_argument('id', nargs='?', help='the id of experiment')\n    parser_updater_concurrency.add_argument('--value', '-v', required=True)\n    parser_updater_concurrency.set_defaults(func=update_concurrency)\n    parser_updater_duration = parser_updater_subparsers.add_parser('duration', help='update duration')\n    parser_updater_duration.add_argument('id', nargs='?', help='the id of experiment')\n    parser_updater_duration.add_argument('--value', '-v', required=True, help='the unit of time should in {\\'s\\', \\'m\\', \\'h\\', \\'d\\'}')\n    parser_updater_duration.set_defaults(func=update_duration)\n    parser_updater_trialnum = parser_updater_subparsers.add_parser('trialnum', help='update maxtrialnum')\n    parser_updater_trialnum.add_argument('--id', '-i', dest='id', help='the id of experiment')\n    parser_updater_trialnum.add_argument('--value', '-v', required=True)\n    parser_updater_trialnum.set_defaults(func=update_trialnum)\n\n    #parse stop command\n    parser_stop = subparsers.add_parser('stop', help='stop the experiment')\n    parser_stop.add_argument('id', nargs='?', help='the id of experiment, use \\'all\\' to stop all running experiments')\n    parser_stop.set_defaults(func=stop_experiment)\n\n    #parse trial command\n    parser_trial = subparsers.add_parser('trial', help='get trial information')\n    #add subparsers for parser_trial\n    parser_trial_subparsers = parser_trial.add_subparsers()\n    parser_trial_ls = parser_trial_subparsers.add_parser('ls', help='list trial jobs')\n    parser_trial_ls.add_argument('id', nargs='?', help='the id of experiment')\n    parser_trial_ls.set_defaults(func=trial_ls)\n    parser_trial_kill = parser_trial_subparsers.add_parser('kill', help='kill trial jobs')\n    parser_trial_kill.add_argument('id', nargs='?', help='the id of experiment')\n    parser_trial_kill.add_argument('--trial_id', '-T', required=True, dest='trial_id', help='the id of trial to be killed')\n    parser_trial_kill.set_defaults(func=trial_kill)\n\n    #parse experiment command\n    parser_experiment = subparsers.add_parser('experiment', help='get experiment information')\n    #add subparsers for parser_experiment\n    parser_experiment_subparsers = parser_experiment.add_subparsers()\n    parser_experiment_show = parser_experiment_subparsers.add_parser('show', help='show the information of experiment')\n    parser_experiment_show.add_argument('id', nargs='?', help='the id of experiment')\n    parser_experiment_show.set_defaults(func=list_experiment)\n    parser_experiment_status = parser_experiment_subparsers.add_parser('status', help='show the status of experiment')\n    parser_experiment_status.add_argument('id', nargs='?', help='the id of experiment')\n    parser_experiment_status.set_defaults(func=experiment_status)\n    parser_experiment_list = parser_experiment_subparsers.add_parser('list', help='list all of running experiment ids')\n    parser_experiment_list.add_argument('all', nargs='?', help='list all of experiments')\n    parser_experiment_list.set_defaults(func=experiment_list)\n    #import tuning data\n    parser_import_data = parser_experiment_subparsers.add_parser('import', help='import additional data')\n    parser_import_data.add_argument('id', nargs='?', help='the id of experiment')\n    parser_import_data.add_argument('--filename', '-f', required=True)\n    parser_import_data.set_defaults(func=import_data)\n    #export trial data\n    parser_trial_export = parser_experiment_subparsers.add_parser('export', help='export trial job results to csv or json')\n    parser_trial_export.add_argument('id', nargs='?', help='the id of experiment')\n    parser_trial_export.add_argument('--type', '-t', choices=['json', 'csv'], required=True, dest='type', help='target file type')\n    parser_trial_export.add_argument('--filename', '-f', required=True, dest='path', help='target file path')\n    parser_trial_export.set_defaults(func=export_trials_data)\n\n    #TODO:finish webui function\n    #parse board command\n    parser_webui = subparsers.add_parser('webui', help='get web ui information')\n    #add subparsers for parser_board\n    parser_webui_subparsers = parser_webui.add_subparsers()\n    parser_webui_url = parser_webui_subparsers.add_parser('url', help='show the url of web ui')\n    parser_webui_url.add_argument('id', nargs='?', help='the id of experiment')\n    parser_webui_url.set_defaults(func=webui_url)\n\n    #parse config command\n    parser_config = subparsers.add_parser('config', help='get config information')\n    parser_config_subparsers = parser_config.add_subparsers()\n    parser_config_show = parser_config_subparsers.add_parser('show', help='show the information of config')\n    parser_config_show.add_argument('id', nargs='?', help='the id of experiment')\n    parser_config_show.set_defaults(func=get_config)\n\n    #parse log command\n    parser_log = subparsers.add_parser('log', help='get log information')\n    # add subparsers for parser_log\n    parser_log_subparsers = parser_log.add_subparsers()\n    parser_log_stdout = parser_log_subparsers.add_parser('stdout', help='get stdout information')\n    parser_log_stdout.add_argument('id', nargs='?', help='the id of experiment')\n    parser_log_stdout.add_argument('--tail', '-T', dest='tail', type=int, help='get tail -100 content of stdout')\n    parser_log_stdout.add_argument('--head', '-H', dest='head', type=int, help='get head -100 content of stdout')\n    parser_log_stdout.add_argument('--path', action='store_true', default=False, help='get the path of stdout file')\n    parser_log_stdout.set_defaults(func=log_stdout)\n    parser_log_stderr = parser_log_subparsers.add_parser('stderr', help='get stderr information')\n    parser_log_stderr.add_argument('id', nargs='?', help='the id of experiment')\n    parser_log_stderr.add_argument('--tail', '-T', dest='tail', type=int, help='get tail -100 content of stderr')\n    parser_log_stderr.add_argument('--head', '-H', dest='head', type=int, help='get head -100 content of stderr')\n    parser_log_stderr.add_argument('--path', action='store_true', default=False, help='get the path of stderr file')\n    parser_log_stderr.set_defaults(func=log_stderr)\n    parser_log_trial = parser_log_subparsers.add_parser('trial', help='get trial log path')\n    parser_log_trial.add_argument('id', nargs='?', help='the id of experiment')\n    parser_log_trial.add_argument('--trial_id', '-T', dest='trial_id', help='find trial log path by id')\n    parser_log_trial.set_defaults(func=log_trial)\n\n    #parse package command\n    parser_package = subparsers.add_parser('package', help='control nni tuner and assessor packages')\n    # add subparsers for parser_package\n    parser_package_subparsers = parser_package.add_subparsers()\n    parser_package_install = parser_package_subparsers.add_parser('install', help='install packages')\n    parser_package_install.add_argument('--name', '-n', dest='name', help='package name to be installed')\n    parser_package_install.set_defaults(func=package_install) \n    parser_package_show = parser_package_subparsers.add_parser('show', help='show the information of packages')\n    parser_package_show.set_defaults(func=package_show)\n\n    #parse tensorboard command\n    parser_tensorboard = subparsers.add_parser('tensorboard', help='manage tensorboard')\n    parser_tensorboard_subparsers = parser_tensorboard.add_subparsers()\n    parser_tensorboard_start = parser_tensorboard_subparsers.add_parser('start', help='start tensorboard')\n    parser_tensorboard_start.add_argument('id', nargs='?', help='the id of experiment')\n    parser_tensorboard_start.add_argument('--trial_id', '-T', dest='trial_id', help='the id of trial')\n    parser_tensorboard_start.add_argument('--port', dest='port', default=6006, help='the port to start tensorboard')\n    parser_tensorboard_start.set_defaults(func=start_tensorboard)\n    parser_tensorboard_start = parser_tensorboard_subparsers.add_parser('stop', help='stop tensorboard')\n    parser_tensorboard_start.add_argument('id', nargs='?', help='the id of experiment')\n    parser_tensorboard_start.set_defaults(func=stop_tensorboard)\n\n    #parse top command\n    parser_top = subparsers.add_parser('top', help='monitor the experiment')\n    parser_top.add_argument('--time', '-t', dest='time', type=int, default=3, help='the time interval to update the experiment status, ' \\\n    'the unit is second')\n    parser_top.set_defaults(func=monitor_experiment)\n\n    args = parser.parse_args()\n    args.func(args)",
        "history": [],
        "output": "Definite the arguments users need to follow and input",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def is_fully_defined(self):\n        \"\"\"Returns True iff `self` is fully defined in every dimension.\"\"\"\n        return self._dims is not None and all(\n            dim.value is not None for dim in self._dims\n        )",
        "history": [],
        "output": "Returns True iff `self` is fully defined in every dimension.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_transform(self, model_output):\n        \"\"\" A consistent interface to make predictions from this model.\n        \"\"\"\n        if model_output == \"margin\":\n            transform = \"identity\"\n        elif model_output == \"probability\":\n            if self.tree_output == \"log_odds\":\n                transform = \"logistic\"\n            elif self.tree_output == \"probability\":\n                transform = \"identity\"\n            else:\n                raise Exception(\"model_output = \\\"probability\\\" is not yet supported when model.tree_output = \\\"\" + self.tree_output + \"\\\"!\")\n        elif model_output == \"logloss\":\n\n            if self.objective == \"squared_error\":\n                transform = \"squared_loss\"\n            elif self.objective == \"binary_crossentropy\":\n                transform = \"logistic_nlogloss\"\n            else:\n                raise Exception(\"model_output = \\\"logloss\\\" is not yet supported when model.objective = \\\"\" + self.objective + \"\\\"!\")\n        return transform",
        "history": [],
        "output": "A consistent interface to make predictions from this model.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _exploit(self, trial_executor, trial, trial_to_clone):\n        \"\"\"Transfers perturbed state from trial_to_clone -> trial.\n\n        If specified, also logs the updated hyperparam state.\"\"\"\n\n        trial_state = self._trial_state[trial]\n        new_state = self._trial_state[trial_to_clone]\n        if not new_state.last_checkpoint:\n            logger.info(\"[pbt]: no checkpoint for trial.\"\n                        \" Skip exploit for Trial {}\".format(trial))\n            return\n        new_config = explore(trial_to_clone.config, self._hyperparam_mutations,\n                             self._resample_probability,\n                             self._custom_explore_fn)\n        logger.info(\"[exploit] transferring weights from trial \"\n                    \"{} (score {}) -> {} (score {})\".format(\n                        trial_to_clone, new_state.last_score, trial,\n                        trial_state.last_score))\n\n        if self._log_config:\n            self._log_config_on_step(trial_state, new_state, trial,\n                                     trial_to_clone, new_config)\n\n        new_tag = make_experiment_tag(trial_state.orig_tag, new_config,\n                                      self._hyperparam_mutations)\n        reset_successful = trial_executor.reset_trial(trial, new_config,\n                                                      new_tag)\n        if reset_successful:\n            trial_executor.restore(\n                trial, Checkpoint.from_object(new_state.last_checkpoint))\n        else:\n            trial_executor.stop_trial(trial, stop_logger=False)\n            trial.config = new_config\n            trial.experiment_tag = new_tag\n            trial_executor.start_trial(\n                trial, Checkpoint.from_object(new_state.last_checkpoint))\n\n        self._num_perturbations += 1\n        # Transfer over the last perturbation time as well\n        trial_state.last_perturbation_time = new_state.last_perturbation_time",
        "history": [],
        "output": "Transfers perturbed state from trial_to_clone -> trial.\n\n        If specified, also logs the updated hyperparam state.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def mouseMoveEvent(self, event):\n        \"\"\"Override Qt method.\n\n        Show code analisis, if left button pressed select lines.\n        \"\"\"\n        line_number = self.editor.get_linenumber_from_mouse_event(event)\n        block = self.editor.document().findBlockByNumber(line_number-1)\n        data = block.userData()\n\n        # this disables pyflakes messages if there is an active drag/selection\n        # operation\n        check = self._released == -1\n        if data and data.code_analysis and check:\n            self.editor.show_code_analysis_results(line_number,\n                                                   data)\n        else:\n            self.editor.hide_tooltip()\n\n        if event.buttons() == Qt.LeftButton:\n            self._released = line_number\n            self.editor.select_lines(self._pressed, self._released)",
        "history": [],
        "output": "Override Qt method.\n\n        Show code analisis, if left button pressed select lines.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def apply(\n            self,\n            query: BaseQuery,\n            func: Callable) -> BaseQuery:\n        \"\"\"\n        Filter queries to only those owned by current user if\n        can_only_access_owned_queries permission is set.\n\n        :returns: query\n        \"\"\"\n        if security_manager.can_only_access_owned_queries():\n            query = (\n                query\n                .filter(Query.user_id == g.user.get_user_id())\n            )\n        return query",
        "history": [],
        "output": "Filter queries to only those owned by current user if\n        can_only_access_owned_queries permission is set.\n\n        :returns: query",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def collect_metrics(local_evaluator=None,\n                    remote_evaluators=[],\n                    timeout_seconds=180):\n    \"\"\"Gathers episode metrics from PolicyEvaluator instances.\"\"\"\n\n    episodes, num_dropped = collect_episodes(\n        local_evaluator, remote_evaluators, timeout_seconds=timeout_seconds)\n    metrics = summarize_episodes(episodes, episodes, num_dropped)\n    return metrics",
        "history": [],
        "output": "Gathers episode metrics from PolicyEvaluator instances.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _process_all_1(self, texts:Collection[str]) -> List[List[str]]:\n        \"Process a list of `texts` in one process.\"\n        tok = self.tok_func(self.lang)\n        if self.special_cases: tok.add_special_cases(self.special_cases)\n        return [self.process_text(str(t), tok) for t in texts]",
        "history": [],
        "output": "Process a list of `texts` in one process.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def attention(query: torch.Tensor,\n              key: torch.Tensor,\n              value: torch.Tensor,\n              mask: torch.Tensor = None,\n              dropout: Callable = None) -> Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"Compute 'Scaled Dot Product Attention'\"\"\"\n    d_k = query.size(-1)\n    scores = torch.matmul(query, key.transpose(-2, -1)) / math.sqrt(d_k)\n    if mask is not None:\n        scores = scores.masked_fill(mask == 0, -1e9)\n    p_attn = F.softmax(scores, dim=-1)\n    if dropout is not None:\n        p_attn = dropout(p_attn)\n    return torch.matmul(p_attn, value), p_attn",
        "history": [],
        "output": "Compute 'Scaled Dot Product Attention",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def autoencoder_range(rhp):\n  \"\"\"Tuning grid of the main autoencoder params.\"\"\"\n  rhp.set_float(\"dropout\", 0.01, 0.3)\n  rhp.set_float(\"gan_loss_factor\", 0.01, 0.1)\n  rhp.set_float(\"bottleneck_l2_factor\", 0.001, 0.1, scale=rhp.LOG_SCALE)\n  rhp.set_discrete(\"bottleneck_warmup_steps\", [200, 2000])\n  rhp.set_float(\"gumbel_temperature\", 0, 1)\n  rhp.set_float(\"gumbel_noise_factor\", 0, 0.5)",
        "history": [],
        "output": "Tuning grid of the main autoencoder params.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def search_range(nums, target):\n    \"\"\"\n    :type nums: List[int]\n    :type target: int\n    :rtype: List[int]\n    \"\"\"\n    low = 0\n    high = len(nums) - 1\n    while low <= high:\n        mid = low + (high - low) // 2\n        if target < nums[mid]:\n            high = mid - 1\n        elif target > nums[mid]:\n            low = mid + 1\n        else:\n            break\n\n    for j in range(len(nums) - 1, -1, -1):\n        if nums[j] == target:\n            return [mid, j]\n\n    return [-1, -1]",
        "history": [],
        "output": ":type nums: List[int]\n    :type target: int\n    :rtype: List[int]",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def synchronize(self):\r\n        \"\"\"\r\n        Synchronize Spyder's path list with PYTHONPATH environment variable\r\n        Only apply to: current user, on Windows platforms\r\n        \"\"\"\r\n        answer = QMessageBox.question(self, _(\"Synchronize\"),\r\n            _(\"This will synchronize Spyder's path list with \"\r\n                    \"<b>PYTHONPATH</b> environment variable for current user, \"\r\n                    \"allowing you to run your Python modules outside Spyder \"\r\n                    \"without having to configure sys.path. \"\r\n                    \"<br>Do you want to clear contents of PYTHONPATH before \"\r\n                    \"adding Spyder's path list?\"),\r\n            QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel)\r\n        if answer == QMessageBox.Cancel:\r\n            return\r\n        elif answer == QMessageBox.Yes:\r\n            remove = True\r\n        else:\r\n            remove = False\r\n        from spyder.utils.environ import (get_user_env, set_user_env,\r\n                                          listdict2envdict)\r\n        env = get_user_env()\r\n        if remove:\r\n            ppath = self.active_pathlist+self.ro_pathlist\r\n        else:\r\n            ppath = env.get('PYTHONPATH', [])\r\n            if not isinstance(ppath, list):\r\n                ppath = [ppath]\r\n            ppath = [path for path in ppath\r\n                     if path not in (self.active_pathlist+self.ro_pathlist)]\r\n            ppath.extend(self.active_pathlist+self.ro_pathlist)\r\n        env['PYTHONPATH'] = ppath\r\n        set_user_env(listdict2envdict(env), parent=self)",
        "history": [],
        "output": "Synchronize Spyder's path list with PYTHONPATH environment variable\r\n        Only apply to: current user, on Windows platforms",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def set_as_spell_check(self, color=Qt.blue):\n        \"\"\"\n        Underlines text as a spellcheck error.\n\n        :param color: Underline color\n        :type color: QtGui.QColor\n        \"\"\"\n        self.format.setUnderlineStyle(\n            QTextCharFormat.SpellCheckUnderline)\n        self.format.setUnderlineColor(color)",
        "history": [],
        "output": "Underlines text as a spellcheck error.\n\n        :param color: Underline color\n        :type color: QtGui.QColor",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def convert_depthtospace(node, **kwargs):\n    \"\"\"Map MXNet's depth_to_space operator attributes to onnx's\n    DepthToSpace operator and return the created node.\n    \"\"\"\n    name, input_nodes, attrs = get_inputs(node, kwargs)\n\n    blksize = int(attrs.get(\"block_size\", 0))\n\n    node = onnx.helper.make_node(\n        \"DepthToSpace\",\n        input_nodes,\n        [name],\n        blocksize=blksize,\n        name=name,\n    )\n    return [node]",
        "history": [],
        "output": "Map MXNet's depth_to_space operator attributes to onnx's\n    DepthToSpace operator and return the created node.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def highlight_block(self, text):\r\n        \"\"\"Implement highlight specific for Fortran.\"\"\"\r\n        text = to_text_string(text)\r\n        self.setFormat(0, len(text), self.formats[\"normal\"])\r\n        \r\n        match = self.PROG.search(text)\r\n        index = 0\r\n        while match:\r\n            for key, value in list(match.groupdict().items()):\r\n                if value:\r\n                    start, end = match.span(key)\r\n                    index += end-start\r\n                    self.setFormat(start, end-start, self.formats[key])\r\n                    if value.lower() in (\"subroutine\", \"module\", \"function\"):\r\n                        match1 = self.IDPROG.match(text, end)\r\n                        if match1:\r\n                            start1, end1 = match1.span(1)\r\n                            self.setFormat(start1, end1-start1,\r\n                                           self.formats[\"definition\"])\r\n                    \r\n            match = self.PROG.search(text, match.end())\r\n        \r\n        self.highlight_spaces(text)",
        "history": [],
        "output": "Implement highlight specific for Fortran.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _lookup_element(lst, key):\n    '''\n    Find an dictionary in a list of dictionaries, given its main key.\n    '''\n    if not lst:\n        return {}\n    for ele in lst:\n        if not ele or not isinstance(ele, dict):\n            continue\n        if ele.keys()[0] == key:\n            return ele.values()[0]\n    return {}",
        "history": [],
        "output": "Find an dictionary in a list of dictionaries, given its main key.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def rle_encode(img:NPArrayMask)->str:\n    \"Return run-length encoding string from `img`.\"\n    pixels = np.concatenate([[0], img.flatten() , [0]])\n    runs = np.where(pixels[1:] != pixels[:-1])[0] + 1\n    runs[1::2] -= runs[::2]\n    return ' '.join(str(x) for x in runs)",
        "history": [],
        "output": "Return run-length encoding string from `img`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def load_misc_dashboard():\n    \"\"\"Loading a dashboard featuring misc charts\"\"\"\n\n    print('Creating the dashboard')\n    db.session.expunge_all()\n    dash = db.session.query(Dash).filter_by(slug=DASH_SLUG).first()\n\n    if not dash:\n        dash = Dash()\n    js = textwrap.dedent(\"\"\"\\\n{\n    \"CHART-BkeVbh8ANQ\": {\n        \"children\": [],\n        \"id\": \"CHART-BkeVbh8ANQ\",\n        \"meta\": {\n            \"chartId\": 4004,\n            \"height\": 34,\n            \"sliceName\": \"Multi Line\",\n            \"width\": 8\n        },\n        \"type\": \"CHART\"\n    },\n    \"CHART-H1HYNzEANX\": {\n        \"children\": [],\n        \"id\": \"CHART-H1HYNzEANX\",\n        \"meta\": {\n            \"chartId\": 3940,\n            \"height\": 50,\n            \"sliceName\": \"Energy Sankey\",\n            \"width\": 6\n        },\n        \"type\": \"CHART\"\n    },\n    \"CHART-HJOYVMV0E7\": {\n        \"children\": [],\n        \"id\": \"CHART-HJOYVMV0E7\",\n        \"meta\": {\n            \"chartId\": 3969,\n            \"height\": 63,\n            \"sliceName\": \"Mapbox Long/Lat\",\n            \"width\": 6\n        },\n        \"type\": \"CHART\"\n    },\n    \"CHART-S1WYNz4AVX\": {\n        \"children\": [],\n        \"id\": \"CHART-S1WYNz4AVX\",\n        \"meta\": {\n            \"chartId\": 3989,\n            \"height\": 25,\n            \"sliceName\": \"Parallel Coordinates\",\n            \"width\": 4\n        },\n        \"type\": \"CHART\"\n    },\n    \"CHART-r19KVMNCE7\": {\n        \"children\": [],\n        \"id\": \"CHART-r19KVMNCE7\",\n        \"meta\": {\n            \"chartId\": 3971,\n            \"height\": 34,\n            \"sliceName\": \"Calendar Heatmap multiformat 0\",\n            \"width\": 4\n        },\n        \"type\": \"CHART\"\n    },\n    \"CHART-rJ4K4GV04Q\": {\n        \"children\": [],\n        \"id\": \"CHART-rJ4K4GV04Q\",\n        \"meta\": {\n            \"chartId\": 3941,\n            \"height\": 63,\n            \"sliceName\": \"Energy Force Layout\",\n            \"width\": 6\n        },\n        \"type\": \"CHART\"\n    },\n    \"CHART-rkgF4G4A4X\": {\n        \"children\": [],\n        \"id\": \"CHART-rkgF4G4A4X\",\n        \"meta\": {\n            \"chartId\": 3970,\n            \"height\": 25,\n            \"sliceName\": \"Birth in France by department in 2016\",\n            \"width\": 8\n        },\n        \"type\": \"CHART\"\n    },\n    \"CHART-rywK4GVR4X\": {\n        \"children\": [],\n        \"id\": \"CHART-rywK4GVR4X\",\n        \"meta\": {\n            \"chartId\": 3942,\n            \"height\": 50,\n            \"sliceName\": \"Heatmap\",\n            \"width\": 6\n        },\n        \"type\": \"CHART\"\n    },\n    \"COLUMN-ByUFVf40EQ\": {\n        \"children\": [\n            \"CHART-rywK4GVR4X\",\n            \"CHART-HJOYVMV0E7\"\n        ],\n        \"id\": \"COLUMN-ByUFVf40EQ\",\n        \"meta\": {\n            \"background\": \"BACKGROUND_TRANSPARENT\",\n            \"width\": 6\n        },\n        \"type\": \"COLUMN\"\n    },\n    \"COLUMN-rkmYVGN04Q\": {\n        \"children\": [\n            \"CHART-rJ4K4GV04Q\",\n            \"CHART-H1HYNzEANX\"\n        ],\n        \"id\": \"COLUMN-rkmYVGN04Q\",\n        \"meta\": {\n            \"background\": \"BACKGROUND_TRANSPARENT\",\n            \"width\": 6\n        },\n        \"type\": \"COLUMN\"\n    },\n    \"GRID_ID\": {\n        \"children\": [\n            \"ROW-SytNzNA4X\",\n            \"ROW-S1MK4M4A4X\",\n            \"ROW-HkFFEzVRVm\"\n        ],\n        \"id\": \"GRID_ID\",\n        \"type\": \"GRID\"\n    },\n    \"HEADER_ID\": {\n        \"id\": \"HEADER_ID\",\n        \"meta\": {\n            \"text\": \"Misc Charts\"\n        },\n        \"type\": \"HEADER\"\n    },\n    \"ROOT_ID\": {\n        \"children\": [\n            \"GRID_ID\"\n        ],\n        \"id\": \"ROOT_ID\",\n        \"type\": \"ROOT\"\n    },\n    \"ROW-HkFFEzVRVm\": {\n        \"children\": [\n            \"CHART-r19KVMNCE7\",\n            \"CHART-BkeVbh8ANQ\"\n        ],\n        \"id\": \"ROW-HkFFEzVRVm\",\n        \"meta\": {\n            \"background\": \"BACKGROUND_TRANSPARENT\"\n        },\n        \"type\": \"ROW\"\n    },\n    \"ROW-S1MK4M4A4X\": {\n        \"children\": [\n            \"COLUMN-rkmYVGN04Q\",\n            \"COLUMN-ByUFVf40EQ\"\n        ],\n        \"id\": \"ROW-S1MK4M4A4X\",\n        \"meta\": {\n            \"background\": \"BACKGROUND_TRANSPARENT\"\n        },\n        \"type\": \"ROW\"\n    },\n    \"ROW-SytNzNA4X\": {\n        \"children\": [\n            \"CHART-rkgF4G4A4X\",\n            \"CHART-S1WYNz4AVX\"\n        ],\n        \"id\": \"ROW-SytNzNA4X\",\n        \"meta\": {\n            \"background\": \"BACKGROUND_TRANSPARENT\"\n        },\n        \"type\": \"ROW\"\n    },\n    \"DASHBOARD_VERSION_KEY\": \"v2\"\n}\n    \"\"\")\n    pos = json.loads(js)\n    slices = (\n        db.session\n        .query(Slice)\n        .filter(Slice.slice_name.in_(misc_dash_slices))\n        .all()\n    )\n    slices = sorted(slices, key=lambda x: x.id)\n    update_slice_ids(pos, slices)\n    dash.dashboard_title = 'Misc Charts'\n    dash.position_json = json.dumps(pos, indent=4)\n    dash.slug = DASH_SLUG\n    dash.slices = slices\n    db.session.merge(dash)\n    db.session.commit()",
        "history": [],
        "output": "Loading a dashboard featuring misc charts",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _compare(cur_cmp, cur_struct):\n    '''\n    Compares two objects and return a boolean value\n    when there's a match.\n    '''\n    if isinstance(cur_cmp, dict) and isinstance(cur_struct, dict):\n        log.debug('Comparing dict to dict')\n        for cmp_key, cmp_value in six.iteritems(cur_cmp):\n            if cmp_key == '*':\n                # matches any key from the source dictionary\n                if isinstance(cmp_value, dict):\n                    found = False\n                    for _, cur_struct_val in six.iteritems(cur_struct):\n                        found |= _compare(cmp_value, cur_struct_val)\n                    return found\n                else:\n                    found = False\n                    if isinstance(cur_struct, (list, tuple)):\n                        for cur_ele in cur_struct:\n                            found |= _compare(cmp_value, cur_ele)\n                    elif isinstance(cur_struct, dict):\n                        for _, cur_ele in six.iteritems(cur_struct):\n                            found |= _compare(cmp_value, cur_ele)\n                    return found\n            else:\n                if isinstance(cmp_value, dict):\n                    if cmp_key not in cur_struct:\n                        return False\n                    return _compare(cmp_value, cur_struct[cmp_key])\n                if isinstance(cmp_value, list):\n                    found = False\n                    for _, cur_struct_val in six.iteritems(cur_struct):\n                        found |= _compare(cmp_value, cur_struct_val)\n                    return found\n                else:\n                    return _compare(cmp_value, cur_struct[cmp_key])\n    elif isinstance(cur_cmp, (list, tuple)) and isinstance(cur_struct, (list, tuple)):\n        log.debug('Comparing list to list')\n        found = False\n        for cur_cmp_ele in cur_cmp:\n            for cur_struct_ele in cur_struct:\n                found |= _compare(cur_cmp_ele, cur_struct_ele)\n        return found\n    elif isinstance(cur_cmp, dict) and isinstance(cur_struct, (list, tuple)):\n        log.debug('Comparing dict to list (of dicts?)')\n        found = False\n        for cur_struct_ele in cur_struct:\n            found |= _compare(cur_cmp, cur_struct_ele)\n        return found\n    elif isinstance(cur_cmp, bool) and isinstance(cur_struct, bool):\n        log.debug('Comparing booleans: %s ? %s', cur_cmp, cur_struct)\n        return cur_cmp == cur_struct\n    elif isinstance(cur_cmp, (six.string_types, six.text_type)) and \\\n         isinstance(cur_struct, (six.string_types, six.text_type)):\n        log.debug('Comparing strings (and regex?): %s ? %s', cur_cmp, cur_struct)\n        # Trying literal match\n        matched = re.match(cur_cmp, cur_struct, re.I)\n        if matched:\n            return True\n        return False\n    elif isinstance(cur_cmp, (six.integer_types, float)) and \\\n         isinstance(cur_struct, (six.integer_types, float)):\n        log.debug('Comparing numeric values: %d ? %d', cur_cmp, cur_struct)\n        # numeric compare\n        return cur_cmp == cur_struct\n    elif isinstance(cur_struct, (six.integer_types, float)) and \\\n         isinstance(cur_cmp, (six.string_types, six.text_type)):\n        # Comapring the numerical value agains a presumably mathematical value\n        log.debug('Comparing a numeric value (%d) with a string (%s)', cur_struct, cur_cmp)\n        numeric_compare = _numeric_regex.match(cur_cmp)\n        # determine if the value to compare agains is a mathematical operand\n        if numeric_compare:\n            compare_value = numeric_compare.group(2)\n            return getattr(float(cur_struct), _numeric_operand[numeric_compare.group(1)])(float(compare_value))\n        return False\n    return False",
        "history": [],
        "output": "Compares two objects and return a boolean value\n    when there's a match.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def advance(self, size: int) -> None:\n        \"\"\"\n        Advance the current buffer position by ``size`` bytes.\n        \"\"\"\n        assert 0 < size <= self._size\n        self._size -= size\n        pos = self._first_pos\n\n        buffers = self._buffers\n        while buffers and size > 0:\n            is_large, b = buffers[0]\n            b_remain = len(b) - size - pos\n            if b_remain <= 0:\n                buffers.popleft()\n                size -= len(b) - pos\n                pos = 0\n            elif is_large:\n                pos += size\n                size = 0\n            else:\n                # Amortized O(1) shrink for Python 2\n                pos += size\n                if len(b) <= 2 * pos:\n                    del typing.cast(bytearray, b)[:pos]\n                    pos = 0\n                size = 0\n\n        assert size == 0\n        self._first_pos = pos",
        "history": [],
        "output": "Advance the current buffer position by ``size`` bytes.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def render(hjson_data, saltenv='base', sls='', **kws):\n    '''\n    Accepts HJSON as a string or as a file object and runs it through the HJSON\n    parser.\n\n    :rtype: A Python data structure\n    '''\n    if not isinstance(hjson_data, six.string_types):\n        hjson_data = hjson_data.read()\n\n    if hjson_data.startswith('#!'):\n        hjson_data = hjson_data[(hjson_data.find('\\n') + 1):]\n    if not hjson_data.strip():\n        return {}\n    return hjson.loads(hjson_data)",
        "history": [],
        "output": "Accepts HJSON as a string or as a file object and runs it through the HJSON\n    parser.\n\n    :rtype: A Python data structure",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _connect(host=None, port=None, db=None, password=None):\n    '''\n    Returns an instance of the redis client\n    '''\n    if not host:\n        host = __salt__['config.option']('redis.host')\n    if not port:\n        port = __salt__['config.option']('redis.port')\n    if not db:\n        db = __salt__['config.option']('redis.db')\n    if not password:\n        password = __salt__['config.option']('redis.password')\n\n    return redis.StrictRedis(host, port, db, password, decode_responses=True)",
        "history": [],
        "output": "Returns an instance of the redis client",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def triggered(self):\n        \"\"\"\n        For a market order, True.\n        For a stop order, True IFF stop_reached.\n        For a limit order, True IFF limit_reached.\n        \"\"\"\n        if self.stop is not None and not self.stop_reached:\n            return False\n\n        if self.limit is not None and not self.limit_reached:\n            return False\n\n        return True",
        "history": [],
        "output": "For a market order, True.\n        For a stop order, True IFF stop_reached.\n        For a limit order, True IFF limit_reached.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _AddSerializeToStringMethod(message_descriptor, cls):\n  \"\"\"Helper for _AddMessageMethods().\"\"\"\n\n  def SerializeToString(self):\n    # Check if the message has all of its required fields set.\n    errors = []\n    if not self.IsInitialized():\n      raise message_mod.EncodeError(\n          'Message %s is missing required fields: %s' % (\n          self.DESCRIPTOR.full_name, ','.join(self.FindInitializationErrors())))\n    return self.SerializePartialToString()\n  cls.SerializeToString = SerializeToString",
        "history": [],
        "output": "Helper for _AddMessageMethods().",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def load_data(self, profdatafile):\r\n        \"\"\"Load profiler data saved by profile/cProfile module\"\"\"\r\n        import pstats\r\n        try:\r\n            stats_indi = [pstats.Stats(profdatafile), ]\r\n        except (OSError, IOError):\r\n            return\r\n        self.profdata = stats_indi[0]\r\n        \r\n        if self.compare_file is not None:\r\n            try:\r\n                stats_indi.append(pstats.Stats(self.compare_file))\r\n            except (OSError, IOError) as e:\r\n                QMessageBox.critical(\r\n                    self, _(\"Error\"),\r\n                    _(\"Error when trying to load profiler results\"))\r\n                logger.debug(\"Error when calling pstats, {}\".format(e))\r\n                self.compare_file = None\r\n        map(lambda x: x.calc_callees(), stats_indi)\r\n        self.profdata.calc_callees()\r\n        self.stats1 = stats_indi\r\n        self.stats = stats_indi[0].stats",
        "history": [],
        "output": "Load profiler data saved by profile/cProfile module",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_std_icon(name, size=None):\n    \"\"\"Get standard platform icon\n    Call 'show_std_icons()' for details\"\"\"\n    if not name.startswith('SP_'):\n        name = 'SP_' + name\n    icon = QWidget().style().standardIcon(getattr(QStyle, name))\n    if size is None:\n        return icon\n    else:\n        return QIcon(icon.pixmap(size, size))",
        "history": [],
        "output": "Get standard platform icon\n    Call 'show_std_icons()' for details",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def ext_pillar(minion_id,\n               pillar,  # pylint: disable=W0613\n               key=None,\n               only=()):\n    '''\n    Read pillar data from Cobbler via its API.\n    '''\n    url = __opts__['cobbler.url']\n    user = __opts__['cobbler.user']\n    password = __opts__['cobbler.password']\n\n    log.info(\"Querying cobbler at %r for information for %r\", url, minion_id)\n    try:\n        server = salt.ext.six.moves.xmlrpc_client.Server(url, allow_none=True)\n        if user:\n            server.login(user, password)\n        result = server.get_blended_data(None, minion_id)\n    except Exception:\n        log.exception(\n            'Could not connect to cobbler.'\n        )\n        return {}\n\n    if only:\n        result = dict((k, result[k]) for k in only if k in result)\n\n    if key:\n        result = {key: result}\n    return result",
        "history": [],
        "output": "Read pillar data from Cobbler via its API.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def block(self):\n        \"\"\"Blocks until process is complete.\"\"\"\n        if self._uses_subprocess:\n            # consume stdout and stderr\n            if self.blocking:\n                try:\n                    stdout, stderr = self.subprocess.communicate()\n                    self.__out = stdout\n                    self.__err = stderr\n                except ValueError:\n                    pass  # Don't read from finished subprocesses.\n            else:\n                self.subprocess.stdin.close()\n                self.std_out.close()\n                self.std_err.close()\n                self.subprocess.wait()\n        else:\n            self.subprocess.sendeof()\n            try:\n                self.subprocess.wait()\n            finally:\n                if self.subprocess.proc.stdout:\n                    self.subprocess.proc.stdout.close()",
        "history": [],
        "output": "Blocks until process is complete.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def slicenet_params1_noam():\n  \"\"\"Version with Noam's decay scheme.\"\"\"\n  hparams = slicenet_params1()\n  hparams.learning_rate_decay_scheme = \"noam\"\n  hparams.learning_rate = 1.0\n  hparams.learning_rate_warmup_steps = 4000\n  hparams.initializer = \"uniform_unit_scaling\"\n  hparams.optimizer_adam_epsilon = 1e-9\n  hparams.optimizer_adam_beta1 = 0.9\n  hparams.optimizer_adam_beta2 = 0.98\n  return hparams",
        "history": [],
        "output": "Version with Noam's decay scheme.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def import_module(module_name):\n    \"\"\"Helper function to import module\"\"\"\n    import sys, os\n    import importlib\n    sys.path.append(os.path.dirname(__file__))\n    return importlib.import_module(module_name)",
        "history": [],
        "output": "Helper function to import module",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_same_name_files(files_path_list, filename):\r\n    \"\"\"Get a list of the path components of the files with the same name.\"\"\"\r\n    same_name_files = []\r\n    for fname in files_path_list:\r\n        if filename == os.path.basename(fname):\r\n            same_name_files.append(path_components(fname))\r\n    return same_name_files",
        "history": [],
        "output": "Get a list of the path components of the files with the same name.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _clean_salt_variables(params, variable_prefix=\"__\"):\n    '''\n    Pops out variables from params which starts with `variable_prefix`.\n    '''\n    list(list(map(params.pop, [k for k in params if k.startswith(variable_prefix)])))\n    return params",
        "history": [],
        "output": "Pops out variables from params which starts with `variable_prefix`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def replace_strings_in_list(array_of_strigs, replace_with_strings):\n    \"A value in replace_with_strings can be either single string or list of strings\"\n    potentially_nested_list = [replace_with_strings.get(s) or s for s in array_of_strigs]\n    return list(flatten(potentially_nested_list))",
        "history": [],
        "output": "A value in replace_with_strings can be either single string or list of strings",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _extract_labels(time_series):\n    \"\"\"Build the combined resource and metric labels, with resource_type.\"\"\"\n    labels = {\"resource_type\": time_series.resource.type}\n    labels.update(time_series.resource.labels)\n    labels.update(time_series.metric.labels)\n    return labels",
        "history": [],
        "output": "Build the combined resource and metric labels, with resource_type.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def intel_extractor(url, response):\r\n    \"\"\"Extract intel from the response body.\"\"\"\r\n    for rintel in rintels:\r\n        res = re.sub(r'<(script).*?</\\1>(?s)', '', response)\r\n        res = re.sub(r'<[^<]+?>', '', res)\r\n        matches = rintel[0].findall(res)\r\n        if matches:\r\n            for match in matches:\r\n                verb('Intel', match)\r\n                bad_intel.add((match, rintel[1], url))",
        "history": [],
        "output": "Extract intel from the response body.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_roster_file(options):\n    '''\n    Find respective roster file.\n\n    :param options:\n    :return:\n    '''\n    template = None\n    # The __disable_custom_roster is always True if Salt SSH Client comes\n    # from Salt API. In that case no way to define own 'roster_file', instead\n    # this file needs to be chosen from already validated rosters\n    # (see /etc/salt/master config).\n    if options.get('__disable_custom_roster') and options.get('roster_file'):\n        roster = options.get('roster_file').strip('/')\n        for roster_location in options.get('rosters'):\n            r_file = os.path.join(roster_location, roster)\n            if os.path.isfile(r_file):\n                template = r_file\n                break\n        del options['roster_file']\n\n    if not template:\n        if options.get('roster_file'):\n            template = options.get('roster_file')\n        elif 'config_dir' in options.get('__master_opts__', {}):\n            template = os.path.join(options['__master_opts__']['config_dir'],\n                                    'roster')\n        elif 'config_dir' in options:\n            template = os.path.join(options['config_dir'], 'roster')\n        else:\n            template = os.path.join(salt.syspaths.CONFIG_DIR, 'roster')\n\n    if not os.path.isfile(template):\n        raise IOError('Roster file \"{0}\" not found'.format(template))\n\n    if not os.access(template, os.R_OK):\n        raise IOError('Access denied to roster \"{0}\"'.format(template))\n\n    return template",
        "history": [],
        "output": "Find respective roster file.\n\n    :param options:\n    :return:",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def from_string(self, source, globals=None, template_class=None):\n        \"\"\"Load a template from a string.  This parses the source given and\n        returns a :class:`Template` object.\n        \"\"\"\n        globals = self.make_globals(globals)\n        cls = template_class or self.template_class\n        return cls.from_code(self, self.compile(source), globals, None)",
        "history": [],
        "output": "Load a template from a string.  This parses the source given and\n        returns a :class:`Template` object.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _SkipVarint(buffer, pos, end):\n  \"\"\"Skip a varint value.  Returns the new position.\"\"\"\n  # Previously ord(buffer[pos]) raised IndexError when pos is out of range.\n  # With this code, ord(b'') raises TypeError.  Both are handled in\n  # python_message.py to generate a 'Truncated message' error.\n  while ord(buffer[pos:pos+1]) & 0x80:\n    pos += 1\n  pos += 1\n  if pos > end:\n    raise _DecodeError('Truncated message.')\n  return pos",
        "history": [],
        "output": "Skip a varint value.  Returns the new position.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def run(self):\n        \"\"\"\n        Kill any open Redshift sessions for the given database.\n        \"\"\"\n        connection = self.output().connect()\n        # kill any sessions other than ours and\n        # internal Redshift sessions (rdsdb)\n        query = (\"select pg_terminate_backend(process) \"\n                 \"from STV_SESSIONS \"\n                 \"where db_name=%s \"\n                 \"and user_name != 'rdsdb' \"\n                 \"and process != pg_backend_pid()\")\n        cursor = connection.cursor()\n        logger.info('Killing all open Redshift sessions for database: %s', self.database)\n        try:\n            cursor.execute(query, (self.database,))\n            cursor.close()\n            connection.commit()\n        except psycopg2.DatabaseError as e:\n            if e.message and 'EOF' in e.message:\n                # sometimes this operation kills the current session.\n                # rebuild the connection. Need to pause for 30-60 seconds\n                # before Redshift will allow us back in.\n                connection.close()\n                logger.info('Pausing %s seconds for Redshift to reset connection', self.connection_reset_wait_seconds)\n                time.sleep(self.connection_reset_wait_seconds)\n                logger.info('Reconnecting to Redshift')\n                connection = self.output().connect()\n            else:\n                raise\n\n        try:\n            self.output().touch(connection)\n            connection.commit()\n        finally:\n            connection.close()\n\n        logger.info('Done killing all open Redshift sessions for database: %s', self.database)",
        "history": [],
        "output": "Kill any open Redshift sessions for the given database.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def iter_next(self):\n        \"\"\"Increments the coursor by batch_size for next batch\n        and check current cursor if it exceed the number of data points.\"\"\"\n        self.cursor += self.batch_size\n        return self.cursor < self.num_data",
        "history": [],
        "output": "Increments the coursor by batch_size for next batch\n        and check current cursor if it exceed the number of data points.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _service_is_chkconfig(name):\n    '''\n    Return True if the service is managed by chkconfig.\n    '''\n    cmdline = '/sbin/chkconfig --list {0}'.format(name)\n    return __salt__['cmd.retcode'](cmdline, python_shell=False, ignore_retcode=True) == 0",
        "history": [],
        "output": "Return True if the service is managed by chkconfig.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def register_child(self, block, name=None):\n        \"\"\"Registers block as a child of self. :py:class:`Block` s assigned to self as\n        attributes will be registered automatically.\"\"\"\n        if name is None:\n            name = str(len(self._children))\n        self._children[name] = block",
        "history": [],
        "output": "Registers block as a child of self. :py:class:`Block` s assigned to self as\n        attributes will be registered automatically.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def toggle_show_cd_only(self, checked):\r\n        \"\"\"Toggle show current directory only mode\"\"\"\r\n        self.parent_widget.sig_option_changed.emit('show_cd_only', checked)\r\n        self.show_cd_only = checked\r\n        if checked:\r\n            if self.__last_folder is not None:\r\n                self.set_current_folder(self.__last_folder)\r\n        elif self.__original_root_index is not None:\r\n            self.setRootIndex(self.__original_root_index)",
        "history": [],
        "output": "Toggle show current directory only mode",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def execute_request_handler(self):\n        \"\"\"\n        Invoke the request handler defined by the\n        :func:`sanic.app.Sanic.handle_request` method\n\n        :return: None\n        \"\"\"\n        self._response_timeout_handler = self.loop.call_later(\n            self.response_timeout, self.response_timeout_callback\n        )\n        self._last_request_time = time()\n        self._request_handler_task = self.loop.create_task(\n            self.request_handler(\n                self.request, self.write_response, self.stream_response\n            )\n        )",
        "history": [],
        "output": "Invoke the request handler defined by the\n        :func:`sanic.app.Sanic.handle_request` method\n\n        :return: None",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def parse(self, val):\n        \"\"\"\n        Parses a ``bool`` from the string, matching 'true' or 'false' ignoring case.\n        \"\"\"\n        s = str(val).lower()\n        if s == \"true\":\n            return True\n        elif s == \"false\":\n            return False\n        else:\n            raise ValueError(\"cannot interpret '{}' as boolean\".format(val))",
        "history": [],
        "output": "Parses a ``bool`` from the string, matching 'true' or 'false' ignoring case.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def is_list(self, key):\r\n        \"\"\"Return True if variable is a list or a tuple\"\"\"\r\n        data = self.model.get_data()\r\n        return isinstance(data[key], (tuple, list))",
        "history": [],
        "output": "Return True if variable is a list or a tuple",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def replace_variables(sentence: List[str],\n                      sentence_variables: Dict[str, str]) -> Tuple[List[str], List[str]]:\n    \"\"\"\n    Replaces abstract variables in text with their concrete counterparts.\n    \"\"\"\n    tokens = []\n    tags = []\n    for token in sentence:\n        if token not in sentence_variables:\n            tokens.append(token)\n            tags.append(\"O\")\n        else:\n            for word in sentence_variables[token].split():\n                tokens.append(word)\n                tags.append(token)\n    return tokens, tags",
        "history": [],
        "output": "Replaces abstract variables in text with their concrete counterparts.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def Vector(self, off):\n        \"\"\"Vector retrieves the start of data of the vector whose offset is\n           stored at \"off\" in this object.\"\"\"\n        N.enforce_number(off, N.UOffsetTFlags)\n\n        off += self.Pos\n        x = off + self.Get(N.UOffsetTFlags, off)\n        # data starts after metadata containing the vector length\n        x += N.UOffsetTFlags.bytewidth\n        return x",
        "history": [],
        "output": "Vector retrieves the start of data of the vector whose offset is\n           stored at \"off\" in this object.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _update_gecos(name, key, value, root=None):\n    '''\n    Common code to change a user's GECOS information\n    '''\n    if value is None:\n        value = ''\n    elif not isinstance(value, six.string_types):\n        value = six.text_type(value)\n    else:\n        value = salt.utils.stringutils.to_unicode(value)\n    pre_info = _get_gecos(name, root=root)\n    if not pre_info:\n        return False\n    if value == pre_info[key]:\n        return True\n    gecos_data = copy.deepcopy(pre_info)\n    gecos_data[key] = value\n\n    cmd = ['usermod']\n    if root is not None and __grains__['kernel'] != 'AIX':\n        cmd.extend(('-R', root))\n    cmd.extend(('-c', _build_gecos(gecos_data), name))\n\n    __salt__['cmd.run'](cmd, python_shell=False)\n    return _get_gecos(name, root=root).get(key) == value",
        "history": [],
        "output": "Common code to change a user's GECOS information",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def split_action_id (id):\n    \"\"\" Splits an id in the toolset and specific rule parts. E.g.\n        'gcc.compile.c++' returns ('gcc', 'compile.c++')\n    \"\"\"\n    assert isinstance(id, basestring)\n    split = id.split ('.', 1)\n    toolset = split [0]\n    name = ''\n    if len (split) > 1:\n        name = split [1]\n    return (toolset, name)",
        "history": [],
        "output": "Splits an id in the toolset and specific rule parts. E.g.\n        'gcc.compile.c++' returns ('gcc', 'compile.c++')",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def __enforce_only_strings_dict(dictionary):\n    '''\n    Returns a dictionary that has string keys and values.\n    '''\n    ret = {}\n\n    for key, value in iteritems(dictionary):\n        ret[six.text_type(key)] = six.text_type(value)\n\n    return ret",
        "history": [],
        "output": "Returns a dictionary that has string keys and values.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _parse_quniform(self, param_value):\n        '''parse type of quniform parameter and return a list'''\n        if param_value[2] < 2:\n            raise RuntimeError(\"The number of values sampled (q) should be at least 2\")\n        low, high, count = param_value[0], param_value[1], param_value[2]\n        interval = (high - low) / (count - 1)\n        return [float(low + interval * i) for i in range(count)]",
        "history": [],
        "output": "parse type of quniform parameter and return a list",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def char_beam_search(out):\n    \"\"\"\n    Description : apply beam search for prediction result\n    \"\"\"\n    out_conv = list()\n    for idx in range(out.shape[0]):\n        probs = out[idx]\n        prob = probs.softmax().asnumpy()\n        line_string_proposals = ctcBeamSearch(prob, ALPHABET, None, k=4, beamWidth=25)\n        out_conv.append(line_string_proposals[0])\n    return out_conv",
        "history": [],
        "output": "Description : apply beam search for prediction result",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def step_HMC(exe, exe_params, exe_grads, label_key, noise_precision, prior_precision, L=10, eps=1E-6):\n    \"\"\"Generate the implementation of step HMC\"\"\"\n    init_params = {k: v.copyto(v.context) for k, v in exe_params.items()}\n    end_params = {k: v.copyto(v.context) for k, v in exe_params.items()}\n    init_momentums = {k: mx.random.normal(0, 1, v.shape) for k, v in init_params.items()}\n    end_momentums = {k: v.copyto(v.context) for k, v in init_momentums.items()}\n    init_potential = calc_potential(exe, init_params, label_key, noise_precision, prior_precision)\n\n    # 0. Calculate Initial Energy and Kinetic\n    init_kinetic = sum([nd.sum(nd.square(momentum)) / 2.0\n                        for momentum in init_momentums.values()]).asscalar()\n    # 1. Make a half step for momentum at the beginning\n    exe.copy_params_from(end_params)\n    exe.forward(is_train=True)\n    exe.backward()\n    for k, v in exe_grads.items():\n        v.wait_to_read()\n    for k, momentum in end_momentums.items():\n        momentum[:] = momentum - (eps / 2) * exe_grads[k]\n    # 2. Alternate full steps for position and momentum\n    for i in range(L):\n        # 2.1 Full step for position\n        for k, param in exe_params.items():\n            param[:] = param + eps * end_momentums[k]\n        # 2.2 Full step for the momentum, except at the end of trajectory we perform a half step\n        exe.forward(is_train=True)\n        exe.backward()\n        for v in exe_grads.values():\n            v.wait_to_read()\n        if i != L - 1:\n            for k, momentum in end_momentums.items():\n                momentum[:] = momentum - eps * exe_grads[k]\n        else:\n            for k, momentum in end_momentums.items():\n                # We should reverse the sign of the momentum at the end\n                momentum[:] = -(momentum - eps / 2.0 * exe_grads[k])\n    copy_param(exe, end_params)\n    # 3. Calculate acceptance ratio and accept/reject the move\n    end_potential = calc_potential(exe, end_params, label_key, noise_precision, prior_precision)\n    end_kinetic = sum([nd.sum(nd.square(momentum)) / 2.0\n                       for momentum in end_momentums.values()]).asscalar()\n    # print init_potential, init_kinetic, end_potential, end_kinetic\n    r = numpy.random.rand(1)\n    if r < numpy.exp(-(end_potential + end_kinetic) + (init_potential + init_kinetic)):\n        exe.copy_params_from(end_params)\n        return end_params, 1\n    else:\n        exe.copy_params_from(init_params)\n        return init_params, 0",
        "history": [],
        "output": "Generate the implementation of step HMC",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def start_building (self, main_target_instance):\n        \"\"\" Helper rules to detect cycles in main target references.\n        \"\"\"\n        assert isinstance(main_target_instance, MainTarget)\n        if id(main_target_instance) in self.targets_being_built_:\n            names = []\n            for t in self.targets_being_built_.values() + [main_target_instance]:\n                names.append (t.full_name())\n\n            get_manager().errors()(\"Recursion in main target references\\n\")\n\n        self.targets_being_built_[id(main_target_instance)] = main_target_instance",
        "history": [],
        "output": "Helper rules to detect cycles in main target references.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _config_logic(napalm_device,\n                  loaded_result,\n                  test=False,\n                  debug=False,\n                  replace=False,\n                  commit_config=True,\n                  loaded_config=None,\n                  commit_in=None,\n                  commit_at=None,\n                  revert_in=None,\n                  revert_at=None,\n                  commit_jid=None,\n                  **kwargs):\n    '''\n    Builds the config logic for `load_config` and `load_template` functions.\n    '''\n    # As the Salt logic is built around independent events\n    # when it comes to configuration changes in the\n    # candidate DB on the network devices, we need to\n    # make sure we're using the same session.\n    # Hence, we need to pass the same object around.\n    # the napalm_device object is inherited from\n    # the load_config or load_template functions\n    # and forwarded to compare, discard, commit etc.\n    # then the decorator will make sure that\n    # if not proxy (when the connection is always alive)\n    # and the `inherit_napalm_device` is set,\n    # `napalm_device` will be overridden.\n    # See `salt.utils.napalm.proxy_napalm_wrap` decorator.\n\n    current_jid = kwargs.get('__pub_jid')\n    if not current_jid:\n        current_jid = '{0:%Y%m%d%H%M%S%f}'.format(datetime.datetime.now())\n\n    loaded_result['already_configured'] = False\n\n    loaded_result['loaded_config'] = ''\n    if debug:\n        loaded_result['loaded_config'] = loaded_config\n\n    _compare = compare_config(inherit_napalm_device=napalm_device)\n    if _compare.get('result', False):\n        loaded_result['diff'] = _compare.get('out')\n        loaded_result.pop('out', '')  # not needed\n    else:\n        loaded_result['diff'] = None\n        loaded_result['result'] = False\n        loaded_result['comment'] = _compare.get('comment')\n        __context__['retcode'] = 1\n        return loaded_result\n\n    _loaded_res = loaded_result.get('result', False)\n    if not _loaded_res or test:\n        # if unable to load the config (errors / warnings)\n        # or in testing mode,\n        # will discard the config\n        if loaded_result['comment']:\n            loaded_result['comment'] += '\\n'\n        if not loaded_result.get('diff', ''):\n            loaded_result['already_configured'] = True\n        discarded = _safe_dicard_config(loaded_result, napalm_device)\n        if not discarded['result']:\n            return loaded_result\n        loaded_result['comment'] += 'Configuration discarded.'\n        # loaded_result['result'] = False not necessary\n        # as the result can be true when test=True\n        _explicit_close(napalm_device)\n        if not loaded_result['result']:\n            __context__['retcode'] = 1\n        return loaded_result\n\n    if not test and commit_config:\n        # if not in testing mode and trying to commit\n        if commit_jid:\n            log.info('Committing the JID: %s', str(commit_jid))\n            removed = cancel_commit(commit_jid)\n            log.debug('Cleaned up the commit from the schedule')\n            log.debug(removed['comment'])\n        if loaded_result.get('diff', ''):\n            # if not testing mode\n            # and also the user wants to commit (default)\n            # and there are changes to commit\n            if commit_in or commit_at:\n                commit_time = __utils__['timeutil.get_time_at'](time_in=commit_in,\n                                                                time_at=commit_in)\n                # schedule job\n                scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                temp_file = salt.utils.files.mkstemp()\n                with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                    fp_.write(loaded_config)\n                scheduled = __salt__['schedule.add'](scheduled_job_name,\n                                                     function='net.load_config',\n                                                     job_kwargs={\n                                                         'filename': temp_file,\n                                                         'commit_jid': current_jid,\n                                                         'replace': replace\n                                                     },\n                                                     once=commit_time)\n                log.debug('Scheduling job')\n                log.debug(scheduled)\n                saved = __salt__['schedule.save']()  # ensure the schedule is\n                # persistent cross Minion restart\n                discarded = _safe_dicard_config(loaded_result, napalm_device)\n                # discard the changes\n                if not discarded['result']:\n                    discarded['comment'] += ('Scheduled the job to be executed at {schedule_ts}, '\n                        'but was unable to discard the config: \\n').format(schedule_ts=commit_time)\n                    return discarded\n                loaded_result['comment'] = ('Changes discarded for now, and scheduled commit at: {schedule_ts}.\\n'\n                    'The commit ID is: {current_jid}.\\n'\n                    'To discard this commit, you can execute: \\n\\n'\n                    'salt {min_id} net.cancel_commit {current_jid}').format(schedule_ts=commit_time,\n                                                                             min_id=__opts__['id'],\n                                                                             current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            log.debug('About to commit:')\n            log.debug(loaded_result['diff'])\n            if revert_in or revert_at:\n                revert_time = __utils__['timeutil.get_time_at'](time_in=revert_in,\n                                                                time_at=revert_at)\n                if __grains__['os'] == 'junos':\n                    if not HAS_JXMLEASE:\n                        loaded_result['comment'] = ('This feature requires the library jxmlease to be installed.\\n'\n                                'To install, please execute: ``pip install jxmlease``.')\n                        loaded_result['result'] = False\n                        return loaded_result\n                    timestamp_at = __utils__['timeutil.get_timestamp_at'](time_in=revert_in,\n                                                                          time_at=revert_at)\n                    minutes = int((timestamp_at - time.time())/60)\n                    _comm = __salt__['napalm.junos_commit'](confirm=minutes)\n                    if not _comm['out']:\n                        # If unable to commit confirm, should try to bail out\n                        loaded_result['comment'] = 'Unable to commit confirm: {}'.format(_comm['message'])\n                        loaded_result['result'] = False\n                        # But before exiting, we must gracefully discard the config\n                        discarded = _safe_dicard_config(loaded_result, napalm_device)\n                        if not discarded['result']:\n                            return loaded_result\n                else:\n                    temp_file = salt.utils.files.mkstemp()\n                    running_config = __salt__['net.config'](source='running')['out']['running']\n                    with salt.utils.files.fopen(temp_file, 'w') as fp_:\n                        fp_.write(running_config)\n                    committed = _safe_commit_config(loaded_result, napalm_device)\n                    if not committed['result']:\n                        # If unable to commit, dicard the config (which is\n                        # already done by the _safe_commit_config function), and\n                        # return with the command and other details.\n                        return loaded_result\n                    scheduled_job_name = '__napalm_commit_{}'.format(current_jid)\n                    scheduled = __salt__['schedule.add'](scheduled_job_name,\n                                                         function='net.load_config',\n                                                         job_kwargs={\n                                                             'filename': temp_file,\n                                                             'commit_jid': current_jid,\n                                                             'replace': True\n                                                         },\n                                                         once=revert_time)\n                    log.debug('Scheduling commit confirmed')\n                    log.debug(scheduled)\n                    saved = __salt__['schedule.save']()\n                loaded_result['comment'] = ('The commit ID is: {current_jid}.\\n'\n                        'This commit will be reverted at: {schedule_ts}, unless confirmed.\\n'\n                        'To confirm the commit and avoid reverting, you can execute:\\n\\n'\n                        'salt {min_id} net.confirm_commit {current_jid}').format(schedule_ts=revert_time,\n                                                                                 min_id=__opts__['id'],\n                                                                                 current_jid=current_jid)\n                loaded_result['commit_id'] = current_jid\n                return loaded_result\n            committed = _safe_commit_config(loaded_result, napalm_device)\n            if not committed['result']:\n                return loaded_result\n        else:\n            # would like to commit, but there's no change\n            # need to call discard_config() to release the config DB\n            discarded = _safe_dicard_config(loaded_result, napalm_device)\n            if not discarded['result']:\n                return loaded_result\n            loaded_result['already_configured'] = True\n            loaded_result['comment'] = 'Already configured.'\n    _explicit_close(napalm_device)\n    if not loaded_result['result']:\n        __context__['retcode'] = 1\n    return loaded_result",
        "history": [],
        "output": "Builds the config logic for `load_config` and `load_template` functions.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _reset_syslog_config_params(host, username, password, cmd, resets, valid_resets,\n                                protocol=None, port=None, esxi_host=None, credstore=None):\n    '''\n    Helper function for reset_syslog_config that resets the config and populates the return dictionary.\n    '''\n    ret_dict = {}\n    all_success = True\n\n    if not isinstance(resets, list):\n        resets = [resets]\n\n    for reset_param in resets:\n        if reset_param in valid_resets:\n            ret = salt.utils.vmware.esxcli(host, username, password, cmd + reset_param,\n                                           protocol=protocol, port=port,\n                                           esxi_host=esxi_host, credstore=credstore)\n            ret_dict[reset_param] = {}\n            ret_dict[reset_param]['success'] = ret['retcode'] == 0\n            if ret['retcode'] != 0:\n                all_success = False\n                ret_dict[reset_param]['message'] = ret['stdout']\n        else:\n            all_success = False\n            ret_dict[reset_param] = {}\n            ret_dict[reset_param]['success'] = False\n            ret_dict[reset_param]['message'] = 'Invalid syslog ' \\\n                                               'configuration parameter'\n\n    ret_dict['success'] = all_success\n\n    return ret_dict",
        "history": [],
        "output": "Helper function for reset_syslog_config that resets the config and populates the return dictionary.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_stack_index(self, stack_index, plugin_index):\n        \"\"\"Get the real index of the selected item.\"\"\"\n        other_plugins_count = sum([other_tabs[0].count() \\\n                                   for other_tabs in \\\n                                   self.plugins_tabs[:plugin_index]])\n        real_index = stack_index - other_plugins_count\n\n        return real_index",
        "history": [],
        "output": "Get the real index of the selected item.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def rename_key(pki_dir, id_, new_id):\n    '''\n    Rename a key, when an instance has also been renamed\n    '''\n    oldkey = os.path.join(pki_dir, 'minions', id_)\n    newkey = os.path.join(pki_dir, 'minions', new_id)\n    if os.path.isfile(oldkey):\n        os.rename(oldkey, newkey)",
        "history": [],
        "output": "Rename a key, when an instance has also been renamed",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def htmlNodeDumpFormatOutput(self, buf, cur, encoding, format):\n        \"\"\"Dump an HTML node, recursive behaviour,children are printed\n           too. \"\"\"\n        if buf is None: buf__o = None\n        else: buf__o = buf._o\n        if cur is None: cur__o = None\n        else: cur__o = cur._o\n        libxml2mod.htmlNodeDumpFormatOutput(buf__o, self._o, cur__o, encoding, format)",
        "history": [],
        "output": "Dump an HTML node, recursive behaviour,children are printed\n           too.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def closing_plugin(self, cancelable=False):\r\n        \"\"\"Perform actions before parent main window is closed\"\"\"\r\n        self.findinfiles.closing_widget()  # stop search thread and clean-up\r\n        options = self.findinfiles.find_options.get_options(to_save=True)\r\n        if options is not None:\r\n            (search_text, text_re,\r\n             exclude, exclude_idx, exclude_re,\r\n             more_options, case_sensitive,\r\n             path_history) = options\r\n            hist_limit = 15\r\n            search_text = search_text[:hist_limit]\r\n            exclude = exclude[:hist_limit]\r\n            path_history = path_history[-hist_limit:]\r\n            self.set_option('search_text', search_text)\r\n            self.set_option('search_text_regexp', text_re)\r\n            self.set_option('exclude', exclude)\r\n            self.set_option('exclude_idx', exclude_idx)\r\n            self.set_option('exclude_regexp', exclude_re)\r\n            self.set_option('more_options', more_options)\r\n            self.set_option('case_sensitive', case_sensitive)\r\n            self.set_option('path_history', path_history)\r\n        return True",
        "history": [],
        "output": "Perform actions before parent main window is closed",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def FromNanoseconds(self, nanos):\n    \"\"\"Converts nanoseconds since epoch to Timestamp.\"\"\"\n    self.seconds = nanos // _NANOS_PER_SECOND\n    self.nanos = nanos % _NANOS_PER_SECOND",
        "history": [],
        "output": "Converts nanoseconds since epoch to Timestamp.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def golds_to_gold_tuples(docs, golds):\n    \"\"\"Get out the annoying 'tuples' format used by begin_training, given the\n    GoldParse objects.\"\"\"\n    tuples = []\n    for doc, gold in zip(docs, golds):\n        text = doc.text\n        ids, words, tags, heads, labels, iob = zip(*gold.orig_annot)\n        sents = [((ids, words, tags, heads, labels, iob), [])]\n        tuples.append((text, sents))\n    return tuples",
        "history": [],
        "output": "Get out the annoying 'tuples' format used by begin_training, given the\n    GoldParse objects.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def format_return_text(self, data, function, **kwargs):  # pylint: disable=unused-argument\n        '''\n        Print out YAML using the block mode\n        '''\n        # emulate the yaml_out output formatter. It relies on a global __opts__ object which\n        # we can't obviously pass in\n        try:\n            try:\n                outputter = data[next(iter(data))].get('out')\n            except (StopIteration, AttributeError):\n                outputter = None\n            return salt.output.string_format(\n                {x: y['return'] for x, y in six.iteritems(data)},\n                out=outputter,\n                opts=__opts__,\n            )\n        except Exception as exc:\n            import pprint\n            log.exception(\n                'Exception encountered when trying to serialize %s',\n                pprint.pformat(data)\n            )\n            return 'Got an error trying to serialze/clean up the response'",
        "history": [],
        "output": "Print out YAML using the block mode",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def set_umr_namelist(self):\r\n        \"\"\"Set UMR excluded modules name list\"\"\"\r\n        arguments, valid = QInputDialog.getText(self, _('UMR'),\r\n                                  _(\"Set the list of excluded modules as \"\r\n                                    \"this: <i>numpy, scipy</i>\"),\r\n                                  QLineEdit.Normal,\r\n                                  \", \".join(self.get_option('umr/namelist')))\r\n        if valid:\r\n            arguments = to_text_string(arguments)\r\n            if arguments:\r\n                namelist = arguments.replace(' ', '').split(',')\r\n                fixed_namelist = []\r\n                non_ascii_namelist = []\r\n                for module_name in namelist:\r\n                    if PY2:\r\n                        if all(ord(c) < 128 for c in module_name):\r\n                            if programs.is_module_installed(module_name):\r\n                                fixed_namelist.append(module_name)\r\n                        else:\r\n                            QMessageBox.warning(self, _('Warning'),\r\n                            _(\"You are working with Python 2, this means that \"\r\n                              \"you can not import a module that contains non-\"\r\n                              \"ascii characters.\"), QMessageBox.Ok)\r\n                            non_ascii_namelist.append(module_name)\r\n                    elif programs.is_module_installed(module_name):\r\n                        fixed_namelist.append(module_name)\r\n                invalid = \", \".join(set(namelist)-set(fixed_namelist)-\r\n                                    set(non_ascii_namelist))\r\n                if invalid:\r\n                    QMessageBox.warning(self, _('UMR'),\r\n                                        _(\"The following modules are not \"\r\n                                          \"installed on your machine:\\n%s\"\r\n                                          ) % invalid, QMessageBox.Ok)\r\n                QMessageBox.information(self, _('UMR'),\r\n                                    _(\"Please note that these changes will \"\r\n                                      \"be applied only to new Python/IPython \"\r\n                                      \"consoles\"), QMessageBox.Ok)\r\n            else:\r\n                fixed_namelist = []\r\n            self.set_option('umr/namelist', fixed_namelist)",
        "history": [],
        "output": "Set UMR excluded modules name list",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def generate_files_distributed(generator,\n                               output_name,\n                               output_dir,\n                               num_shards=1,\n                               max_cases=None,\n                               task_id=0):\n  \"\"\"generate_files but with a single writer writing to shard task_id.\"\"\"\n  assert task_id < num_shards\n  output_filename = sharded_name(output_name, task_id, num_shards)\n  output_file = os.path.join(output_dir, output_filename)\n  tf.logging.info(\"Writing to file %s\", output_file)\n  writer = tf.python_io.TFRecordWriter(output_file)\n\n  counter = 0\n  for case in generator:\n    if counter % 100000 == 0:\n      tf.logging.info(\"Generating case %d for %s.\" % (counter, output_name))\n    counter += 1\n    if max_cases and counter > max_cases:\n      break\n    example = to_example(case)\n    writer.write(example.SerializeToString())\n\n  writer.close()\n  return output_file",
        "history": [],
        "output": "generate_files but with a single writer writing to shard task_id.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def text_standardize(text):\n    \"\"\"\n    Apply text standardization following original implementation.\n    \"\"\"\n    text = text.replace('\u2014', '-')\n    text = text.replace('\u2013', '-')\n    text = text.replace('\u2015', '-')\n    text = text.replace('\u2026', '...')\n    text = text.replace('\u00b4', \"'\")\n    text = re.sub(r'''(-+|~+|!+|\"+|;+|\\?+|\\++|,+|\\)+|\\(+|\\\\+|\\/+|\\*+|\\[+|\\]+|}+|{+|\\|+|_+)''', r' \\1 ', text)\n    text = re.sub(r'\\s*\\n\\s*', ' \\n ', text)\n    text = re.sub(r'[^\\S\\n]+', ' ', text)\n    return text.strip()",
        "history": [],
        "output": "Apply text standardization following original implementation.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def diff(self, first_row: List[Row], second_row: List[Row], column: NumberColumn) -> Number:\n        \"\"\"\n        Takes a two rows and a number column and returns the difference between the values under\n        that column in those two rows.\n        \"\"\"\n        if not first_row or not second_row:\n            return 0.0  # type: ignore\n        first_value = first_row[0].values[column.name]\n        second_value = second_row[0].values[column.name]\n        if isinstance(first_value, float) and isinstance(second_value, float):\n            return first_value - second_value  # type: ignore\n        else:\n            raise ExecutionError(f\"Invalid column for diff: {column.name}\")",
        "history": [],
        "output": "Takes a two rows and a number column and returns the difference between the values under\n        that column in those two rows.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def start(name):\n    '''\n    Start the named container\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt myminion nspawn.start <name>\n    '''\n    if _sd_version() >= 219:\n        ret = _machinectl('start {0}'.format(name))\n    else:\n        cmd = 'systemctl start systemd-nspawn@{0}'.format(name)\n        ret = __salt__['cmd.run_all'](cmd, python_shell=False)\n\n    if ret['retcode'] != 0:\n        __context__['retcode'] = salt.defaults.exitcodes.EX_UNAVAILABLE\n        return False\n    return True",
        "history": [],
        "output": "Start the named container\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt myminion nspawn.start <name>",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_game_for_worker(map_name, directory_id):\n  \"\"\"Get game for the given worker (directory) id.\"\"\"\n  if map_name == \"v100unfriendly\":\n    games = [\"chopper_command\", \"boxing\", \"asterix\", \"seaquest\"]\n    worker_per_game = 5\n  elif map_name == \"human_nice\":\n    games = gym_env.ATARI_GAMES_WITH_HUMAN_SCORE_NICE\n    worker_per_game = 5\n  else:\n    raise ValueError(\"Unknown worker to game map name: %s\" % map_name)\n  games.sort()\n  game_id = (directory_id - 1) // worker_per_game\n  tf.logging.info(\"Getting game %d from %s.\" % (game_id, games))\n  return games[game_id]",
        "history": [],
        "output": "Get game for the given worker (directory) id.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _start(self, worker=None):\n        \"\"\"Start threads and check for inactive workers.\"\"\"\n        if worker:\n            self._queue_workers.append(worker)\n\n        if self._queue_workers and self._running_threads < self._max_threads:\n            #print('Queue: {0} Running: {1} Workers: {2} '\n            #       'Threads: {3}'.format(len(self._queue_workers),\n            #                                 self._running_threads,\n            #                                 len(self._workers),\n            #                                 len(self._threads)))\n            self._running_threads += 1\n            worker = self._queue_workers.popleft()\n            thread = QThread()\n            if isinstance(worker, PythonWorker):\n                worker.moveToThread(thread)\n                worker.sig_finished.connect(thread.quit)\n                thread.started.connect(worker._start)\n                thread.start()\n            elif isinstance(worker, ProcessWorker):\n                thread.quit()\n                worker._start()\n            self._threads.append(thread)\n        else:\n            self._timer.start()\n\n        if self._workers:\n            for w in self._workers:\n                if w.is_finished():\n                    self._bag_collector.append(w)\n                    self._workers.remove(w)\n\n        if self._threads:\n            for t in self._threads:\n                if t.isFinished():\n                    self._threads.remove(t)\n                    self._running_threads -= 1\n\n        if len(self._threads) == 0 and len(self._workers) == 0:\n            self._timer.stop()\n            self._timer_worker_delete.start()",
        "history": [],
        "output": "Start threads and check for inactive workers.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def switch(self, gen_mode:bool=None):\n        \"Switch the model, if `gen_mode` is provided, in the desired mode.\"\n        self.gen_mode = (not self.gen_mode) if gen_mode is None else gen_mode\n        self.opt.opt = self.opt_gen.opt if self.gen_mode else self.opt_critic.opt\n        self._set_trainable()\n        self.model.switch(gen_mode)\n        self.loss_func.switch(gen_mode)",
        "history": [],
        "output": "Switch the model, if `gen_mode` is provided, in the desired mode.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def option_list_all(self):\n        \"\"\"Get a list of all options, including those in option groups.\"\"\"\n        res = self.option_list[:]\n        for i in self.option_groups:\n            res.extend(i.option_list)\n\n        return res",
        "history": [],
        "output": "Get a list of all options, including those in option groups.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def groupByKey(self, numPartitions=None):\n        \"\"\"\n        Return a new DStream by applying groupByKey on each RDD.\n        \"\"\"\n        if numPartitions is None:\n            numPartitions = self._sc.defaultParallelism\n        return self.transform(lambda rdd: rdd.groupByKey(numPartitions))",
        "history": [],
        "output": "Return a new DStream by applying groupByKey on each RDD.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def imagetransformer_base_10l_8h_big_uncond_dr03_dan_64():\n  \"\"\"big 1d model for unconditional generation on imagenet.\"\"\"\n  hparams = imagetransformer_base_10l_8h_big_cond_dr03_dan()\n  hparams.unconditional = True\n  hparams.max_length = 14000\n  hparams.batch_size = 1\n  hparams.img_len = 64\n  hparams.layer_prepostprocess_dropout = 0.1\n  return hparams",
        "history": [],
        "output": "big 1d model for unconditional generation on imagenet.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _SimpleSizer(compute_value_size):\n  \"\"\"A sizer which uses the function compute_value_size to compute the size of\n  each value.  Typically compute_value_size is _VarintSize.\"\"\"\n\n  def SpecificSizer(field_number, is_repeated, is_packed):\n    tag_size = _TagSize(field_number)\n    if is_packed:\n      local_VarintSize = _VarintSize\n      def PackedFieldSize(value):\n        result = 0\n        for element in value:\n          result += compute_value_size(element)\n        return result + local_VarintSize(result) + tag_size\n      return PackedFieldSize\n    elif is_repeated:\n      def RepeatedFieldSize(value):\n        result = tag_size * len(value)\n        for element in value:\n          result += compute_value_size(element)\n        return result\n      return RepeatedFieldSize\n    else:\n      def FieldSize(value):\n        return tag_size + compute_value_size(value)\n      return FieldSize\n\n  return SpecificSizer",
        "history": [],
        "output": "A sizer which uses the function compute_value_size to compute the size of\n  each value.  Typically compute_value_size is _VarintSize.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _parse_settings_vlan(opts, iface):\n\n    '''\n    Filters given options and outputs valid settings for a vlan\n    '''\n    vlan = {}\n    if 'reorder_hdr' in opts:\n        if opts['reorder_hdr'] in _CONFIG_TRUE + _CONFIG_FALSE:\n            vlan.update({'reorder_hdr': opts['reorder_hdr']})\n        else:\n            valid = _CONFIG_TRUE + _CONFIG_FALSE\n            _raise_error_iface(iface, 'reorder_hdr', valid)\n\n    if 'vlan_id' in opts:\n        if opts['vlan_id'] > 0:\n            vlan.update({'vlan_id': opts['vlan_id']})\n        else:\n            _raise_error_iface(iface, 'vlan_id', 'Positive integer')\n\n    if 'phys_dev' in opts:\n        if opts['phys_dev']:\n            vlan.update({'phys_dev': opts['phys_dev']})\n        else:\n            _raise_error_iface(iface, 'phys_dev', 'Non-empty string')\n\n    return vlan",
        "history": [],
        "output": "Filters given options and outputs valid settings for a vlan",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _unary_op(name, doc=\"unary operator\"):\n    \"\"\" Create a method for given unary operator \"\"\"\n    def _(self):\n        jc = getattr(self._jc, name)()\n        return Column(jc)\n    _.__doc__ = doc\n    return _",
        "history": [],
        "output": "Create a method for given unary operator",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def accuracy_thresh_expand(y_pred:Tensor, y_true:Tensor, thresh:float=0.5, sigmoid:bool=True)->Rank0Tensor:\n    \"Compute accuracy after expanding `y_true` to the size of `y_pred`.\"\n    if sigmoid: y_pred = y_pred.sigmoid()\n    return ((y_pred>thresh)==y_true[:,None].expand_as(y_pred).byte()).float().mean()",
        "history": [],
        "output": "Compute accuracy after expanding `y_true` to the size of `y_pred`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def kill_log_monitor(self, check_alive=True):\n        \"\"\"Kill the log monitor.\n\n        Args:\n            check_alive (bool): Raise an exception if the process was already\n                dead.\n        \"\"\"\n        self._kill_process_type(\n            ray_constants.PROCESS_TYPE_LOG_MONITOR, check_alive=check_alive)",
        "history": [],
        "output": "Kill the log monitor.\n\n        Args:\n            check_alive (bool): Raise an exception if the process was already\n                dead.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def __translate(self, parameter_values):\n        \"\"\"\n        This method is unused and a Work In Progress\n        \"\"\"\n\n        template_copy = self.template\n\n        sam_parser = Parser()\n        sam_translator = Translator(managed_policy_map=self.__managed_policy_map(),\n                                    sam_parser=sam_parser,\n                                    # Default plugins are already initialized within the Translator\n                                    plugins=self.extra_plugins)\n\n        return sam_translator.translate(sam_template=template_copy,\n                                        parameter_values=parameter_values)",
        "history": [],
        "output": "This method is unused and a Work In Progress",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def from_folder(cls, path:PathOrStr, train:PathOrStr='train', valid:PathOrStr='valid',\n                    valid_pct=None, classes:Collection=None, **kwargs:Any)->'ImageDataBunch':\n        \"Create from imagenet style dataset in `path` with `train`,`valid`,`test` subfolders (or provide `valid_pct`).\"\n        path=Path(path)\n        il = ImageList.from_folder(path)\n        if valid_pct is None: src = il.split_by_folder(train=train, valid=valid)\n        else: src = il.split_by_rand_pct(valid_pct)\n        src = src.label_from_folder(classes=classes)\n        return cls.create_from_ll(src, **kwargs)",
        "history": [],
        "output": "Create from imagenet style dataset in `path` with `train`,`valid`,`test` subfolders (or provide `valid_pct`).",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _createFromLocal(self, data, schema):\n        \"\"\"\n        Create an RDD for DataFrame from a list or pandas.DataFrame, returns\n        the RDD and schema.\n        \"\"\"\n        # make sure data could consumed multiple times\n        if not isinstance(data, list):\n            data = list(data)\n\n        if schema is None or isinstance(schema, (list, tuple)):\n            struct = self._inferSchemaFromList(data, names=schema)\n            converter = _create_converter(struct)\n            data = map(converter, data)\n            if isinstance(schema, (list, tuple)):\n                for i, name in enumerate(schema):\n                    struct.fields[i].name = name\n                    struct.names[i] = name\n            schema = struct\n\n        elif not isinstance(schema, StructType):\n            raise TypeError(\"schema should be StructType or list or None, but got: %s\" % schema)\n\n        # convert python objects to sql data\n        data = [schema.toInternal(row) for row in data]\n        return self._sc.parallelize(data), schema",
        "history": [],
        "output": "Create an RDD for DataFrame from a list or pandas.DataFrame, returns\n        the RDD and schema.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_assistive_access():\n    '''\n    Get a list of all of the assistive access applications installed,\n    returns as a ternary showing whether each app is enabled or not.\n    '''\n    cmd = 'sqlite3 \"/Library/Application Support/com.apple.TCC/TCC.db\" \"SELECT * FROM access\"'\n    call = __salt__['cmd.run_all'](\n        cmd,\n        output_loglevel='debug',\n        python_shell=False\n    )\n\n    if call['retcode'] != 0:\n        comment = ''\n        if 'stderr' in call:\n            comment += call['stderr']\n        if 'stdout' in call:\n            comment += call['stdout']\n\n        raise CommandExecutionError('Error: {0}'.format(comment))\n\n    out = call['stdout']\n    return re.findall(r'kTCCServiceAccessibility\\|(.*)\\|[0-9]{1}\\|([0-9]{1})\\|[0-9]{1}\\|', out, re.MULTILINE)",
        "history": [],
        "output": "Get a list of all of the assistive access applications installed,\n    returns as a ternary showing whether each app is enabled or not.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_buckets_cache_filename(bucket, prefix):\n    '''\n    Return the filename of the cache for bucket contents.\n    Create the path if it does not exist.\n    '''\n\n    cache_dir = _get_cache_dir()\n    if not os.path.exists(cache_dir):\n        os.makedirs(cache_dir)\n\n    return os.path.join(cache_dir, '{0}-{1}-files.cache'.format(bucket, prefix))",
        "history": [],
        "output": "Return the filename of the cache for bucket contents.\n    Create the path if it does not exist.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def take(attributes, properties):\n    \"\"\"Returns a property set which include all\n    properties in 'properties' that have any of 'attributes'.\"\"\"\n    assert is_iterable_typed(attributes, basestring)\n    assert is_iterable_typed(properties, basestring)\n    result = []\n    for e in properties:\n        if b2.util.set.intersection(attributes, feature.attributes(get_grist(e))):\n            result.append(e)\n    return result",
        "history": [],
        "output": "Returns a property set which include all\n    properties in 'properties' that have any of 'attributes'.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def serve_file(load, fnd):\n    '''\n    Return a chunk from a file based on the data received\n    '''\n    ret = {'data': '',\n           'dest': ''}\n    required_load_keys = ('path', 'loc', 'saltenv')\n    if not all(x in load for x in required_load_keys):\n        log.debug(\n            'Not all of the required keys present in payload. Missing: %s',\n            ', '.join(required_load_keys.difference(load))\n        )\n        return ret\n    if not fnd['path']:\n        return ret\n    ret['dest'] = fnd['rel']\n    gzip = load.get('gzip', None)\n    fpath = os.path.normpath(fnd['path'])\n    with salt.utils.files.fopen(fpath, 'rb') as fp_:\n        fp_.seek(load['loc'])\n        data = fp_.read(__opts__['file_buffer_size'])\n        if data and six.PY3 and not salt.utils.files.is_binary(fpath):\n            data = data.decode(__salt_system_encoding__)\n        if gzip and data:\n            data = salt.utils.gzip_util.compress(data, gzip)\n            ret['gzip'] = gzip\n        ret['data'] = data\n    return ret",
        "history": [],
        "output": "Return a chunk from a file based on the data received",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def local_attention_2d(x, hparams, attention_type=\"local_attention_2d\"):\n  \"\"\"Local 2d, self attention layer.\"\"\"\n  # self-attention\n  with tf.variable_scope(\"local_2d_self_att\"):\n    y = common_attention.multihead_attention_2d(\n        x,\n        None,\n        hparams.attention_key_channels or hparams.hidden_size,\n        hparams.attention_value_channels or hparams.hidden_size,\n        hparams.hidden_size,\n        hparams.num_heads,\n        attention_type=attention_type,\n        query_shape=hparams.query_shape,\n        memory_flange=hparams.memory_flange,\n        name=\"self_attention\")\n  return y",
        "history": [],
        "output": "Local 2d, self attention layer.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _train(self, trial):\n        \"\"\"Start one iteration of training and save remote id.\"\"\"\n\n        assert trial.status == Trial.RUNNING, trial.status\n        remote = trial.runner.train.remote()\n\n        # Local Mode\n        if isinstance(remote, dict):\n            remote = _LocalWrapper(remote)\n\n        self._running[remote] = trial",
        "history": [],
        "output": "Start one iteration of training and save remote id.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def prepare_to_generate(self, data_dir, tmp_dir):\n    \"\"\"Make sure that the data is prepared and the vocab is generated.\"\"\"\n    self.get_or_create_vocab(data_dir, tmp_dir)\n    self.train_text_filepaths(tmp_dir)\n    self.dev_text_filepaths(tmp_dir)",
        "history": [],
        "output": "Make sure that the data is prepared and the vocab is generated.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def dummy_eval(m:nn.Module, size:tuple=(64,64)):\n    \"Pass a `dummy_batch` in evaluation mode in `m` with `size`.\"\n    return m.eval()(dummy_batch(m, size))",
        "history": [],
        "output": "Pass a `dummy_batch` in evaluation mode in `m` with `size`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def viewers(self, value):\n        \"\"\"Update viewers.\n\n        DEPRECATED:  use ``policy[\"roles/viewers\"] = value`` instead.\n        \"\"\"\n        warnings.warn(\n            _ASSIGNMENT_DEPRECATED_MSG.format(\"viewers\", VIEWER_ROLE),\n            DeprecationWarning,\n        )\n        self[VIEWER_ROLE] = value",
        "history": [],
        "output": "Update viewers.\n\n        DEPRECATED:  use ``policy[\"roles/viewers\"] = value`` instead.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _ValueMessageToJsonObject(self, message):\n    \"\"\"Converts Value message according to Proto3 JSON Specification.\"\"\"\n    which = message.WhichOneof('kind')\n    # If the Value message is not set treat as null_value when serialize\n    # to JSON. The parse back result will be different from original message.\n    if which is None or which == 'null_value':\n      return None\n    if which == 'list_value':\n      return self._ListValueMessageToJsonObject(message.list_value)\n    if which == 'struct_value':\n      value = message.struct_value\n    else:\n      value = getattr(message, which)\n    oneof_descriptor = message.DESCRIPTOR.fields_by_name[which]\n    return self._FieldToJsonObject(oneof_descriptor, value)",
        "history": [],
        "output": "Converts Value message according to Proto3 JSON Specification.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def remove_gateway_router(self, router):\n        '''\n        Removes an external network gateway from the specified router\n        '''\n        router_id = self._find_router_id(router)\n        return self.network_conn.remove_gateway_router(router=router_id)",
        "history": [],
        "output": "Removes an external network gateway from the specified router",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def prettify(self, elem):\n        \"\"\"\n            Return a pretty-printed XML string for the Element.\n        \"\"\"\n        rough_string = ElementTree.tostring(elem, 'utf8')\n        root = etree.fromstring(rough_string)\n        return etree.tostring(root, pretty_print=True, encoding=ENCODE_METHOD).replace(\"  \".encode(), \"\\t\".encode())\n        # minidom does not support UTF-8\n        '''reparsed = minidom.parseString(rough_string)\n        return reparsed.toprettyxml(indent=\"\\t\", encoding=ENCODE_METHOD)'''",
        "history": [],
        "output": "Return a pretty-printed XML string for the Element.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_output(script):\n    \"\"\"Reads script output from log.\n\n    :type script: str\n    :rtype: str | None\n\n    \"\"\"\n    if six.PY2:\n        logs.warn('Experimental instant mode is Python 3+ only')\n        return None\n\n    if 'THEFUCK_OUTPUT_LOG' not in os.environ:\n        logs.warn(\"Output log isn't specified\")\n        return None\n\n    if const.USER_COMMAND_MARK not in os.environ.get('PS1', ''):\n        logs.warn(\n            \"PS1 doesn't contain user command mark, please ensure \"\n            \"that PS1 is not changed after The Fuck alias initialization\")\n        return None\n\n    try:\n        with logs.debug_time(u'Read output from log'):\n            fd = os.open(os.environ['THEFUCK_OUTPUT_LOG'], os.O_RDONLY)\n            buffer = mmap.mmap(fd, const.LOG_SIZE_IN_BYTES, mmap.MAP_SHARED, mmap.PROT_READ)\n            _skip_old_lines(buffer)\n            lines = _get_output_lines(script, buffer)\n            output = '\\n'.join(lines).strip()\n            logs.debug(u'Received output: {}'.format(output))\n            return output\n    except OSError:\n        logs.warn(\"Can't read output log\")\n        return None\n    except ScriptNotInLog:\n        logs.warn(\"Script not found in output log\")\n        return None",
        "history": [],
        "output": "Reads script output from log.\n\n    :type script: str\n    :rtype: str | None",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def stat(self, filename):\n        \"\"\"Returns file statistics for a given path.\"\"\"\n        # NOTE: Size of the file is given by ContentLength from S3,\n        # but we convert to .length\n        client = boto3.client(\"s3\")\n        bucket, path = self.bucket_and_path(filename)\n        try:\n            obj = client.head_object(Bucket=bucket, Key=path)\n            return StatData(obj['ContentLength'])\n        except botocore.exceptions.ClientError as exc:\n            if exc.response['Error']['Code'] == '404':\n                raise errors.NotFoundError(None, None, \"Could not find file\")\n            else:\n                raise",
        "history": [],
        "output": "Returns file statistics for a given path.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def file_saved_in_editorstack(self, editorstack_id_str,\r\n                                  original_filename, filename):\r\n        \"\"\"A file was saved in editorstack, this notifies others\"\"\"\r\n        for editorstack in self.editorstacks:\r\n            if str(id(editorstack)) != editorstack_id_str:\r\n                editorstack.file_saved_in_other_editorstack(original_filename,\r\n                                                            filename)",
        "history": [],
        "output": "A file was saved in editorstack, this notifies others",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def handle_keypress(self):\r\n        \"\"\"When hitting tab, it handles if single or double tab\"\"\"\r\n        if self.numpress == 2:\r\n            self.sig_double_tab_pressed.emit(True)\r\n        self.numpress = 0",
        "history": [],
        "output": "When hitting tab, it handles if single or double tab",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def process_minion_update(self, event_data):\n        '''\n        Associate grains data with a minion and publish minion update\n        '''\n        tag = event_data['tag']\n        event_info = event_data['data']\n\n        mid = tag.split('/')[-1]\n\n        if not self.minions.get(mid, None):\n            self.minions[mid] = {}\n\n        minion = self.minions[mid]\n\n        minion.update({'grains': event_info['return']})\n        log.debug(\"In process minion grains update with minions=%s\", self.minions)\n        self.publish_minions()",
        "history": [],
        "output": "Associate grains data with a minion and publish minion update",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def suspend(name, call=None):\n    '''\n    To suspend a VM using its name\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a suspend vmname\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The suspend action must be called with '\n            '-a or --action.'\n        )\n\n    vm_properties = [\n        \"name\",\n        \"summary.runtime.powerState\"\n    ]\n\n    vm_list = salt.utils.vmware.get_mors_with_properties(_get_si(), vim.VirtualMachine, vm_properties)\n\n    for vm in vm_list:\n        if vm[\"name\"] == name:\n            if vm[\"summary.runtime.powerState\"] == \"poweredOff\":\n                ret = 'cannot suspend in powered off state'\n                log.info('VM %s %s', name, ret)\n                return ret\n            elif vm[\"summary.runtime.powerState\"] == \"suspended\":\n                ret = 'already suspended'\n                log.info('VM %s %s', name, ret)\n                return ret\n            try:\n                log.info('Suspending VM %s', name)\n                task = vm[\"object\"].Suspend()\n                salt.utils.vmware.wait_for_task(task, name, 'suspend')\n            except Exception as exc:\n                log.error(\n                    'Error while suspending VM %s: %s',\n                    name, exc,\n                    # Show the traceback if the debug logging level is enabled\n                    exc_info_on_loglevel=logging.DEBUG\n                )\n                return 'failed to suspend'\n\n    return 'suspended'",
        "history": [],
        "output": "To suspend a VM using its name\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt-cloud -a suspend vmname",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def conv_block_downsample(x,\n                          kernel,\n                          strides,\n                          padding,\n                          separability=0,\n                          name=None,\n                          reuse=None):\n  \"\"\"Implements a downwards-striding conv block, like Xception exit flow.\"\"\"\n  with tf.variable_scope(\n      name, default_name=\"conv_block_downsample\", values=[x], reuse=reuse):\n    hidden_size = int(x.get_shape()[-1])\n    res = conv_block(\n        x,\n        int(1.25 * hidden_size), [((1, 1), kernel)],\n        padding=padding,\n        strides=strides,\n        name=\"res_conv\")\n\n    x = subseparable_conv_block(\n        x,\n        hidden_size, [((1, 1), kernel)],\n        padding=padding,\n        separability=separability,\n        name=\"conv0\")\n    x = subseparable_conv_block(\n        x,\n        int(1.25 * hidden_size), [((1, 1), kernel)],\n        padding=padding,\n        separability=separability,\n        name=\"conv1\")\n    x = pool(x, kernel, \"MAX\", padding, strides=strides)\n\n    x += res\n\n    x = subseparable_conv_block(\n        x,\n        2 * hidden_size, [((1, 1), kernel)],\n        first_relu=False,\n        padding=padding,\n        separability=separability,\n        name=\"conv2\")\n    x = subseparable_conv_block(\n        x,\n        int(2.5 * hidden_size), [((1, 1), kernel)],\n        padding=padding,\n        separability=separability,\n        name=\"conv3\")\n    return x",
        "history": [],
        "output": "Implements a downwards-striding conv block, like Xception exit flow.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def save_reduce(self, func, args, state=None,\n                    listitems=None, dictitems=None, obj=None):\n        \"\"\"Modified to support __transient__ on new objects\n        Change only affects protocol level 2 (which is always used by PiCloud\"\"\"\n        # Assert that args is a tuple or None\n        if not isinstance(args, tuple):\n            raise pickle.PicklingError(\"args from reduce() should be a tuple\")\n\n        # Assert that func is callable\n        if not hasattr(func, '__call__'):\n            raise pickle.PicklingError(\"func from reduce should be callable\")\n\n        save = self.save\n        write = self.write\n\n        # Protocol 2 special case: if func's name is __newobj__, use NEWOBJ\n        if self.proto >= 2 and getattr(func, \"__name__\", \"\") == \"__newobj__\":\n            #Added fix to allow transient\n            cls = args[0]\n            if not hasattr(cls, \"__new__\"):\n                raise pickle.PicklingError(\n                    \"args[0] from __newobj__ args has no __new__\")\n            if obj is not None and cls is not obj.__class__:\n                raise pickle.PicklingError(\n                    \"args[0] from __newobj__ args has the wrong class\")\n            args = args[1:]\n            save(cls)\n\n            #Don't pickle transient entries\n            if hasattr(obj, '__transient__'):\n                transient = obj.__transient__\n                state = state.copy()\n\n                for k in list(state.keys()):\n                    if k in transient:\n                        del state[k]\n\n            save(args)\n            write(pickle.NEWOBJ)\n        else:\n            save(func)\n            save(args)\n            write(pickle.REDUCE)\n\n        if obj is not None:\n            self.memoize(obj)\n\n        # More new special cases (that work with older protocols as\n        # well): when __reduce__ returns a tuple with 4 or 5 items,\n        # the 4th and 5th item should be iterators that provide list\n        # items and dict items (as (key, value) tuples), or None.\n\n        if listitems is not None:\n            self._batch_appends(listitems)\n\n        if dictitems is not None:\n            self._batch_setitems(dictitems)\n\n        if state is not None:\n            save(state)\n            write(pickle.BUILD)",
        "history": [],
        "output": "Modified to support __transient__ on new objects\n        Change only affects protocol level 2 (which is always used by PiCloud",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _to_java(self):\n        \"\"\"\n        Transfer this instance to a Java OneVsRestModel. Used for ML persistence.\n\n        :return: Java object equivalent to this instance.\n        \"\"\"\n        sc = SparkContext._active_spark_context\n        java_models = [model._to_java() for model in self.models]\n        java_models_array = JavaWrapper._new_java_array(\n            java_models, sc._gateway.jvm.org.apache.spark.ml.classification.ClassificationModel)\n        metadata = JavaParams._new_java_obj(\"org.apache.spark.sql.types.Metadata\")\n        _java_obj = JavaParams._new_java_obj(\"org.apache.spark.ml.classification.OneVsRestModel\",\n                                             self.uid, metadata.empty(), java_models_array)\n        _java_obj.set(\"classifier\", self.getClassifier()._to_java())\n        _java_obj.set(\"featuresCol\", self.getFeaturesCol())\n        _java_obj.set(\"labelCol\", self.getLabelCol())\n        _java_obj.set(\"predictionCol\", self.getPredictionCol())\n        return _java_obj",
        "history": [],
        "output": "Transfer this instance to a Java OneVsRestModel. Used for ML persistence.\n\n        :return: Java object equivalent to this instance.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def move_to_element(self, to_element):\n        \"\"\"\n        Moving the mouse to the middle of an element.\n\n        :Args:\n         - to_element: The WebElement to move to.\n        \"\"\"\n        if self._driver.w3c:\n            self.w3c_actions.pointer_action.move_to(to_element)\n            self.w3c_actions.key_action.pause()\n        else:\n            self._actions.append(lambda: self._driver.execute(\n                                 Command.MOVE_TO, {'element': to_element.id}))\n        return self",
        "history": [],
        "output": "Moving the mouse to the middle of an element.\n\n        :Args:\n         - to_element: The WebElement to move to.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def remove(self, elem):\n    \"\"\"Removes an item from the list. Similar to list.remove().\"\"\"\n    self._values.remove(elem)\n    self._message_listener.Modified()",
        "history": [],
        "output": "Removes an item from the list. Similar to list.remove().",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def selinux_fs_path():\n    '''\n    Return the location of the SELinux VFS directory\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' selinux.selinux_fs_path\n    '''\n    # systems running systemd (e.g. Fedora 15 and newer)\n    # have the selinux filesystem in a different location\n    try:\n        for directory in ('/sys/fs/selinux', '/selinux'):\n            if os.path.isdir(directory):\n                if os.path.isfile(os.path.join(directory, 'enforce')):\n                    return directory\n        return None\n    # If selinux is Disabled, the path does not exist.\n    except AttributeError:\n        return None",
        "history": [],
        "output": "Return the location of the SELinux VFS directory\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' selinux.selinux_fs_path",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _process_msg(self, client, state, reward, isOver):\n        \"\"\"\n        Process a message sent from some client.\n        \"\"\"\n        # in the first message, only state is valid,\n        # reward&isOver should be discarded\n        if len(client.memory) > 0:\n            client.memory[-1].reward = reward\n            if isOver:\n                # should clear client's memory and put to queue\n                self._parse_memory(0, client, True)\n            else:\n                if len(client.memory) == LOCAL_TIME_MAX + 1:\n                    R = client.memory[-1].value\n                    self._parse_memory(R, client, False)\n        # feed state and return action\n        self._on_state(state, client)",
        "history": [],
        "output": "Process a message sent from some client.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def initialize(self, *args, **kwargs):\n        \"\"\"\n        Call self._initialize with `self` made available to Zipline API\n        functions.\n        \"\"\"\n        with ZiplineAPI(self):\n            self._initialize(self, *args, **kwargs)",
        "history": [],
        "output": "Call self._initialize with `self` made available to Zipline API\n        functions.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _process_emerge_err(stdout, stderr):\n    '''\n    Used to parse emerge output to provide meaningful output when emerge fails\n    '''\n    ret = {}\n    rexp = re.compile(r'^[<>=][^ ]+/[^ ]+ [^\\n]+', re.M)\n\n    slot_conflicts = re.compile(r'^[^ \\n]+/[^ ]+:[^ ]', re.M).findall(stderr)\n    if slot_conflicts:\n        ret['slot conflicts'] = slot_conflicts\n\n    blocked = re.compile(r'(?m)^\\[blocks .+\\] '\n                         r'([^ ]+/[^ ]+-[0-9]+[^ ]+)'\n                         r'.*$').findall(stdout)\n\n    unsatisfied = re.compile(\n            r'Error: The above package list contains').findall(stderr)\n\n    # If there were blocks and emerge could not resolve it.\n    if blocked and unsatisfied:\n        ret['blocked'] = blocked\n\n    sections = re.split('\\n\\n', stderr)\n    for section in sections:\n        if 'The following keyword changes' in section:\n            ret['keywords'] = rexp.findall(section)\n        elif 'The following license changes' in section:\n            ret['license'] = rexp.findall(section)\n        elif 'The following USE changes' in section:\n            ret['use'] = rexp.findall(section)\n        elif 'The following mask changes' in section:\n            ret['mask'] = rexp.findall(section)\n    return ret",
        "history": [],
        "output": "Used to parse emerge output to provide meaningful output when emerge fails",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def setup_common_actions(self):\r\n        \"\"\"Setup context menu common actions\"\"\"\r\n        self.collapse_all_action = create_action(self,\r\n                                     text=_('Collapse all'),\r\n                                     icon=ima.icon('collapse'),\r\n                                     triggered=self.collapseAll)\r\n        self.expand_all_action = create_action(self,\r\n                                     text=_('Expand all'),\r\n                                     icon=ima.icon('expand'),\r\n                                     triggered=self.expandAll)\r\n        self.restore_action = create_action(self,\r\n                                     text=_('Restore'),\r\n                                     tip=_('Restore original tree layout'),\r\n                                     icon=ima.icon('restore'),\r\n                                     triggered=self.restore)\r\n        self.collapse_selection_action = create_action(self,\r\n                                     text=_('Collapse selection'),\r\n                                     icon=ima.icon('collapse_selection'),\r\n                                     triggered=self.collapse_selection)\r\n        self.expand_selection_action = create_action(self,\r\n                                     text=_('Expand selection'),\r\n                                     icon=ima.icon('expand_selection'),\r\n                                     triggered=self.expand_selection)\r\n        return [self.collapse_all_action, self.expand_all_action,\r\n                self.restore_action, None,\r\n                self.collapse_selection_action, self.expand_selection_action]",
        "history": [],
        "output": "Setup context menu common actions",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def subseparable_conv(inputs, filters, kernel_size, **kwargs):\n  \"\"\"Sub-separable convolution. If separability == 0 it's a separable_conv.\"\"\"\n\n  def conv_fn(inputs, filters, kernel_size, **kwargs):\n    \"\"\"Sub-separable convolution, splits into separability-many blocks.\"\"\"\n    separability = None\n    if \"separability\" in kwargs:\n      separability = kwargs.pop(\"separability\")\n    if separability:\n      parts = []\n      abs_sep = separability if separability > 0 else -1 * separability\n      for split_idx, split in enumerate(tf.split(inputs, abs_sep, axis=3)):\n        with tf.variable_scope(\"part_%d\" % split_idx):\n          if separability > 0:\n            parts.append(\n                layers().Conv2D(filters // separability, kernel_size,\n                                **kwargs)(split))\n          else:\n            parts.append(\n                layers().SeparableConv2D(filters // abs_sep,\n                                         kernel_size, **kwargs)(split))\n      if separability > 1:\n        result = layers().Conv2D(filters, (1, 1))(tf.concat(parts, axis=3))\n      elif abs_sep == 1:  # If we have just one block, return it.\n        assert len(parts) == 1\n        result = parts[0]\n      else:\n        result = tf.concat(parts, axis=3)\n    else:\n      result = layers().SeparableConv2D(filters, kernel_size,\n                                        **kwargs)(inputs)\n    if separability is not None:\n      kwargs[\"separability\"] = separability\n    return result\n\n  return conv_internal(conv_fn, inputs, filters, kernel_size, **kwargs)",
        "history": [],
        "output": "Sub-separable convolution. If separability == 0 it's a separable_conv.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def reset_namespace(self):\r\n        \"\"\"Resets the namespace by removing all names defined by the user\"\"\"\r\n        self.shellwidget.reset_namespace(warning=self.reset_warning,\r\n                                         message=True)",
        "history": [],
        "output": "Resets the namespace by removing all names defined by the user",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def common_log(environ, response, response_time=None):\n    \"\"\"\n    Given the WSGI environ and the response,\n    log this event in Common Log Format.\n\n    \"\"\"\n\n    logger = logging.getLogger()\n\n    if response_time:\n        formatter = ApacheFormatter(with_response_time=True)\n        try:\n            log_entry = formatter(response.status_code, environ,\n                                  len(response.content), rt_us=response_time)\n        except TypeError:\n            # Upstream introduced a very annoying breaking change on the rt_ms/rt_us kwarg.\n            log_entry = formatter(response.status_code, environ,\n                                  len(response.content), rt_ms=response_time)\n    else:\n        formatter = ApacheFormatter(with_response_time=False)\n        log_entry = formatter(response.status_code, environ,\n                              len(response.content))\n\n    logger.info(log_entry)\n\n    return log_entry",
        "history": [],
        "output": "Given the WSGI environ and the response,\n    log this event in Common Log Format.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def combination_memo(n, r):\n    \"\"\"This function calculates nCr using memoization method.\"\"\"\n    memo = {}\n    def recur(n, r):\n        if n == r or r == 0:\n            return 1\n        if (n, r) not in memo:\n            memo[(n, r)] = recur(n - 1, r - 1) + recur(n - 1, r)\n        return memo[(n, r)]\n    return recur(n, r)",
        "history": [],
        "output": "This function calculates nCr using memoization method.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def imagetransformer_base_tpu():\n  \"\"\"Transformer base params for cifar-10.\"\"\"\n  hparams = imagetransformer_bas8l_8h_big_uncond_dr03_imgnet()\n  update_hparams_for_tpu(hparams)\n  hparams.batch_size = 4\n  hparams.num_heads = 4   # heads are expensive on tpu\n  hparams.num_decoder_layers = 12\n  hparams.block_length = 128\n  hparams.hidden_size = 512\n  hparams.filter_size = 2048\n  hparams.learning_rate = 0.2\n  hparams.learning_rate_warmup_steps = 6000\n  hparams.layer_preprocess_sequence = \"none\"\n  hparams.layer_postprocess_sequence = \"dan\"\n  hparams.layer_prepostprocess_dropout = 0.3\n  return hparams",
        "history": [],
        "output": "Transformer base params for cifar-10.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _list_linodes(full=False):\n    '''\n    Helper function to format and parse linode data\n    '''\n    nodes = _query('linode', 'list')['DATA']\n    ips = get_ips()\n\n    ret = {}\n    for node in nodes:\n        this_node = {}\n        linode_id = six.text_type(node['LINODEID'])\n\n        this_node['id'] = linode_id\n        this_node['image'] = node['DISTRIBUTIONVENDOR']\n        this_node['name'] = node['LABEL']\n        this_node['size'] = node['TOTALRAM']\n\n        state = int(node['STATUS'])\n        this_node['state'] = _get_status_descr_by_id(state)\n\n        for key, val in six.iteritems(ips):\n            if key == linode_id:\n                this_node['private_ips'] = val['private_ips']\n                this_node['public_ips'] = val['public_ips']\n\n        if full:\n            this_node['extra'] = node\n\n        ret[node['LABEL']] = this_node\n\n    return ret",
        "history": [],
        "output": "Helper function to format and parse linode data",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _is_proxy_running(proxyname):\n    '''\n    Check if proxy for this name is running\n    '''\n    cmd = ('ps ax | grep \"salt-proxy --proxyid={0}\" | grep -v grep'\n           .format(salt.ext.six.moves.shlex_quote(proxyname)))\n    cmdout = __salt__['cmd.run_all'](\n        cmd,\n        timeout=5,\n        python_shell=True)\n    if not cmdout['stdout']:\n        return False\n    else:\n        return True",
        "history": [],
        "output": "Check if proxy for this name is running",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def download_images(urls:Collection[str], dest:PathOrStr, max_pics:int=1000, max_workers:int=8, timeout=4):\n    \"Download images listed in text file `urls` to path `dest`, at most `max_pics`\"\n    urls = open(urls).read().strip().split(\"\\n\")[:max_pics]\n    dest = Path(dest)\n    dest.mkdir(exist_ok=True)\n    parallel(partial(_download_image_inner, dest, timeout=timeout), urls, max_workers=max_workers)",
        "history": [],
        "output": "Download images listed in text file `urls` to path `dest`, at most `max_pics`",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def avail_images(call=None):\n    '''\n    Return a list of the images that are on the provider\n    '''\n    if call == 'action':\n        raise SaltCloudSystemExit(\n            'The avail_images function must be called with '\n            '-f or --function, or with the --list-images option'\n        )\n\n    items = query(action='template')\n    ret = {}\n    for item in items:\n        ret[item.attrib['name']] = item.attrib\n\n    return ret",
        "history": [],
        "output": "Return a list of the images that are on the provider",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def dir_list(self, tgt_env):\n        '''\n        Get list of directories for the target environment using GitPython\n        '''\n        ret = set()\n        tree = self.get_tree(tgt_env)\n        if not tree:\n            return ret\n        if self.root(tgt_env):\n            try:\n                tree = tree / self.root(tgt_env)\n            except KeyError:\n                return ret\n            relpath = lambda path: os.path.relpath(path, self.root(tgt_env))\n        else:\n            relpath = lambda path: path\n        add_mountpoint = lambda path: salt.utils.path.join(\n            self.mountpoint(tgt_env), path, use_posixpath=True)\n        for blob in tree.traverse():\n            if isinstance(blob, git.Tree):\n                ret.add(add_mountpoint(relpath(blob.path)))\n        if self.mountpoint(tgt_env):\n            ret.add(self.mountpoint(tgt_env))\n        return ret",
        "history": [],
        "output": "Get list of directories for the target environment using GitPython",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _read_temp(data):\n    '''\n    Return what would be written to disk\n    '''\n    tout = StringIO()\n    tout.write(data)\n    tout.seek(0)\n    output = tout.readlines()\n    tout.close()\n\n    return output",
        "history": [],
        "output": "Return what would be written to disk",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def global_instance(cls, cmdline_args, allow_override=False):\n        \"\"\"\n        Meant to be used as a context manager.\n        \"\"\"\n        orig_value = cls._instance\n        assert (orig_value is None) or allow_override\n        new_value = None\n        try:\n            new_value = CmdlineParser(cmdline_args)\n            cls._instance = new_value\n            yield new_value\n        finally:\n            assert cls._instance is new_value\n            cls._instance = orig_value",
        "history": [],
        "output": "Meant to be used as a context manager.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def readMemory(buffer, size, URL, encoding, options):\n    \"\"\"parse an XML in-memory document and build a tree. \"\"\"\n    ret = libxml2mod.xmlReadMemory(buffer, size, URL, encoding, options)\n    if ret is None:raise treeError('xmlReadMemory() failed')\n    return xmlDoc(_obj=ret)",
        "history": [],
        "output": "parse an XML in-memory document and build a tree.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def computePreRec(cm, class_names):\n    '''\n    This function computes the precision, recall and f1 measures,\n    given a confusion matrix\n    '''\n    n_classes = cm.shape[0]\n    if len(class_names) != n_classes:\n        print(\"Error in computePreRec! Confusion matrix and class_names \"\n              \"list must be of the same size!\")\n        return\n    precision = []\n    recall = []\n    f1 = []    \n    for i, c in enumerate(class_names):\n        precision.append(cm[i,i] / numpy.sum(cm[:,i]))\n        recall.append(cm[i,i] / numpy.sum(cm[i,:]))\n        f1.append( 2 * precision[-1] * recall[-1] / (precision[-1] + recall[-1]))\n    return recall, precision, f1",
        "history": [],
        "output": "This function computes the precision, recall and f1 measures,\n    given a confusion matrix",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def incident_path(cls, project, incident):\n        \"\"\"Return a fully-qualified incident string.\"\"\"\n        return google.api_core.path_template.expand(\n            \"projects/{project}/incidents/{incident}\",\n            project=project,\n            incident=incident,\n        )",
        "history": [],
        "output": "Return a fully-qualified incident string.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def isMixedElement(self, name):\n        \"\"\"Search in the DtDs whether an element accept Mixed content\n           (or ANY) basically if it is supposed to accept text childs \"\"\"\n        ret = libxml2mod.xmlIsMixedElement(self._o, name)\n        return ret",
        "history": [],
        "output": "Search in the DtDs whether an element accept Mixed content\n           (or ANY) basically if it is supposed to accept text childs",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def save_partial(self, obj):\n        \"\"\"Partial objects do not serialize correctly in python2.x -- this fixes the bugs\"\"\"\n        self.save_reduce(_genpartial, (obj.func, obj.args, obj.keywords))",
        "history": [],
        "output": "Partial objects do not serialize correctly in python2.x -- this fixes the bugs",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def recurse_json(mlkit_tree, xgb_tree_json, tree_id, node_id, feature_map,\n        force_32bit_float):\n    \"\"\"Traverse through the tree and append to the tree spec.\n    \"\"\"\n    relative_hit_rate = None\n\n    try:\n        relative_hit_rate = xgb_tree_json['cover']\n    except KeyError:\n        pass\n\n\n    # Fill node attributes\n    if 'leaf' not in xgb_tree_json:\n        branch_mode = 'BranchOnValueLessThan'\n        split_name = xgb_tree_json['split']\n        feature_index = split_name if not feature_map else feature_map[split_name]\n\n        # xgboost internally uses float32, but the parsing from json pulls it out\n        # as a 64bit double.  To trigger the internal float32 detection in the\n        # tree ensemble compiler, we need to explicitly cast it to a float 32\n        # value, then back to the 64 bit float that protobuf expects.  This is\n        # controlled with the force_32bit_float flag.\n        feature_value = xgb_tree_json['split_condition']\n\n        if force_32bit_float:\n            feature_value = float(_np.float32(feature_value))\n\n\n        true_child_id = xgb_tree_json['yes']\n        false_child_id = xgb_tree_json['no']\n\n        # Get the missing value behavior correct\n        missing_value_tracks_true_child = False\n\n        try:\n            if xgb_tree_json['missing'] == true_child_id:\n                missing_value_tracks_true_child = True\n        except KeyError:\n            pass\n\n        mlkit_tree.add_branch_node(tree_id, node_id, feature_index,\n                feature_value, branch_mode, true_child_id, false_child_id,\n                relative_hit_rate = relative_hit_rate,\n                missing_value_tracks_true_child = missing_value_tracks_true_child)\n\n    else:\n        value = xgb_tree_json[\"leaf\"]\n\n        if force_32bit_float:\n            value = float(_np.float32(value))\n\n        mlkit_tree.add_leaf_node(tree_id, node_id, value,\n                relative_hit_rate = relative_hit_rate)\n\n    # Now recurse\n    if \"children\" in xgb_tree_json:\n        for child in xgb_tree_json[\"children\"]:\n            recurse_json(mlkit_tree, child, tree_id, child['nodeid'], feature_map, force_32bit_float)",
        "history": [],
        "output": "Traverse through the tree and append to the tree spec.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def select_row(self, steps):\r\n        \"\"\"Move selected row a number of steps.\r\n\r\n        Iterates in a cyclic behaviour.\r\n        \"\"\"\r\n        row = (self.currentRow() + steps) % self.count()\r\n        self.setCurrentRow(row)",
        "history": [],
        "output": "Move selected row a number of steps.\r\n\r\n        Iterates in a cyclic behaviour.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def check_environment(self, environment):\n        \"\"\"\n        Make sure the environment contains only strings\n\n        (since putenv needs a string)\n        \"\"\"\n\n        non_strings = []\n        for (k,v) in environment.items():\n            if not isinstance(v, basestring):\n                non_strings.append(k)\n        if non_strings:\n            raise ValueError(\"The following environment variables are not strings: {}\".format(\", \".join(non_strings)))\n        else:\n            return True",
        "history": [],
        "output": "Make sure the environment contains only strings\n\n        (since putenv needs a string)",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def update_buttons(self):\n        \"\"\"Updates the enable status of delete and reset buttons.\"\"\"\n        current_scheme = self.current_scheme\n        names = self.get_option(\"names\")\n        try:\n            names.pop(names.index(u'Custom'))\n        except ValueError:\n            pass\n        delete_enabled = current_scheme not in names\n        self.delete_button.setEnabled(delete_enabled)\n        self.reset_button.setEnabled(not delete_enabled)",
        "history": [],
        "output": "Updates the enable status of delete and reset buttons.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def scan_run_path(cls, project, scan_config, scan_run):\n        \"\"\"Return a fully-qualified scan_run string.\"\"\"\n        return google.api_core.path_template.expand(\n            \"projects/{project}/scanConfigs/{scan_config}/scanRuns/{scan_run}\",\n            project=project,\n            scan_config=scan_config,\n            scan_run=scan_run,\n        )",
        "history": [],
        "output": "Return a fully-qualified scan_run string.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def main(argv=None):\n  \"\"\"\n  Make a confidence report and save it to disk.\n  \"\"\"\n  try:\n    _name_of_script, filepath = argv\n  except ValueError:\n    raise ValueError(argv)\n  make_confidence_report(filepath=filepath, test_start=FLAGS.test_start,\n                         test_end=FLAGS.test_end, which_set=FLAGS.which_set,\n                         report_path=FLAGS.report_path,\n                         mc_batch_size=FLAGS.mc_batch_size,\n                         nb_iter=FLAGS.nb_iter,\n                         base_eps_iter=FLAGS.base_eps_iter,\n                         batch_size=FLAGS.batch_size,\n                         save_advx=FLAGS.save_advx)",
        "history": [],
        "output": "Make a confidence report and save it to disk.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def mock_decorator_with_params(*oargs, **okwargs):  # pylint: disable=unused-argument\n    '''\n    Optionally mock a decorator that takes parameters\n\n    E.g.:\n\n    @blah(stuff=True)\n    def things():\n        pass\n    '''\n    def inner(fn, *iargs, **ikwargs):  # pylint: disable=unused-argument\n        if hasattr(fn, '__call__'):\n            return fn\n        return Mock()\n    return inner",
        "history": [],
        "output": "Optionally mock a decorator that takes parameters\n\n    E.g.:\n\n    @blah(stuff=True)\n    def things():\n        pass",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _psed(text,\n          before,\n          after,\n          limit,\n          flags):\n    '''\n    Does the actual work for file.psed, so that single lines can be passed in\n    '''\n    atext = text\n    if limit:\n        limit = re.compile(limit)\n        comps = text.split(limit)\n        atext = ''.join(comps[1:])\n\n    count = 1\n    if 'g' in flags:\n        count = 0\n        flags = flags.replace('g', '')\n\n    aflags = 0\n    for flag in flags:\n        aflags |= RE_FLAG_TABLE[flag]\n\n    before = re.compile(before, flags=aflags)\n    text = re.sub(before, after, atext, count=count)\n\n    return text",
        "history": [],
        "output": "Does the actual work for file.psed, so that single lines can be passed in",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _update_svrg_gradients(self):\n        \"\"\"Calculates gradients based on the SVRG update rule.\n        \"\"\"\n        param_names = self._exec_group.param_names\n        for ctx in range(self._ctx_len):\n            for index, name in enumerate(param_names):\n                g_curr_batch_reg = self._exec_group.grad_arrays[index][ctx]\n                g_curr_batch_special = self._mod_aux._exec_group.grad_arrays[index][ctx]\n                g_special_weight_all_batch = self._param_dict[ctx][name]\n                g_svrg = self._svrg_grads_update_rule(g_curr_batch_reg, g_curr_batch_special,\n                                                      g_special_weight_all_batch)\n                self._exec_group.grad_arrays[index][ctx] = g_svrg",
        "history": [],
        "output": "Calculates gradients based on the SVRG update rule.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def import_module(dotted_path):\n    \"\"\"\n    Imports the specified module based on the\n    dot notated import path for the module.\n    \"\"\"\n    import importlib\n\n    module_parts = dotted_path.split('.')\n    module_path = '.'.join(module_parts[:-1])\n    module = importlib.import_module(module_path)\n\n    return getattr(module, module_parts[-1])",
        "history": [],
        "output": "Imports the specified module based on the\n    dot notated import path for the module.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _urlnorm(cls, uri):\n        \"\"\"Normalize the URL to create a safe key for the cache\"\"\"\n        (scheme, authority, path, query, fragment) = parse_uri(uri)\n        if not scheme or not authority:\n            raise Exception(\"Only absolute URIs are allowed. uri = %s\" % uri)\n\n        scheme = scheme.lower()\n        authority = authority.lower()\n\n        if not path:\n            path = \"/\"\n\n        # Could do syntax based normalization of the URI before\n        # computing the digest. See Section 6.2.2 of Std 66.\n        request_uri = query and \"?\".join([path, query]) or path\n        defrag_uri = scheme + \"://\" + authority + request_uri\n\n        return defrag_uri",
        "history": [],
        "output": "Normalize the URL to create a safe key for the cache",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def bb2hw(a:Collection[int])->np.ndarray:\n    \"Convert bounding box points from (width,height,center) to (height,width,top,left).\"\n    return np.array([a[1],a[0],a[3]-a[1],a[2]-a[0]])",
        "history": [],
        "output": "Convert bounding box points from (width,height,center) to (height,width,top,left).",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def returner(load):\n    '''\n    Return data to couchbase bucket\n    '''\n    cb_ = _get_connection()\n\n    hn_key = '{0}/{1}'.format(load['jid'], load['id'])\n    try:\n        ret_doc = {'return': load['return'],\n                   'full_ret': salt.utils.json.dumps(load)}\n\n        cb_.add(hn_key,\n               ret_doc,\n               ttl=_get_ttl(),\n               )\n    except couchbase.exceptions.KeyExistsError:\n        log.error(\n            'An extra return was detected from minion %s, please verify '\n            'the minion, this could be a replay attack', load['id']\n        )\n        return False",
        "history": [],
        "output": "Return data to couchbase bucket",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def loads(schema_str):\n    \"\"\" Parse a schema given a schema string \"\"\"\n    try:\n        if sys.version_info[0] < 3:\n            return schema.parse(schema_str)\n        else:\n            return schema.Parse(schema_str)\n    except schema.SchemaParseException as e:\n        raise ClientError(\"Schema parse failed: %s\" % (str(e)))",
        "history": [],
        "output": "Parse a schema given a schema string",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def set_http_port(port=80):\n    '''\n    Configure the port HTTP should listen on\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' ilo.set_http_port 8080\n    '''\n    _current = global_settings()\n\n    if _current['Global Settings']['HTTP_PORT']['VALUE'] == port:\n        return True\n\n    _xml = \"\"\"<RIBCL VERSION=\"2.0\">\n                <LOGIN USER_LOGIN=\"adminname\" PASSWORD=\"password\">\n                  <RIB_INFO MODE=\"write\">\n                    <MOD_GLOBAL_SETTINGS>\n                      <HTTP_PORT value=\"{0}\"/>\n                    </MOD_GLOBAL_SETTINGS>\n                  </RIB_INFO>\n                </LOGIN>\n              </RIBCL>\"\"\".format(port)\n\n    return __execute_cmd('Set_HTTP_Port', _xml)",
        "history": [],
        "output": "Configure the port HTTP should listen on\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' ilo.set_http_port 8080",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def load_tf_weights_in_openai_gpt(model, openai_checkpoint_folder_path):\n    \"\"\" Load tf pre-trained weights in a pytorch model (from NumPy arrays here)\n    \"\"\"\n    import re\n    import numpy as np\n    print(\"Loading weights...\")\n    names = json.load(open(openai_checkpoint_folder_path + '/parameters_names.json', \"r\", encoding='utf-8'))\n    shapes = json.load(open(openai_checkpoint_folder_path + '/params_shapes.json', \"r\", encoding='utf-8'))\n    offsets = np.cumsum([np.prod(shape) for shape in shapes])\n    init_params = [np.load(openai_checkpoint_folder_path + '/params_{}.npy'.format(n)) for n in range(10)]\n    init_params = np.split(np.concatenate(init_params, 0), offsets)[:-1]\n    init_params = [param.reshape(shape) for param, shape in zip(init_params, shapes)]\n\n    # This was used when we had a single embedding matrix for positions and tokens\n    # init_params[0] = np.concatenate([init_params[1], init_params[0]], 0)\n    # del init_params[1]\n    init_params = [arr.squeeze() for arr in init_params]\n\n    try:\n        assert model.tokens_embed.weight.shape == init_params[1].shape\n        assert model.positions_embed.weight.shape == init_params[0].shape\n    except AssertionError as e:\n        e.args += (model.tokens_embed.weight.shape, init_params[1].shape)\n        e.args += (model.positions_embed.weight.shape, init_params[0].shape)\n        raise\n\n    model.tokens_embed.weight.data = torch.from_numpy(init_params[1])\n    model.positions_embed.weight.data = torch.from_numpy(init_params[0])\n    names.pop(0)\n    # Pop position and token embedding arrays\n    init_params.pop(0)\n    init_params.pop(0)\n\n    for name, array in zip(names, init_params): # names[1:n_transfer], init_params[1:n_transfer]):\n        name = name[6:]  # skip \"model/\"\n        assert name[-2:] == \":0\"\n        name = name[:-2]\n        name = name.split('/')\n        pointer = model\n        for m_name in name:\n            if re.fullmatch(r'[A-Za-z]+\\d+', m_name):\n                l = re.split(r'(\\d+)', m_name)\n            else:\n                l = [m_name]\n            if l[0] == 'g':\n                pointer = getattr(pointer, 'weight')\n            elif l[0] == 'b':\n                pointer = getattr(pointer, 'bias')\n            elif l[0] == 'w':\n                pointer = getattr(pointer, 'weight')\n            else:\n                pointer = getattr(pointer, l[0])\n            if len(l) >= 2:\n                num = int(l[1])\n                pointer = pointer[num]\n        try:\n            assert pointer.shape == array.shape\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        try:\n            assert pointer.shape == array.shape\n        except AssertionError as e:\n            e.args += (pointer.shape, array.shape)\n            raise\n        print(\"Initialize PyTorch weight {}\".format(name))\n        pointer.data = torch.from_numpy(array)\n    return model",
        "history": [],
        "output": "Load tf pre-trained weights in a pytorch model (from NumPy arrays here)",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def finalizer(self, data):\n        '''\n        Ensure that printed mappings are YAML friendly.\n        '''\n        def explore(data):\n            if isinstance(data, (dict, OrderedDict)):\n                return PrintableDict(\n                    [(key, explore(value)) for key, value in six.iteritems(data)]\n                )\n            elif isinstance(data, (list, tuple, set)):\n                return data.__class__([explore(value) for value in data])\n            return data\n        return explore(data)",
        "history": [],
        "output": "Ensure that printed mappings are YAML friendly.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def tenant_absent(name, profile=None, **connection_args):\n    '''\n    Ensure that the keystone tenant is absent.\n\n    name\n        The name of the tenant that should not exist\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': 'Tenant / project \"{0}\" is already absent'.format(name)}\n\n    # Check if tenant is present\n    tenant = __salt__['keystone.tenant_get'](name=name,\n                                             profile=profile,\n                                             **connection_args)\n    if 'Error' not in tenant:\n        if __opts__.get('test'):\n            ret['result'] = None\n            ret['comment'] = 'Tenant / project \"{0}\" will be deleted'.format(name)\n            return ret\n        # Delete tenant\n        __salt__['keystone.tenant_delete'](name=name, profile=profile,\n                                           **connection_args)\n        ret['comment'] = 'Tenant / project \"{0}\" has been deleted'.format(name)\n        ret['changes']['Tenant/Project'] = 'Deleted'\n\n    return ret",
        "history": [],
        "output": "Ensure that the keystone tenant is absent.\n\n    name\n        The name of the tenant that should not exist",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def c_int_array(data):\n    \"\"\"Get pointer of int numpy array / list.\"\"\"\n    if is_1d_list(data):\n        data = np.array(data, copy=False)\n    if is_numpy_1d_array(data):\n        data = convert_from_sliced_object(data)\n        assert data.flags.c_contiguous\n        if data.dtype == np.int32:\n            ptr_data = data.ctypes.data_as(ctypes.POINTER(ctypes.c_int32))\n            type_data = C_API_DTYPE_INT32\n        elif data.dtype == np.int64:\n            ptr_data = data.ctypes.data_as(ctypes.POINTER(ctypes.c_int64))\n            type_data = C_API_DTYPE_INT64\n        else:\n            raise TypeError(\"Expected np.int32 or np.int64, met type({})\"\n                            .format(data.dtype))\n    else:\n        raise TypeError(\"Unknown type({})\".format(type(data).__name__))\n    return (ptr_data, type_data, data)",
        "history": [],
        "output": "Get pointer of int numpy array / list.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def macro_body(self, node, frame):\n        \"\"\"Dump the function def of a macro or call block.\"\"\"\n        frame = frame.inner()\n        frame.symbols.analyze_node(node)\n        macro_ref = MacroRef(node)\n\n        explicit_caller = None\n        skip_special_params = set()\n        args = []\n        for idx, arg in enumerate(node.args):\n            if arg.name == 'caller':\n                explicit_caller = idx\n            if arg.name in ('kwargs', 'varargs'):\n                skip_special_params.add(arg.name)\n            args.append(frame.symbols.ref(arg.name))\n\n        undeclared = find_undeclared(node.body, ('caller', 'kwargs', 'varargs'))\n\n        if 'caller' in undeclared:\n            # In older Jinja2 versions there was a bug that allowed caller\n            # to retain the special behavior even if it was mentioned in\n            # the argument list.  However thankfully this was only really\n            # working if it was the last argument.  So we are explicitly\n            # checking this now and error out if it is anywhere else in\n            # the argument list.\n            if explicit_caller is not None:\n                try:\n                    node.defaults[explicit_caller - len(node.args)]\n                except IndexError:\n                    self.fail('When defining macros or call blocks the '\n                              'special \"caller\" argument must be omitted '\n                              'or be given a default.', node.lineno)\n            else:\n                args.append(frame.symbols.declare_parameter('caller'))\n            macro_ref.accesses_caller = True\n        if 'kwargs' in undeclared and not 'kwargs' in skip_special_params:\n            args.append(frame.symbols.declare_parameter('kwargs'))\n            macro_ref.accesses_kwargs = True\n        if 'varargs' in undeclared and not 'varargs' in skip_special_params:\n            args.append(frame.symbols.declare_parameter('varargs'))\n            macro_ref.accesses_varargs = True\n\n        # macros are delayed, they never require output checks\n        frame.require_output_check = False\n        frame.symbols.analyze_node(node)\n        self.writeline('%s(%s):' % (self.func('macro'), ', '.join(args)), node)\n        self.indent()\n\n        self.buffer(frame)\n        self.enter_frame(frame)\n\n        self.push_parameter_definitions(frame)\n        for idx, arg in enumerate(node.args):\n            ref = frame.symbols.ref(arg.name)\n            self.writeline('if %s is missing:' % ref)\n            self.indent()\n            try:\n                default = node.defaults[idx - len(node.args)]\n            except IndexError:\n                self.writeline('%s = undefined(%r, name=%r)' % (\n                    ref,\n                    'parameter %r was not provided' % arg.name,\n                    arg.name))\n            else:\n                self.writeline('%s = ' % ref)\n                self.visit(default, frame)\n            self.mark_parameter_stored(ref)\n            self.outdent()\n        self.pop_parameter_definitions()\n\n        self.blockvisit(node.body, frame)\n        self.return_buffer_contents(frame, force_unescaped=True)\n        self.leave_frame(frame, with_python_scope=True)\n        self.outdent()\n\n        return frame, macro_ref",
        "history": [],
        "output": "Dump the function def of a macro or call block.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def attend(x, source, hparams, name):\n  \"\"\"Self-attention layer with source as memory antecedent.\"\"\"\n  with tf.variable_scope(name):\n    x = tf.squeeze(x, axis=2)\n    if len(source.get_shape()) > 3:\n      source = tf.squeeze(source, axis=2)\n    source = common_attention.add_timing_signal_1d(source)\n    y = common_attention.multihead_attention(\n        common_layers.layer_preprocess(x, hparams), source, None,\n        hparams.attention_key_channels or hparams.hidden_size,\n        hparams.attention_value_channels or hparams.hidden_size,\n        hparams.hidden_size, hparams.num_heads,\n        hparams.attention_dropout)\n    res = common_layers.layer_postprocess(x, y, hparams)\n    return tf.expand_dims(res, axis=2)",
        "history": [],
        "output": "Self-attention layer with source as memory antecedent.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_conn(service='SoftLayer_Virtual_Guest'):\n    '''\n    Return a conn object for the passed VM data\n    '''\n    client = SoftLayer.Client(\n        username=config.get_cloud_config_value(\n            'user', get_configured_provider(), __opts__, search_global=False\n        ),\n        api_key=config.get_cloud_config_value(\n            'apikey', get_configured_provider(), __opts__, search_global=False\n        ),\n    )\n    return client[service]",
        "history": [],
        "output": "Return a conn object for the passed VM data",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def save_wdhistory(self):\r\n        \"\"\"Save history to a text file in user home directory\"\"\"\r\n        text = [ to_text_string( self.pathedit.itemText(index) ) \\\r\n                 for index in range(self.pathedit.count()) ]\r\n        try:\r\n            encoding.writelines(text, self.LOG_PATH)\r\n        except EnvironmentError:\r\n            pass",
        "history": [],
        "output": "Save history to a text file in user home directory",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_token_create_url(config):\n    '''\n    Create Vault url for token creation\n    '''\n    role_name = config.get('role_name', None)\n    auth_path = '/v1/auth/token/create'\n    base_url = config['url']\n    return '/'.join(x.strip('/') for x in (base_url, auth_path, role_name) if x)",
        "history": [],
        "output": "Create Vault url for token creation",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def image_encoder(image_feat,\n                  hparams,\n                  name=\"image_encoder\",\n                  save_weights_to=None,\n                  make_image_summary=True):\n  \"\"\"A stack of self attention layers.\"\"\"\n\n  x = image_feat\n  with tf.variable_scope(name):\n    for layer in range(hparams.num_encoder_layers or hparams.num_hidden_layers):\n      with tf.variable_scope(\"layer_%d\" % layer):\n        with tf.variable_scope(\"self_attention\"):\n          y = vqa_layers.multihead_attention(\n              common_layers.layer_preprocess(x, hparams),\n              None,\n              None,\n              hparams.attention_key_channels or hparams.image_hidden_size,\n              hparams.attention_value_channels or hparams.image_hidden_size,\n              hparams.image_hidden_size,\n              hparams.num_heads,\n              hparams.attention_dropout,\n              attention_type=hparams.self_attention_type,\n              save_weights_to=save_weights_to,\n              max_relative_position=None,\n              make_image_summary=make_image_summary,\n              dropout_broadcast_dims=None,\n              max_length=None,\n              vars_3d=False,\n              scale_otproduct=hparams.scale_dotproduct)\n          utils.collect_named_outputs(\"norms\", \"image_feat_self_attention\",\n                                      tf.norm(y, axis=-1))\n          x = common_layers.layer_postprocess(x, y, hparams)\n          utils.collect_named_outputs(\n              \"norms\", \"image_feat_self_attention_zero_add\",\n              tf.norm(x, axis=-1))\n        with tf.variable_scope(\"ffn\"):\n          y = common_layers.dense_relu_dense(\n              common_layers.layer_preprocess(x, hparams),\n              hparams.image_filter_size,\n              hparams.image_hidden_size,\n              dropout=hparams.relu_dropout,\n              dropout_broadcast_dims=None)\n          utils.collect_named_outputs(\"norms\", \"image_feat_ffn\",\n                                      tf.norm(y, axis=-1))\n          x = common_layers.layer_postprocess(x, y, hparams)\n          utils.collect_named_outputs(\"norms\", \"image_feat_ffn_zero_add\",\n                                      tf.norm(x, axis=-1))\n    # if normalization is done in layer_preprocess, then it should also be done\n    # on the output, since the output can grow very large, being the sum of\n    # a whole stack of unnormalized layer outputs.\n    return common_layers.layer_preprocess(x, hparams)",
        "history": [],
        "output": "A stack of self attention layers.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _convert_to_array(array_like, dtype):\n        \"\"\"\n        Convert Matrix attributes which are array-like or buffer to array.\n        \"\"\"\n        if isinstance(array_like, bytes):\n            return np.frombuffer(array_like, dtype=dtype)\n        return np.asarray(array_like, dtype=dtype)",
        "history": [],
        "output": "Convert Matrix attributes which are array-like or buffer to array.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def lmx_moe_h1k_f4k_x32():\n  \"\"\"Transformer with mixture of experts.  890M Params.\"\"\"\n  hparams = lmx_h1k_f4k()\n  hparams.ffn_layer = \"local_moe_tpu\"\n  hparams.moe_num_experts = 32\n  hparams.weight_dtype = \"bfloat16\"\n  hparams.batch_size = 8192\n  return hparams",
        "history": [],
        "output": "Transformer with mixture of experts.  890M Params.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "async def json(self, *, encoding: str=None,\n                   loads: JSONDecoder=DEFAULT_JSON_DECODER,\n                   content_type: Optional[str]='application/json') -> Any:\n        \"\"\"Read and decodes JSON response.\"\"\"\n        if self._body is None:\n            await self.read()\n\n        if content_type:\n            ctype = self.headers.get(hdrs.CONTENT_TYPE, '').lower()\n            if not _is_expected_content_type(ctype, content_type):\n                raise ContentTypeError(\n                    self.request_info,\n                    self.history,\n                    message=('Attempt to decode JSON with '\n                             'unexpected mimetype: %s' % ctype),\n                    headers=self.headers)\n\n        if encoding is None:\n            encoding = self.get_encoding()\n\n        return loads(self._body.decode(encoding))",
        "history": [],
        "output": "Read and decodes JSON response.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def make_input_layers(self):\n        \"\"\"\n        Extract the ordering of the input layers.\n        \"\"\"\n        self.input_layers = []\n        if hasattr(self.model, 'input_layers'):\n            input_keras_layers = self.model.input_layers[:]\n            self.input_layers = [None] * len(input_keras_layers)\n            for layer in self.layer_list:\n                keras_layer = self.keras_layer_map[layer]\n                if isinstance(keras_layer, _keras.engine.topology.InputLayer):\n                    if keras_layer in input_keras_layers:\n                        idx = input_keras_layers.index(keras_layer)\n                        self.input_layers[idx] = layer\n        elif len(self.model.inbound_nodes) <= 1:\n            for ts in _to_list(self.model.input):\n                # search for the InputLayer that matches this ts\n                for l in self.layer_list:\n                    kl = self.keras_layer_map[l]\n                    if isinstance(kl, _keras.engine.topology.InputLayer) and kl.input == ts:\n                        self.input_layers.append(l)\n        else:\n            raise ValueError(\"Input values cannot be identified.\")",
        "history": [],
        "output": "Extract the ordering of the input layers.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def on_backward_begin(self, last_loss:Rank0Tensor, last_input:Tensor, **kwargs):\n        \"Apply AR and TAR to `last_loss`.\"\n        #AR and TAR\n        if self.alpha != 0.:  last_loss += self.alpha * self.out[-1].float().pow(2).mean()\n        if self.beta != 0.:\n            h = self.raw_out[-1]\n            if len(h)>1: last_loss += self.beta * (h[:,1:] - h[:,:-1]).float().pow(2).mean()\n        return {'last_loss': last_loss}",
        "history": [],
        "output": "Apply AR and TAR to `last_loss`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def total_timer(msg):\n    \"\"\" A context which add the time spent inside to TotalTimer. \"\"\"\n    start = timer()\n    yield\n    t = timer() - start\n    _TOTAL_TIMER_DATA[msg].feed(t)",
        "history": [],
        "output": "A context which add the time spent inside to TotalTimer.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def resize(self, size:Union[int,TensorImageSize]) -> 'ImagePoints':\n        \"Resize the image to `size`, size can be a single int.\"\n        if isinstance(size, int): size=(1, size, size)\n        self._flow.size = size[1:]\n        return self",
        "history": [],
        "output": "Resize the image to `size`, size can be a single int.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _memoize(f):\n  \"\"\"Memoizing decorator for f, which must have exactly 1 hashable argument.\"\"\"\n  nothing = object()  # Unique \"no value\" sentinel object.\n  cache = {}\n  # Use a reentrant lock so that if f references the resulting wrapper we die\n  # with recursion depth exceeded instead of deadlocking.\n  lock = threading.RLock()\n  @functools.wraps(f)\n  def wrapper(arg):\n    if cache.get(arg, nothing) is nothing:\n      with lock:\n        if cache.get(arg, nothing) is nothing:\n          cache[arg] = f(arg)\n    return cache[arg]\n  return wrapper",
        "history": [],
        "output": "Memoizing decorator for f, which must have exactly 1 hashable argument.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_git_refs(repopath):\r\n    \"\"\"\r\n    Return Git active branch, state, branches (plus tags).\r\n    \"\"\"\r\n    tags = []\r\n    branches = []\r\n    branch = ''\r\n    files_modifed = []\r\n\r\n    if os.path.isfile(repopath):\r\n        repopath = os.path.dirname(repopath)\r\n\r\n    try:\r\n\r\n        git = programs.find_program('git')\r\n\r\n        # Files modified\r\n        out, err = programs.run_program(\r\n            git, ['status', '-s'],\r\n            cwd=repopath,\r\n        ).communicate()\r\n\r\n        if PY3:\r\n            out = out.decode(sys.getdefaultencoding())\r\n        files_modifed = [line.strip() for line in out.split('\\n') if line]\r\n\r\n        # Tags\r\n        out, err = programs.run_program(\r\n            git, ['tag'],\r\n            cwd=repopath,\r\n        ).communicate()\r\n\r\n        if PY3:\r\n            out = out.decode(sys.getdefaultencoding())\r\n        tags = [line.strip() for line in out.split('\\n') if line]\r\n\r\n        # Branches\r\n        out, err = programs.run_program(\r\n            git, ['branch', '-a'],\r\n            cwd=repopath,\r\n        ).communicate()\r\n\r\n        if PY3:\r\n            out = out.decode(sys.getdefaultencoding())\r\n\r\n        lines = [line.strip() for line in out.split('\\n') if line]\r\n        for line in lines:\r\n            if line.startswith('*'):\r\n                line = line.replace('*', '').strip()\r\n                branch = line\r\n\r\n            branches.append(line)\r\n\r\n    except (subprocess.CalledProcessError, AttributeError, OSError):\r\n        pass\r\n\r\n    return branches + tags, branch, files_modifed",
        "history": [],
        "output": "Return Git active branch, state, branches (plus tags).",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _shorten_file_path(line):\n  \"\"\"Shorten file path in error lines for more readable tracebacks.\"\"\"\n  start = line.lower().find('file')\n  if start < 0:\n    return line\n  first_quote = line.find('\"', start)\n  if first_quote < 0:\n    return line\n  second_quote = line.find('\"', first_quote + 1)\n  if second_quote < 0:\n    return line\n  path = line[first_quote + 1:second_quote]\n  new_path = '/'.join(path.split('/')[-3:])\n  return line[:first_quote] + '[...]/' + new_path + line[second_quote + 1:]",
        "history": [],
        "output": "Shorten file path in error lines for more readable tracebacks.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def task_absent(name):\n    '''\n    Ensure that a task is absent from Kapacitor.\n\n    name\n        Name of the task.\n    '''\n    ret = {'name': name, 'changes': {}, 'result': True, 'comment': ''}\n\n    task = __salt__['kapacitor.get_task'](name)\n\n    if task:\n        if __opts__['test']:\n            ret['result'] = None\n            ret['comment'] = 'Task would have been deleted'\n        else:\n            result = __salt__['kapacitor.delete_task'](name)\n            ret['result'] = result['success']\n            if not ret['result']:\n                ret['comment'] = 'Could not disable task'\n                if result.get('stderr'):\n                    ret['comment'] += '\\n' + result['stderr']\n                return ret\n            ret['comment'] = 'Task was deleted'\n        ret['changes'][name] = 'deleted'\n    else:\n        ret['comment'] = 'Task does not exist'\n\n    return ret",
        "history": [],
        "output": "Ensure that a task is absent from Kapacitor.\n\n    name\n        Name of the task.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def check_origin(self, origin):\n        \"\"\"\n        If cors is enabled, check that the origin is allowed\n        \"\"\"\n\n        mod_opts = self.application.mod_opts\n\n        if mod_opts.get('cors_origin'):\n            return bool(_check_cors_origin(origin, mod_opts['cors_origin']))\n        else:\n            return super(AllEventsHandler, self).check_origin(origin)",
        "history": [],
        "output": "If cors is enabled, check that the origin is allowed",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def parsePoint(line):\n    \"\"\"\n    Parse a line of text into an MLlib LabeledPoint object.\n    \"\"\"\n    values = [float(s) for s in line.split(' ')]\n    if values[0] == -1:   # Convert -1 labels to 0 for MLlib\n        values[0] = 0\n    return LabeledPoint(values[0], values[1:])",
        "history": [],
        "output": "Parse a line of text into an MLlib LabeledPoint object.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def overlap_tokens(doc, other_doc):\n    \"\"\"Get the tokens from the original Doc that are also in the comparison Doc.\n    \"\"\"\n    overlap = []\n    other_tokens = [token.text for token in other_doc]\n    for token in doc:\n        if token.text in other_tokens:\n            overlap.append(token)\n    return overlap",
        "history": [],
        "output": "Get the tokens from the original Doc that are also in the comparison Doc.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def add_metrics(self, metrics: Iterable[float]) -> None:\n        \"\"\"\n        Helper to add multiple metrics at once.\n        \"\"\"\n        for metric in metrics:\n            self.add_metric(metric)",
        "history": [],
        "output": "Helper to add multiple metrics at once.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def boston(display=False):\n    \"\"\" Return the boston housing data in a nice package. \"\"\"\n\n    d = sklearn.datasets.load_boston()\n    df = pd.DataFrame(data=d.data, columns=d.feature_names) # pylint: disable=E1101\n    return df, d.target",
        "history": [],
        "output": "Return the boston housing data in a nice package.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _ssh_state(chunks, st_kwargs,\n              kwargs, test=False):\n    '''\n    Function to run a state with the given chunk via salt-ssh\n    '''\n    file_refs = salt.client.ssh.state.lowstate_file_refs(\n            chunks,\n            _merge_extra_filerefs(\n                kwargs.get('extra_filerefs', ''),\n                __opts__.get('extra_filerefs', '')\n                )\n            )\n    # Create the tar containing the state pkg and relevant files.\n    trans_tar = salt.client.ssh.state.prep_trans_tar(\n            __context__['fileclient'],\n            chunks,\n            file_refs,\n            __pillar__,\n            st_kwargs['id_'])\n    trans_tar_sum = salt.utils.hashutils.get_hash(trans_tar, __opts__['hash_type'])\n    cmd = 'state.pkg {0}/salt_state.tgz test={1} pkg_sum={2} hash_type={3}'.format(\n            __opts__['thin_dir'],\n            test,\n            trans_tar_sum,\n            __opts__['hash_type'])\n    single = salt.client.ssh.Single(\n            __opts__,\n            cmd,\n            fsclient=__context__['fileclient'],\n            minion_opts=__salt__.minion_opts,\n            **st_kwargs)\n    single.shell.send(\n            trans_tar,\n            '{0}/salt_state.tgz'.format(__opts__['thin_dir']))\n    stdout, stderr, _ = single.cmd_block()\n\n    # Clean up our tar\n    try:\n        os.remove(trans_tar)\n    except (OSError, IOError):\n        pass\n\n    # Read in the JSON data and return the data structure\n    try:\n        return salt.utils.data.decode(salt.utils.json.loads(stdout, object_hook=salt.utils.data.encode_dict))\n    except Exception as e:\n        log.error(\"JSON Render failed for: %s\\n%s\", stdout, stderr)\n        log.error(str(e))\n\n    # If for some reason the json load fails, return the stdout\n    return salt.utils.data.decode(stdout)",
        "history": [],
        "output": "Function to run a state with the given chunk via salt-ssh",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _set_retcode(ret, highstate=None):\n    '''\n    Set the return code based on the data back from the state system\n    '''\n\n    # Set default retcode to 0\n    __context__['retcode'] = 0\n\n    if isinstance(ret, list):\n        __context__['retcode'] = 1\n        return\n    if not salt.utils.state.check_result(ret, highstate=highstate):\n\n        __context__['retcode'] = 2",
        "history": [],
        "output": "Set the return code based on the data back from the state system",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _cutout(x, n_holes:uniform_int=1, length:uniform_int=40):\n    \"Cut out `n_holes` number of square holes of size `length` in image at random locations.\"\n    h,w = x.shape[1:]\n    for n in range(n_holes):\n        h_y = np.random.randint(0, h)\n        h_x = np.random.randint(0, w)\n        y1 = int(np.clip(h_y - length / 2, 0, h))\n        y2 = int(np.clip(h_y + length / 2, 0, h))\n        x1 = int(np.clip(h_x - length / 2, 0, w))\n        x2 = int(np.clip(h_x + length / 2, 0, w))\n        x[:, y1:y2, x1:x2] = 0\n    return x",
        "history": [],
        "output": "Cut out `n_holes` number of square holes of size `length` in image at random locations.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def from_function(cls, func):\n        \"\"\"Constructs Signature for the given python function\"\"\"\n\n        if not isinstance(func, types.FunctionType):\n            raise TypeError(\"{!r} is not a Python function\".format(func))\n\n        Parameter = cls._parameter_cls\n\n        # Parameter information.\n        func_code = func.__code__\n        pos_count = func_code.co_argcount\n        arg_names = func_code.co_varnames\n        positional = tuple(arg_names[:pos_count])\n        keyword_only_count = getattr(func_code, \"co_kwonlyargcount\", 0)\n        keyword_only = arg_names[pos_count : (pos_count + keyword_only_count)]\n        annotations = getattr(func, \"__annotations__\", {})\n        defaults = func.__defaults__\n        kwdefaults = getattr(func, \"__kwdefaults__\", None)\n\n        if defaults:\n            pos_default_count = len(defaults)\n        else:\n            pos_default_count = 0\n\n        parameters = []\n\n        # Non-keyword-only parameters w/o defaults.\n        non_default_count = pos_count - pos_default_count\n        for name in positional[:non_default_count]:\n            annotation = annotations.get(name, _empty)\n            parameters.append(\n                Parameter(name, annotation=annotation, kind=_POSITIONAL_OR_KEYWORD)\n            )\n\n        # ... w/ defaults.\n        for offset, name in enumerate(positional[non_default_count:]):\n            annotation = annotations.get(name, _empty)\n            parameters.append(\n                Parameter(\n                    name,\n                    annotation=annotation,\n                    kind=_POSITIONAL_OR_KEYWORD,\n                    default=defaults[offset],\n                )\n            )\n\n        # *args\n        if func_code.co_flags & 0x04:\n            name = arg_names[pos_count + keyword_only_count]\n            annotation = annotations.get(name, _empty)\n            parameters.append(\n                Parameter(name, annotation=annotation, kind=_VAR_POSITIONAL)\n            )\n\n        # Keyword-only parameters.\n        for name in keyword_only:\n            default = _empty\n            if kwdefaults is not None:\n                default = kwdefaults.get(name, _empty)\n\n            annotation = annotations.get(name, _empty)\n            parameters.append(\n                Parameter(\n                    name, annotation=annotation, kind=_KEYWORD_ONLY, default=default\n                )\n            )\n        # **kwargs\n        if func_code.co_flags & 0x08:\n            index = pos_count + keyword_only_count\n            if func_code.co_flags & 0x04:\n                index += 1\n\n            name = arg_names[index]\n            annotation = annotations.get(name, _empty)\n            parameters.append(Parameter(name, annotation=annotation, kind=_VAR_KEYWORD))\n\n        return cls(\n            parameters,\n            return_annotation=annotations.get(\"return\", _empty),\n            __validate_parameters__=False,\n        )",
        "history": [],
        "output": "Constructs Signature for the given python function",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def padded_ds(ll_input, size=(250, 300), resize_method=ResizeMethod.CROP, padding_mode='zeros', **kwargs):\n        \"For a LabelList `ll_input`, resize each image to `size` using `resize_method` and `padding_mode`.\"\n        return ll_input.transform(tfms=crop_pad(), size=size, resize_method=resize_method, padding_mode=padding_mode)",
        "history": [],
        "output": "For a LabelList `ll_input`, resize each image to `size` using `resize_method` and `padding_mode`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def parse_auth(rule):\n    '''\n    Parses the auth/authconfig line\n    '''\n    parser = argparse.ArgumentParser()\n    rules = shlex.split(rule)\n    rules.pop(0)\n    noargs = ('back', 'test', 'nostart', 'kickstart', 'probe', 'enablecache',\n              'disablecache', 'disablenis', 'enableshadow', 'disableshadow',\n              'enablemd5', 'disablemd5', 'enableldap', 'enableldapauth',\n              'enableldaptls', 'disableldap', 'disableldapauth',\n              'enablekrb5kdcdns', 'disablekrb5kdcdns', 'enablekrb5realmdns',\n              'disablekrb5realmdns', 'disablekrb5', 'disablehe-siod',\n              'enablesmbauth', 'disablesmbauth', 'enablewinbind',\n              'enablewinbindauth', 'disablewinbind', 'disablewinbindauth',\n              'enablewinbindusedefaultdomain', 'disablewinbindusedefaultdomain',\n              'enablewins', 'disablewins')\n    for arg in noargs:\n        parser.add_argument('--{0}'.format(arg), dest=arg, action='store_true')\n\n    parser.add_argument('--enablenis', dest='enablenis', action='store')\n    parser.add_argument('--hesiodrhs', dest='hesiodrhs', action='store')\n    parser.add_argument('--krb5adminserver', dest='krb5adminserver',\n                        action='append')\n    parser.add_argument('--krb5kdc', dest='krb5kdc', action='append')\n    parser.add_argument('--ldapbasedn', dest='ldapbasedn', action='store')\n    parser.add_argument('--ldapserver', dest='ldapserver', action='append')\n    parser.add_argument('--nisserver', dest='nisserver', action='append')\n    parser.add_argument('--passalgo', dest='passalgo', action='store')\n    parser.add_argument('--smbidmapgid', dest='smbidmapgid', action='store')\n    parser.add_argument('--smbidmapuid', dest='smbidmapuid', action='store')\n    parser.add_argument('--smbrealm', dest='smbrealm', action='store')\n    parser.add_argument('--smbsecurity', dest='smbsecurity', action='store',\n                        choices=['user', 'server', 'domain', 'dns'])\n    parser.add_argument('--smbservers', dest='smbservers', action='store')\n    parser.add_argument('--smbworkgroup', dest='smbworkgroup', action='store')\n    parser.add_argument('--winbindjoin', dest='winbindjoin', action='store')\n    parser.add_argument('--winbindseparator', dest='winbindseparator',\n                        action='store')\n    parser.add_argument('--winbindtemplatehomedir',\n                        dest='winbindtemplatehomedir', action='store')\n    parser.add_argument('--winbindtemplateprimarygroup',\n                        dest='winbindtemplateprimarygroup', action='store')\n    parser.add_argument('--winbindtemplateshell', dest='winbindtemplateshell',\n                        action='store')\n\n    parser.add_argument('--enablekrb5', dest='enablekrb5', action='store_true')\n    if '--enablekrb5' in rules:\n        parser.add_argument('--krb5realm', dest='krb5realm', action='store',\n                            required=True)\n    parser.add_argument('--enablehesiod', dest='enablehesiod',\n                        action='store_true')\n    if '--enablehesiod' in rules:\n        parser.add_argument('--hesiodlhs', dest='hesiodlhs', action='store',\n                            required=True)\n\n    args = clean_args(vars(parser.parse_args(rules)))\n    parser = None\n    return args",
        "history": [],
        "output": "Parses the auth/authconfig line",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_padding_value(dtype):\n  \"\"\"Returns the padding value given a dtype.\"\"\"\n  padding_value = None\n  if dtype == np.uint8:\n    padding_value = np.uint8(0)\n  elif dtype == np.uint16:\n    padding_value = np.uint16(0)\n  elif dtype == np.float32:\n    padding_value = 0.0\n  else:\n    padding_value = 0\n  assert padding_value is not None\n  return padding_value",
        "history": [],
        "output": "Returns the padding value given a dtype.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def newPI(name, content):\n    \"\"\"Creation of a processing instruction element. Use\n       xmlDocNewPI preferably to get string interning \"\"\"\n    ret = libxml2mod.xmlNewPI(name, content)\n    if ret is None:raise treeError('xmlNewPI() failed')\n    return xmlNode(_obj=ret)",
        "history": [],
        "output": "Creation of a processing instruction element. Use\n       xmlDocNewPI preferably to get string interning",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def create_new_file(self, current_path, title, filters, create_func):\r\n        \"\"\"Create new file\r\n        Returns True if successful\"\"\"\r\n        if current_path is None:\r\n            current_path = ''\r\n        if osp.isfile(current_path):\r\n            current_path = osp.dirname(current_path)\r\n        self.redirect_stdio.emit(False)\r\n        fname, _selfilter = getsavefilename(self, title, current_path, filters)\r\n        self.redirect_stdio.emit(True)\r\n        if fname:\r\n            try:\r\n                create_func(fname)\r\n                return fname\r\n            except EnvironmentError as error:\r\n                QMessageBox.critical(self, _(\"New file\"),\r\n                                     _(\"<b>Unable to create file <i>%s</i>\"\r\n                                       \"</b><br><br>Error message:<br>%s\"\r\n                                       ) % (fname, to_text_string(error)))",
        "history": [],
        "output": "Create new file\r\n        Returns True if successful",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def imagetransformer_ae_cifar():\n  \"\"\"Hyperparameters for CIFAR-10 experiments.\"\"\"\n  hparams = transformer_ae_small()\n  hparams.filter_size = 512\n  hparams.num_compress_steps = 3\n  hparams.startup_steps = 10000\n  hparams.is_2d = 0\n  hparams.learning_rate_warmup_steps = 8000\n  hparams.learning_rate = 0.2\n  hparams.hidden_size = 512\n  hparams.batch_size = 1\n  hparams.max_length = 256\n  hparams.dropout = 0.0\n  hparams.clip_grad_norm = 0.  # i.e. no gradient clipping\n  hparams.optimizer_adam_epsilon = 1e-9\n  hparams.learning_rate_decay_scheme = \"noam\"\n  hparams.learning_rate = 0.1\n  hparams.initializer_gain = 0.2\n  hparams.num_hidden_layers = 6\n  hparams.initializer = \"uniform_unit_scaling\"\n  hparams.weight_decay = 0.0\n  hparams.optimizer_adam_beta1 = 0.9\n  hparams.optimizer_adam_beta2 = 0.98\n  hparams.label_smoothing = 0.0\n  hparams.norm_type = \"layer\"\n  hparams.layer_prepostprocess_dropout = 0.0\n  hparams.num_heads = 8\n  hparams.task = \"image\"\n  hparams.ffn_layer = \"conv_hidden_relu\"\n  # All hyperparameters ending in \"dropout\" are automatically set to 0.0\n  # when not in training mode.\n  hparams.attention_dropout = 0.0\n  hparams.relu_dropout = 0.\n  hparams.pos = \"timing\"  # timing, none\n  hparams.nbr_decoder_problems = 1\n  hparams.num_output_layers = 3\n  # TODO(trandustin): semhash doesn't work if filter_size != hidden_size. For\n  # now, set default to dvq.\n  hparams.bottleneck_kind = \"dvq\"\n  hparams.add_hparam(\"block_size\", 1)\n\n  # dilated attention based flags\n  hparams.add_hparam(\"gap_sizes\", [2, 4, 8, 16, 32, 64, 2, 4, 8, 16, 32, 64])\n  hparams.add_hparam(\"dilated_attention\", False)\n\n  # image size related flags\n  # assuming that the image has same height and width\n  hparams.add_hparam(\"img_len\", 32)\n  hparams.add_hparam(\"num_channels\", 3)\n  # Local attention params\n  hparams.add_hparam(\"local_and_global_att\", False)\n  hparams.add_hparam(\"block_length\", 256)\n  hparams.add_hparam(\"block_width\", 128)\n  hparams.num_encoder_layers = 4\n  hparams.num_decoder_layers = 12\n  hparams.add_hparam(\"dec_attention_type\", cia.AttentionType.LOCAL_1D)\n  hparams.add_hparam(\"block_raster_scan\", False)\n  hparams.add_hparam(\"shared_rel\", False)\n\n  # multipos attention params\n  hparams.add_hparam(\"q_filter_width\", 1)\n  hparams.add_hparam(\"kv_filter_width\", 1)\n\n  hparams.add_hparam(\"unconditional\", False)  # unconditional generation\n\n  hparams.bottom[\"targets\"] = modalities.image_channel_embeddings_bottom\n  hparams.top[\"targets\"] = modalities.image_channel_embeddings_top\n  hparams.drop_inputs = True\n  hparams.do_attend_compress = False\n  hparams.do_attend_decompress = False\n  return hparams",
        "history": [],
        "output": "Hyperparameters for CIFAR-10 experiments.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_node(conn, name):\n    '''\n    Return a libcloud node for the named VM\n    '''\n    nodes = conn.list_nodes()\n    for node in nodes:\n        if node.name == name:\n            __utils__['cloud.cache_node'](salt.utils.data.simple_types_filter(node.__dict__), __active_provider_name__, __opts__)\n            return node",
        "history": [],
        "output": "Return a libcloud node for the named VM",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def utime(self, tarinfo, targetpath):\n        \"\"\"Set modification time of targetpath according to tarinfo.\n        \"\"\"\n        if not hasattr(os, 'utime'):\n            return\n        try:\n            os.utime(targetpath, (tarinfo.mtime, tarinfo.mtime))\n        except EnvironmentError as e:\n            raise ExtractError(\"could not change modification time\")",
        "history": [],
        "output": "Set modification time of targetpath according to tarinfo.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_indices(self, names):\n        \"\"\"\n        Safe get multiple indices, translate keys for\n        datelike to underlying repr.\n        \"\"\"\n\n        def get_converter(s):\n            # possibly convert to the actual key types\n            # in the indices, could be a Timestamp or a np.datetime64\n            if isinstance(s, (Timestamp, datetime.datetime)):\n                return lambda key: Timestamp(key)\n            elif isinstance(s, np.datetime64):\n                return lambda key: Timestamp(key).asm8\n            else:\n                return lambda key: key\n\n        if len(names) == 0:\n            return []\n\n        if len(self.indices) > 0:\n            index_sample = next(iter(self.indices))\n        else:\n            index_sample = None     # Dummy sample\n\n        name_sample = names[0]\n        if isinstance(index_sample, tuple):\n            if not isinstance(name_sample, tuple):\n                msg = (\"must supply a tuple to get_group with multiple\"\n                       \" grouping keys\")\n                raise ValueError(msg)\n            if not len(name_sample) == len(index_sample):\n                try:\n                    # If the original grouper was a tuple\n                    return [self.indices[name] for name in names]\n                except KeyError:\n                    # turns out it wasn't a tuple\n                    msg = (\"must supply a same-length tuple to get_group\"\n                           \" with multiple grouping keys\")\n                    raise ValueError(msg)\n\n            converters = [get_converter(s) for s in index_sample]\n            names = (tuple(f(n) for f, n in zip(converters, name))\n                     for name in names)\n\n        else:\n            converter = get_converter(index_sample)\n            names = (converter(name) for name in names)\n\n        return [self.indices.get(name, []) for name in names]",
        "history": [],
        "output": "Safe get multiple indices, translate keys for\n        datelike to underlying repr.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def ensure_project(\n    three=None,\n    python=None,\n    validate=True,\n    system=False,\n    warn=True,\n    site_packages=False,\n    deploy=False,\n    skip_requirements=False,\n    pypi_mirror=None,\n    clear=False,\n):\n    \"\"\"Ensures both Pipfile and virtualenv exist for the project.\"\"\"\n    from .environments import PIPENV_USE_SYSTEM\n\n    # Clear the caches, if appropriate.\n    if clear:\n        print(\"clearing\")\n        sys.exit(1)\n\n    # Automatically use an activated virtualenv.\n    if PIPENV_USE_SYSTEM:\n        system = True\n    if not project.pipfile_exists and deploy:\n        raise exceptions.PipfileNotFound\n    # Fail if working under /\n    if not project.name:\n        click.echo(\n            \"{0}: Pipenv is not intended to work under the root directory, \"\n            \"please choose another path.\".format(crayons.red(\"ERROR\")),\n            err=True\n        )\n        sys.exit(1)\n    # Skip virtualenv creation when --system was used.\n    if not system:\n        ensure_virtualenv(\n            three=three,\n            python=python,\n            site_packages=site_packages,\n            pypi_mirror=pypi_mirror,\n        )\n        if warn:\n            # Warn users if they are using the wrong version of Python.\n            if project.required_python_version:\n                path_to_python = which(\"python\") or which(\"py\")\n                if path_to_python and project.required_python_version not in (\n                    python_version(path_to_python) or \"\"\n                ):\n                    click.echo(\n                        \"{0}: Your Pipfile requires {1} {2}, \"\n                        \"but you are using {3} ({4}).\".format(\n                            crayons.red(\"Warning\", bold=True),\n                            crayons.normal(\"python_version\", bold=True),\n                            crayons.blue(project.required_python_version),\n                            crayons.blue(python_version(path_to_python)),\n                            crayons.green(shorten_path(path_to_python)),\n                        ),\n                        err=True,\n                    )\n                    click.echo(\n                        \"  {0} and rebuilding the virtual environment \"\n                        \"may resolve the issue.\".format(crayons.green(\"$ pipenv --rm\")),\n                        err=True,\n                    )\n                    if not deploy:\n                        click.echo(\n                            \"  {0} will surely fail.\"\n                            \"\".format(crayons.red(\"$ pipenv check\")),\n                            err=True,\n                        )\n                    else:\n                        raise exceptions.DeployException\n    # Ensure the Pipfile exists.\n    ensure_pipfile(\n        validate=validate, skip_requirements=skip_requirements, system=system\n    )",
        "history": [],
        "output": "Ensures both Pipfile and virtualenv exist for the project.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _parse_kexgss_group(self, m):\n        \"\"\"\n        Parse the SSH2_MSG_KEXGSS_GROUP message (client mode).\n\n        :param `Message` m: The content of the SSH2_MSG_KEXGSS_GROUP message\n        \"\"\"\n        self.p = m.get_mpint()\n        self.g = m.get_mpint()\n        # reject if p's bit length < 1024 or > 8192\n        bitlen = util.bit_length(self.p)\n        if (bitlen < 1024) or (bitlen > 8192):\n            raise SSHException(\n                \"Server-generated gex p (don't ask) is out of range \"\n                \"({} bits)\".format(bitlen)\n            )\n        self.transport._log(\n            DEBUG, \"Got server p ({} bits)\".format(bitlen)\n        )  # noqa\n        self._generate_x()\n        # now compute e = g^x mod p\n        self.e = pow(self.g, self.x, self.p)\n        m = Message()\n        m.add_byte(c_MSG_KEXGSS_INIT)\n        m.add_string(self.kexgss.ssh_init_sec_context(target=self.gss_host))\n        m.add_mpint(self.e)\n        self.transport._send_message(m)\n        self.transport._expect_packet(\n            MSG_KEXGSS_HOSTKEY,\n            MSG_KEXGSS_CONTINUE,\n            MSG_KEXGSS_COMPLETE,\n            MSG_KEXGSS_ERROR,\n        )",
        "history": [],
        "output": "Parse the SSH2_MSG_KEXGSS_GROUP message (client mode).\n\n        :param `Message` m: The content of the SSH2_MSG_KEXGSS_GROUP message",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _maybe_add_condition_to_implicit_api(self, template_dict):\n        \"\"\"\n        Decides whether to add a condition to the implicit api resource.\n        :param dict template_dict: SAM template dictionary\n        \"\"\"\n        # Short-circuit if template doesn't have any functions with implicit API events\n        if not self.api_conditions.get(self.implicit_api_logical_id, {}):\n            return\n\n        # Add a condition to the API resource IFF all of its resource+methods are associated with serverless functions\n        # containing conditions.\n        implicit_api_conditions = self.api_conditions[self.implicit_api_logical_id]\n        all_resource_method_conditions = set([condition\n                                              for path, method_conditions in implicit_api_conditions.items()\n                                              for method, condition in method_conditions.items()])\n        at_least_one_resource_method = len(all_resource_method_conditions) > 0\n        all_resource_methods_contain_conditions = None not in all_resource_method_conditions\n        if at_least_one_resource_method and all_resource_methods_contain_conditions:\n            implicit_api_resource = template_dict.get('Resources').get(self.implicit_api_logical_id)\n            if len(all_resource_method_conditions) == 1:\n                condition = all_resource_method_conditions.pop()\n                implicit_api_resource['Condition'] = condition\n            else:\n                # If multiple functions with multiple different conditions reference the Implicit Api, we need to\n                # aggregate those conditions in order to conditionally create the Implicit Api. See RFC:\n                # https://github.com/awslabs/serverless-application-model/issues/758\n                implicit_api_resource['Condition'] = self.implicit_api_condition\n                self._add_combined_condition_to_template(\n                    template_dict, self.implicit_api_condition, all_resource_method_conditions)",
        "history": [],
        "output": "Decides whether to add a condition to the implicit api resource.\n        :param dict template_dict: SAM template dictionary",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def debug_option(f):\n    \"\"\"\n    Configures --debug option for CLI\n\n    :param f: Callback Function to be passed to Click\n    \"\"\"\n    def callback(ctx, param, value):\n        state = ctx.ensure_object(Context)\n        state.debug = value\n        return value\n\n    return click.option('--debug',\n                        expose_value=False,\n                        is_flag=True,\n                        envvar=\"SAM_DEBUG\",\n                        help='Turn on debug logging to print debug message generated by SAM CLI.',\n                        callback=callback)(f)",
        "history": [],
        "output": "Configures --debug option for CLI\n\n    :param f: Callback Function to be passed to Click",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _log_changes(ret, changekey, changevalue):\n    '''\n    For logging create/update/delete operations to AWS ApiGateway\n    '''\n    cl = ret['changes'].get('new', [])\n    cl.append({changekey: _object_reducer(changevalue)})\n    ret['changes']['new'] = cl\n    return ret",
        "history": [],
        "output": "For logging create/update/delete operations to AWS ApiGateway",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def convert(self, values, nan_rep, encoding, errors):\n        \"\"\"set the data from this selection (and convert to the correct dtype\n        if we can)\n        \"\"\"\n\n        # values is a recarray\n        if values.dtype.fields is not None:\n            values = values[self.cname]\n\n        self.set_data(values)\n\n        # use the meta if needed\n        meta = _ensure_decoded(self.meta)\n\n        # convert to the correct dtype\n        if self.dtype is not None:\n            dtype = _ensure_decoded(self.dtype)\n\n            # reverse converts\n            if dtype == 'datetime64':\n\n                # recreate with tz if indicated\n                self.data = _set_tz(self.data, self.tz, coerce=True)\n\n            elif dtype == 'timedelta64':\n                self.data = np.asarray(self.data, dtype='m8[ns]')\n            elif dtype == 'date':\n                try:\n                    self.data = np.asarray(\n                        [date.fromordinal(v) for v in self.data], dtype=object)\n                except ValueError:\n                    self.data = np.asarray(\n                        [date.fromtimestamp(v) for v in self.data],\n                        dtype=object)\n            elif dtype == 'datetime':\n                self.data = np.asarray(\n                    [datetime.fromtimestamp(v) for v in self.data],\n                    dtype=object)\n\n            elif meta == 'category':\n\n                # we have a categorical\n                categories = self.metadata\n                codes = self.data.ravel()\n\n                # if we have stored a NaN in the categories\n                # then strip it; in theory we could have BOTH\n                # -1s in the codes and nulls :<\n                if categories is None:\n                    # Handle case of NaN-only categorical columns in which case\n                    # the categories are an empty array; when this is stored,\n                    # pytables cannot write a zero-len array, so on readback\n                    # the categories would be None and `read_hdf()` would fail.\n                    categories = Index([], dtype=np.float64)\n                else:\n                    mask = isna(categories)\n                    if mask.any():\n                        categories = categories[~mask]\n                        codes[codes != -1] -= mask.astype(int).cumsum().values\n\n                self.data = Categorical.from_codes(codes,\n                                                   categories=categories,\n                                                   ordered=self.ordered)\n\n            else:\n\n                try:\n                    self.data = self.data.astype(dtype, copy=False)\n                except TypeError:\n                    self.data = self.data.astype('O', copy=False)\n\n        # convert nans / decode\n        if _ensure_decoded(self.kind) == 'string':\n            self.data = _unconvert_string_array(\n                self.data, nan_rep=nan_rep, encoding=encoding, errors=errors)\n\n        return self",
        "history": [],
        "output": "set the data from this selection (and convert to the correct dtype\n        if we can)",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def dataset_path(cls, project, dataset):\n        \"\"\"Return a fully-qualified dataset string.\"\"\"\n        return google.api_core.path_template.expand(\n            \"projects/{project}/datasets/{dataset}\", project=project, dataset=dataset\n        )",
        "history": [],
        "output": "Return a fully-qualified dataset string.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def copy_path(self, fnames=None, method=\"absolute\"):\r\n        \"\"\"Copy absolute or relative path to given file(s)/folders(s).\"\"\"\r\n        cb = QApplication.clipboard()\r\n        explorer_dir = self.fsmodel.rootPath()\r\n        if fnames is None:\r\n            fnames = self.get_selected_filenames()\r\n        if not isinstance(fnames, (tuple, list)):\r\n            fnames = [fnames]\r\n        fnames = [_fn.replace(os.sep, \"/\") for _fn in fnames]\r\n        if len(fnames) > 1:\r\n            if method == \"absolute\":\r\n                clipboard_files = ',\\n'.join('\"' + _fn + '\"' for _fn in fnames)\r\n            elif method == \"relative\":\r\n                clipboard_files = ',\\n'.join('\"' +\r\n                                             osp.relpath(_fn, explorer_dir).\r\n                                             replace(os.sep, \"/\") + '\"'\r\n                                             for _fn in fnames)\r\n        else:\r\n            if method == \"absolute\":\r\n                clipboard_files = fnames[0]\r\n            elif method == \"relative\":\r\n                clipboard_files = (osp.relpath(fnames[0], explorer_dir).\r\n                                   replace(os.sep, \"/\"))\r\n        copied_from = self.parent_widget.__class__.__name__\r\n        if copied_from == 'ProjectExplorerWidget' and method == 'relative':\r\n            clipboard_files = [path.strip(',\"') for path in\r\n                               clipboard_files.splitlines()]\r\n            clipboard_files = ['/'.join(path.strip('/').split('/')[1:]) for\r\n                               path in clipboard_files]\r\n            if len(clipboard_files) > 1:\r\n                clipboard_files = ',\\n'.join('\"' + _fn + '\"' for _fn in\r\n                                             clipboard_files)\r\n            else:\r\n                clipboard_files = clipboard_files[0]\r\n        cb.setText(clipboard_files, mode=cb.Clipboard)",
        "history": [],
        "output": "Copy absolute or relative path to given file(s)/folders(s).",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_configured_provider():\n    '''\n    Return the first configured provider instance.\n    '''\n    def __is_provider_configured(opts, provider, required_keys=()):\n        '''\n        Check if the provider is configured.\n        '''\n        if ':' in provider:\n            alias, driver = provider.split(':')\n            if alias not in opts['providers']:\n                return False\n            if driver not in opts['providers'][alias]:\n                return False\n            for key in required_keys:\n                if opts['providers'][alias][driver].get(key, None) is None:\n                    return False\n            return opts['providers'][alias][driver]\n\n        for alias, drivers in six.iteritems(opts['providers']):\n            for driver, provider_details in six.iteritems(drivers):\n                if driver != provider:\n                    continue\n\n                skip_provider = False\n                for key in required_keys:\n                    if provider_details.get(key, None) is None:\n                        # This provider does not include all necessary keys,\n                        # continue to next one.\n                        skip_provider = True\n                        break\n\n                if skip_provider:\n                    continue\n\n                return provider_details\n        return False\n\n    provider = __is_provider_configured(\n        __opts__,\n        __active_provider_name__ or __virtualname__,\n        ('subscription_id', 'tenant', 'client_id', 'secret'),\n    )\n\n    if provider is False:\n        provider = __is_provider_configured(\n            __opts__,\n            __active_provider_name__ or __virtualname__,\n            ('subscription_id', 'username', 'password'),\n        )\n\n    if provider is False:\n        # check if using MSI style credentials...\n        provider = config.is_provider_configured(\n            __opts__,\n            __active_provider_name__ or __virtualname__,\n            required_keys=('subscription_id',),\n        )\n\n    return provider",
        "history": [],
        "output": "Return the first configured provider instance.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def evaluate_train_and_eval(step, inputs, predict_fun, eval_steps, rng,\n                            train_sw=None, eval_sw=None, history=None):\n  \"\"\"Evalaute on train and eval data, and log metrics.\"\"\"\n  step_log(step, \"Evaluation\")\n  train_metrics, eval_metrics = [\n      evaluate(  # pylint: disable=g-complex-comprehension\n          itertools.islice(input_stream(), eval_steps),\n          predict_fun,\n          _METRICS,\n          rng)\n      for input_stream in\n      [inputs.train_eval_stream, inputs.eval_stream]]\n  if train_sw:\n    log_metrics(train_metrics, train_sw, \"train\", step, history=history)\n  if eval_sw:\n    log_metrics(eval_metrics, eval_sw, \"eval\", step, history=history)\n  step_log(step, \"Finished evaluation\")\n  return train_metrics, eval_metrics",
        "history": [],
        "output": "Evalaute on train and eval data, and log metrics.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def to_api_repr(self):\n        \"\"\"Generate a resource for :meth:`_begin`.\"\"\"\n\n        source_ref = {\n            \"projectId\": self.source.project,\n            \"datasetId\": self.source.dataset_id,\n            \"tableId\": self.source.table_id,\n        }\n\n        configuration = self._configuration.to_api_repr()\n        _helpers._set_sub_prop(configuration, [\"extract\", \"sourceTable\"], source_ref)\n        _helpers._set_sub_prop(\n            configuration, [\"extract\", \"destinationUris\"], self.destination_uris\n        )\n\n        return {\n            \"jobReference\": self._properties[\"jobReference\"],\n            \"configuration\": configuration,\n        }",
        "history": [],
        "output": "Generate a resource for :meth:`_begin`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def common_params(task_instance, task_cls):\n    \"\"\"\n    Grab all the values in task_instance that are found in task_cls.\n    \"\"\"\n    if not isinstance(task_cls, task.Register):\n        raise TypeError(\"task_cls must be an uninstantiated Task\")\n\n    task_instance_param_names = dict(task_instance.get_params()).keys()\n    task_cls_params_dict = dict(task_cls.get_params())\n    task_cls_param_names = task_cls_params_dict.keys()\n    common_param_names = set(task_instance_param_names).intersection(set(task_cls_param_names))\n    common_param_vals = [(key, task_cls_params_dict[key]) for key in common_param_names]\n    common_kwargs = dict((key, task_instance.param_kwargs[key]) for key in common_param_names)\n    vals = dict(task_instance.get_param_values(common_param_vals, [], common_kwargs))\n    return vals",
        "history": [],
        "output": "Grab all the values in task_instance that are found in task_cls.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def handle_stream(self, stream, address):\n        '''\n        Handle incoming streams and add messages to the incoming queue\n        '''\n        log.trace('Req client %s connected', address)\n        self.clients.append((stream, address))\n        unpacker = msgpack.Unpacker()\n        try:\n            while True:\n                wire_bytes = yield stream.read_bytes(4096, partial=True)\n                unpacker.feed(wire_bytes)\n                for framed_msg in unpacker:\n                    if six.PY3:\n                        framed_msg = salt.transport.frame.decode_embedded_strs(\n                            framed_msg\n                        )\n                    header = framed_msg['head']\n                    self.io_loop.spawn_callback(self.message_handler, stream, header, framed_msg['body'])\n\n        except StreamClosedError:\n            log.trace('req client disconnected %s', address)\n            self.clients.remove((stream, address))\n        except Exception as e:\n            log.trace('other master-side exception: %s', e)\n            self.clients.remove((stream, address))\n            stream.close()",
        "history": [],
        "output": "Handle incoming streams and add messages to the incoming queue",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def getCheckpointFile(self):\n        \"\"\"\n        Gets the name of the file to which this RDD was checkpointed\n\n        Not defined if RDD is checkpointed locally.\n        \"\"\"\n        checkpointFile = self._jrdd.rdd().getCheckpointFile()\n        if checkpointFile.isDefined():\n            return checkpointFile.get()",
        "history": [],
        "output": "Gets the name of the file to which this RDD was checkpointed\n\n        Not defined if RDD is checkpointed locally.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def is_named_tuple(cls):\n    \"\"\"Return True if cls is a namedtuple and False otherwise.\"\"\"\n    b = cls.__bases__\n    if len(b) != 1 or b[0] != tuple:\n        return False\n    f = getattr(cls, \"_fields\", None)\n    if not isinstance(f, tuple):\n        return False\n    return all(type(n) == str for n in f)",
        "history": [],
        "output": "Return True if cls is a namedtuple and False otherwise.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def check_env_cache(opts, env_cache):\n    '''\n    Returns cached env names, if present. Otherwise returns None.\n    '''\n    if not os.path.isfile(env_cache):\n        return None\n    try:\n        with salt.utils.files.fopen(env_cache, 'rb') as fp_:\n            log.trace('Returning env cache data from %s', env_cache)\n            serial = salt.payload.Serial(opts)\n            return salt.utils.data.decode(serial.load(fp_))\n    except (IOError, OSError):\n        pass\n    return None",
        "history": [],
        "output": "Returns cached env names, if present. Otherwise returns None.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _has_valid_tuple(self, key):\n        \"\"\" check the key for valid keys across my indexer \"\"\"\n        for i, k in enumerate(key):\n            if i >= self.obj.ndim:\n                raise IndexingError('Too many indexers')\n            try:\n                self._validate_key(k, i)\n            except ValueError:\n                raise ValueError(\"Location based indexing can only have \"\n                                 \"[{types}] types\"\n                                 .format(types=self._valid_types))",
        "history": [],
        "output": "check the key for valid keys across my indexer",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def build_scala(app):\n    \"\"\"build scala for scala docs, java docs, and clojure docs to use\"\"\"\n    if any(v in _BUILD_VER for v in ['1.2.', '1.3.', '1.4.']):\n        _run_cmd(\"cd %s/.. && make scalapkg\" % app.builder.srcdir)\n        _run_cmd(\"cd %s/.. && make scalainstall\" % app.builder.srcdir)\n    else:\n        _run_cmd(\"cd %s/../scala-package && mvn -B install -DskipTests\" % app.builder.srcdir)",
        "history": [],
        "output": "build scala for scala docs, java docs, and clojure docs to use",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def policy_and_value_opt_step(i,\n                              opt_state,\n                              opt_update,\n                              policy_and_value_net_apply,\n                              old_params,\n                              padded_observations,\n                              padded_actions,\n                              padded_rewards,\n                              reward_mask,\n                              c1=1.0,\n                              c2=0.01,\n                              gamma=0.99,\n                              lambda_=0.95,\n                              epsilon=0.1):\n  \"\"\"Policy and Value optimizer step.\"\"\"\n  # Combined loss function given the new params.\n  def policy_and_value_loss(params):\n    \"\"\"Returns the combined loss given just parameters.\"\"\"\n    (loss, _, _, _) = combined_loss(\n        params,\n        old_params,\n        policy_and_value_net_apply,\n        padded_observations,\n        padded_actions,\n        padded_rewards,\n        reward_mask,\n        c1=c1,\n        c2=c2,\n        gamma=gamma,\n        lambda_=lambda_,\n        epsilon=epsilon)\n    return loss\n\n  new_params = trax_opt.get_params(opt_state)\n  g = grad(policy_and_value_loss)(new_params)\n  return opt_update(i, g, opt_state)",
        "history": [],
        "output": "Policy and Value optimizer step.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def parse_human_timedelta(s: str):\n    \"\"\"\n    Returns ``datetime.datetime`` from natural language time deltas\n\n    >>> parse_human_datetime('now') <= datetime.now()\n    True\n    \"\"\"\n    cal = parsedatetime.Calendar()\n    dttm = dttm_from_timtuple(datetime.now().timetuple())\n    d = cal.parse(s or '', dttm)[0]\n    d = datetime(d.tm_year, d.tm_mon, d.tm_mday, d.tm_hour, d.tm_min, d.tm_sec)\n    return d - dttm",
        "history": [],
        "output": "Returns ``datetime.datetime`` from natural language time deltas\n\n    >>> parse_human_datetime('now') <= datetime.now()\n    True",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def absent(name, auth=None):\n    '''\n    Ensure a subnet does not exists\n\n    name\n        Name of the subnet\n\n    '''\n    ret = {'name': name,\n           'changes': {},\n           'result': True,\n           'comment': ''}\n\n    __salt__['neutronng.setup_clouds'](auth)\n\n    subnet = __salt__['neutronng.subnet_get'](name=name)\n\n    if subnet:\n        if __opts__['test'] is True:\n            ret['result'] = None\n            ret['changes'] = {'id': subnet.id}\n            ret['comment'] = 'Project will be deleted.'\n            return ret\n\n        __salt__['neutronng.subnet_delete'](name=subnet)\n        ret['changes']['id'] = name\n        ret['comment'] = 'Deleted subnet'\n\n    return ret",
        "history": [],
        "output": "Ensure a subnet does not exists\n\n    name\n        Name of the subnet",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def evaluate_world_model(\n    real_env, hparams, world_model_dir, debug_video_path,\n    split=tf.estimator.ModeKeys.EVAL,\n):\n  \"\"\"Evaluate the world model (reward accuracy).\"\"\"\n  frame_stack_size = hparams.frame_stack_size\n  rollout_subsequences = []\n  def initial_frame_chooser(batch_size):\n    assert batch_size == len(rollout_subsequences)\n    return np.stack([\n        [frame.observation.decode() for frame in subsequence[:frame_stack_size]]    # pylint: disable=g-complex-comprehension\n        for subsequence in rollout_subsequences\n    ])\n\n  env_fn = rl.make_simulated_env_fn_from_hparams(\n      real_env, hparams, batch_size=hparams.wm_eval_batch_size,\n      initial_frame_chooser=initial_frame_chooser, model_dir=world_model_dir\n  )\n  sim_env = env_fn(in_graph=False)\n  subsequence_length = int(\n      max(hparams.wm_eval_rollout_ratios) * hparams.simulated_rollout_length\n  )\n  rollouts = real_env.current_epoch_rollouts(\n      split=split,\n      minimal_rollout_frames=(subsequence_length + frame_stack_size)\n  )\n\n  video_writer = common_video.WholeVideoWriter(\n      fps=10, output_path=debug_video_path, file_format=\"avi\"\n  )\n\n  reward_accuracies_by_length = {\n      int(ratio * hparams.simulated_rollout_length): []\n      for ratio in hparams.wm_eval_rollout_ratios\n  }\n  for _ in range(hparams.wm_eval_num_batches):\n    rollout_subsequences[:] = random_rollout_subsequences(\n        rollouts, hparams.wm_eval_batch_size,\n        subsequence_length + frame_stack_size\n    )\n\n    eval_subsequences = [\n        subsequence[(frame_stack_size - 1):]\n        for subsequence in rollout_subsequences\n    ]\n\n    # Check that the initial observation is the same in the real and simulated\n    # rollout.\n    sim_init_obs = sim_env.reset()\n    def decode_real_obs(index):\n      return np.stack([\n          subsequence[index].observation.decode()\n          for subsequence in eval_subsequences  # pylint: disable=cell-var-from-loop\n      ])\n    real_init_obs = decode_real_obs(0)\n    assert np.all(sim_init_obs == real_init_obs)\n\n    debug_frame_batches = []\n    def append_debug_frame_batch(sim_obs, real_obs, sim_cum_rews,\n                                 real_cum_rews, sim_rews, real_rews):\n      \"\"\"Add a debug frame.\"\"\"\n      rews = [[sim_cum_rews, sim_rews], [real_cum_rews, real_rews]]\n      headers = []\n      for j in range(len(sim_obs)):\n        local_nps = []\n        for i in range(2):\n          img = PIL_Image().new(\"RGB\", (sim_obs.shape[-2], 11),)\n          draw = PIL_ImageDraw().Draw(img)\n          draw.text((0, 0), \"c:{:3}, r:{:3}\".format(int(rews[i][0][j]),\n                                                    int(rews[i][1][j])),\n                    fill=(255, 0, 0))\n          local_nps.append(np.asarray(img))\n        local_nps.append(np.zeros_like(local_nps[0]))\n        headers.append(np.concatenate(local_nps, axis=1))\n      errs = absolute_hinge_difference(sim_obs, real_obs)\n      headers = np.stack(headers)\n      debug_frame_batches.append(  # pylint: disable=cell-var-from-loop\n          np.concatenate([headers,\n                          np.concatenate([sim_obs, real_obs, errs], axis=2)],\n                         axis=1)\n      )\n    append_debug_frame_batch(sim_init_obs, real_init_obs,\n                             np.zeros(hparams.wm_eval_batch_size),\n                             np.zeros(hparams.wm_eval_batch_size),\n                             np.zeros(hparams.wm_eval_batch_size),\n                             np.zeros(hparams.wm_eval_batch_size))\n\n    (sim_cum_rewards, real_cum_rewards) = (\n        np.zeros(hparams.wm_eval_batch_size) for _ in range(2)\n    )\n    for i in range(subsequence_length):\n      actions = [subsequence[i].action for subsequence in eval_subsequences]\n      (sim_obs, sim_rewards, _) = sim_env.step(actions)\n      sim_cum_rewards += sim_rewards\n\n      real_rewards = np.array([\n          subsequence[i + 1].reward for subsequence in eval_subsequences\n      ])\n      real_cum_rewards += real_rewards\n      for (length, reward_accuracies) in six.iteritems(\n          reward_accuracies_by_length\n      ):\n        if i + 1 == length:\n          reward_accuracies.append(\n              np.sum(sim_cum_rewards == real_cum_rewards) /\n              len(real_cum_rewards)\n          )\n\n      real_obs = decode_real_obs(i + 1)\n      append_debug_frame_batch(sim_obs, real_obs, sim_cum_rewards,\n                               real_cum_rewards, sim_rewards, real_rewards)\n\n    for debug_frames in np.stack(debug_frame_batches, axis=1):\n      debug_frame = None\n      for debug_frame in debug_frames:\n        video_writer.write(debug_frame)\n\n      if debug_frame is not None:\n        # Append two black frames for aesthetics.\n        for _ in range(2):\n          video_writer.write(np.zeros_like(debug_frame))\n\n  video_writer.finish_to_disk()\n\n  return {\n      \"reward_accuracy/at_{}\".format(length): np.mean(reward_accuracies)\n      for (length, reward_accuracies) in six.iteritems(\n          reward_accuracies_by_length\n      )\n  }",
        "history": [],
        "output": "Evaluate the world model (reward accuracy).",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_config(self):\n        \"\"\"Return configurations of EpsGreedyQPolicy\n\n        # Returns\n            Dict of config\n        \"\"\"\n        config = super(EpsGreedyQPolicy, self).get_config()\n        config['eps'] = self.eps\n        return config",
        "history": [],
        "output": "Return configurations of EpsGreedyQPolicy\n\n        # Returns\n            Dict of config",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def stdkey_home(self, shift, ctrl, prompt_pos=None):\r\n        \"\"\"Smart HOME feature: cursor is first moved at\r\n        indentation position, then at the start of the line\"\"\"\r\n        move_mode = self.__get_move_mode(shift)\r\n        if ctrl:\r\n            self.moveCursor(QTextCursor.Start, move_mode)\r\n        else:\r\n            cursor = self.textCursor()\r\n            if prompt_pos is None:\r\n                start_position = self.get_position('sol')\r\n            else:\r\n                start_position = self.get_position(prompt_pos)\r\n            text = self.get_text(start_position, 'eol')\r\n            indent_pos = start_position+len(text)-len(text.lstrip())\r\n            if cursor.position() != indent_pos:\r\n                cursor.setPosition(indent_pos, move_mode)\r\n            else:\r\n                cursor.setPosition(start_position, move_mode)\r\n            self.setTextCursor(cursor)",
        "history": [],
        "output": "Smart HOME feature: cursor is first moved at\r\n        indentation position, then at the start of the line",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def list_roots():\n    '''\n    Return all of the files names in all available environments\n    '''\n    ret = {}\n    for saltenv in __opts__['pillar_roots']:\n        ret[saltenv] = []\n        ret[saltenv].append(list_env(saltenv))\n    return ret",
        "history": [],
        "output": "Return all of the files names in all available environments",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _find_file(self, load):\n        '''\n        Convenience function for calls made using the RemoteClient\n        '''\n        path = load.get('path')\n        if not path:\n            return {'path': '',\n                    'rel': ''}\n        tgt_env = load.get('saltenv', 'base')\n        return self.find_file(path, tgt_env)",
        "history": [],
        "output": "Convenience function for calls made using the RemoteClient",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def export_for_training(self, file_path='./export.json'):\n        \"\"\"\n        Create a file from the database that can be used to\n        train other chat bots.\n        \"\"\"\n        import json\n        export = {'conversations': self._generate_export_data()}\n        with open(file_path, 'w+') as jsonfile:\n            json.dump(export, jsonfile, ensure_ascii=False)",
        "history": [],
        "output": "Create a file from the database that can be used to\n        train other chat bots.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _proc_sparse(self, tarfile):\n        \"\"\"Process a GNU sparse header plus extra headers.\n        \"\"\"\n        # We already collected some sparse structures in frombuf().\n        structs, isextended, origsize = self._sparse_structs\n        del self._sparse_structs\n\n        # Collect sparse structures from extended header blocks.\n        while isextended:\n            buf = tarfile.fileobj.read(BLOCKSIZE)\n            pos = 0\n            for i in range(21):\n                try:\n                    offset = nti(buf[pos:pos + 12])\n                    numbytes = nti(buf[pos + 12:pos + 24])\n                except ValueError:\n                    break\n                if offset and numbytes:\n                    structs.append((offset, numbytes))\n                pos += 24\n            isextended = bool(buf[504])\n        self.sparse = structs\n\n        self.offset_data = tarfile.fileobj.tell()\n        tarfile.offset = self.offset_data + self._block(self.size)\n        self.size = origsize\n        return self",
        "history": [],
        "output": "Process a GNU sparse header plus extra headers.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def df_metrics_to_num(self, df, query_object):\n        \"\"\"Converting metrics to numeric when pandas.read_sql cannot\"\"\"\n        metrics = [metric for metric in query_object.metrics]\n        for col, dtype in df.dtypes.items():\n            if dtype.type == np.object_ and col in metrics:\n                df[col] = pd.to_numeric(df[col], errors='coerce')",
        "history": [],
        "output": "Converting metrics to numeric when pandas.read_sql cannot",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_modules_map(self, path=None):\n        '''\n        Get installed Ansible modules\n        :return:\n        '''\n        paths = {}\n        root = ansible.modules.__path__[0]\n        if not path:\n            path = root\n        for p_el in os.listdir(path):\n            p_el_path = os.path.join(path, p_el)\n            if os.path.islink(p_el_path):\n                continue\n            if os.path.isdir(p_el_path):\n                paths.update(self._get_modules_map(p_el_path))\n            else:\n                if (any(p_el.startswith(elm) for elm in ['__', '.']) or\n                        not p_el.endswith('.py') or\n                        p_el in ansible.constants.IGNORE_FILES):\n                    continue\n                p_el_path = p_el_path.replace(root, '').split('.')[0]\n                als_name = p_el_path.replace('.', '').replace('/', '', 1).replace('/', '.')\n                paths[als_name] = p_el_path\n\n        return paths",
        "history": [],
        "output": "Get installed Ansible modules\n        :return:",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def apply(self, func, **kwargs):\n        \"\"\" apply the function to my values; return a block if we are not\n        one\n        \"\"\"\n        with np.errstate(all='ignore'):\n            result = func(self.values, **kwargs)\n        if not isinstance(result, Block):\n            result = self.make_block(values=_block_shape(result,\n                                                         ndim=self.ndim))\n\n        return result",
        "history": [],
        "output": "apply the function to my values; return a block if we are not\n        one",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def report_final_result(metric):\n    \"\"\"Reports final result to tuner.\n    metric: serializable object.\n    \"\"\"\n    assert _params is not None, 'nni.get_next_parameter() needs to be called before report_final_result'\n    metric = json_tricks.dumps({\n        'parameter_id': _params['parameter_id'],\n        'trial_job_id': trial_env_vars.NNI_TRIAL_JOB_ID,\n        'type': 'FINAL',\n        'sequence': 0,  # TODO: may be unnecessary\n        'value': metric\n    })\n    platform.send_metric(metric)",
        "history": [],
        "output": "Reports final result to tuner.\n    metric: serializable object.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_codes_for_values(values, categories):\n    \"\"\"\n    utility routine to turn values into codes given the specified categories\n    \"\"\"\n    from pandas.core.algorithms import _get_data_algo, _hashtables\n    dtype_equal = is_dtype_equal(values.dtype, categories.dtype)\n\n    if dtype_equal:\n        # To prevent erroneous dtype coercion in _get_data_algo, retrieve\n        # the underlying numpy array. gh-22702\n        values = getattr(values, '_ndarray_values', values)\n        categories = getattr(categories, '_ndarray_values', categories)\n    elif (is_extension_array_dtype(categories.dtype) and\n          is_object_dtype(values)):\n        # Support inferring the correct extension dtype from an array of\n        # scalar objects. e.g.\n        # Categorical(array[Period, Period], categories=PeriodIndex(...))\n        try:\n            values = (\n                categories.dtype.construct_array_type()._from_sequence(values)\n            )\n        except Exception:\n            # but that may fail for any reason, so fall back to object\n            values = ensure_object(values)\n            categories = ensure_object(categories)\n    else:\n        values = ensure_object(values)\n        categories = ensure_object(categories)\n\n    (hash_klass, vec_klass), vals = _get_data_algo(values, _hashtables)\n    (_, _), cats = _get_data_algo(categories, _hashtables)\n    t = hash_klass(len(cats))\n    t.map_locations(cats)\n    return coerce_indexer_dtype(t.lookup(vals), cats)",
        "history": [],
        "output": "utility routine to turn values into codes given the specified categories",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def bbox_transform(ex_rois, gt_rois, box_stds):\n    \"\"\"\n    compute bounding box regression targets from ex_rois to gt_rois\n    :param ex_rois: [N, 4]\n    :param gt_rois: [N, 4]\n    :return: [N, 4]\n    \"\"\"\n    assert ex_rois.shape[0] == gt_rois.shape[0], 'inconsistent rois number'\n\n    ex_widths = ex_rois[:, 2] - ex_rois[:, 0] + 1.0\n    ex_heights = ex_rois[:, 3] - ex_rois[:, 1] + 1.0\n    ex_ctr_x = ex_rois[:, 0] + 0.5 * (ex_widths - 1.0)\n    ex_ctr_y = ex_rois[:, 1] + 0.5 * (ex_heights - 1.0)\n\n    gt_widths = gt_rois[:, 2] - gt_rois[:, 0] + 1.0\n    gt_heights = gt_rois[:, 3] - gt_rois[:, 1] + 1.0\n    gt_ctr_x = gt_rois[:, 0] + 0.5 * (gt_widths - 1.0)\n    gt_ctr_y = gt_rois[:, 1] + 0.5 * (gt_heights - 1.0)\n\n    targets_dx = (gt_ctr_x - ex_ctr_x) / (ex_widths + 1e-14) / box_stds[0]\n    targets_dy = (gt_ctr_y - ex_ctr_y) / (ex_heights + 1e-14) / box_stds[1]\n    targets_dw = np.log(gt_widths / ex_widths) / box_stds[2]\n    targets_dh = np.log(gt_heights / ex_heights) / box_stds[3]\n\n    targets = np.vstack((targets_dx, targets_dy, targets_dw, targets_dh)).transpose()\n    return targets",
        "history": [],
        "output": "compute bounding box regression targets from ex_rois to gt_rois\n    :param ex_rois: [N, 4]\n    :param gt_rois: [N, 4]\n    :return: [N, 4]",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def license():\n    ''' Print the Bokeh license to the console.\n\n    Returns:\n        None\n\n    '''\n    from os.path import join\n    with open(join(__path__[0], 'LICENSE.txt')) as lic:\n        print(lic.read())",
        "history": [],
        "output": "Print the Bokeh license to the console.\n\n    Returns:\n        None",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def parse_timestamp(timestamp):\n    \"\"\"Parse ISO8601 timestamps given by github API.\"\"\"\n    dt = dateutil.parser.parse(timestamp)\n    return dt.astimezone(dateutil.tz.tzutc())",
        "history": [],
        "output": "Parse ISO8601 timestamps given by github API.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _default_hparams():\n  \"\"\"A set of basic model hyperparameters.\"\"\"\n  return hparam.HParams(\n      # Use this parameter to get comparable perplexity numbers with different\n      # tokenizations.  This value should be set to the ratio of the number of\n      # tokens in the test set according to the tokenization used to the number\n      # of tokens in the test set in the \"official\" tokenization.  For\n      # example, if we are using a word-piece based model and we want to\n      # compute per-word perplexity, then we set loss_multiplier to the number\n      # of wordpieces per word in the test set.\n      loss_multiplier=1.0,\n\n      # Use this parameter to allow for larger sequences in the batch. Without\n      # the use of this parameter, the size of the inner two dimensions will\n      # be used to judge the sequence length.\n      batch_size_multiplier=1,\n\n      # During inference for autoregressive problems, if the batch_size is 1,\n      # the inference will stop when the model predict a text_encoder.EOS_ID\n      # token.\n      stop_at_eos=False,\n\n      # Modalities used to map from features to a space compatible with\n      # chosen model architecture. It comprises key-value pairs of a feature\n      # name (str) and its modality type.\n      modality={},\n      vocab_size={},\n\n      # Identifiers used to tell the model which input/target space will be\n      # expected. For example, it can tell that we expect French as characters\n      # as output, or Spanish as sound. Spaces defined as constants in SpaceID\n      # class.\n      input_space_id=SpaceID.GENERIC,\n      target_space_id=SpaceID.GENERIC)",
        "history": [],
        "output": "A set of basic model hyperparameters.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def setup_gui(self):\n        \"\"\"Setup the main layout of the widget.\"\"\"\n        layout = QGridLayout(self)\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.addWidget(self.canvas, 0, 1)\n        layout.addLayout(self.setup_toolbar(), 0, 3, 2, 1)\n\n        layout.setColumnStretch(0, 100)\n        layout.setColumnStretch(2, 100)\n        layout.setRowStretch(1, 100)",
        "history": [],
        "output": "Setup the main layout of the widget.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _generate_faux_mime_message(parser, response):\n    \"\"\"Convert response, content -> (multipart) email.message.\n\n    Helper for _unpack_batch_response.\n    \"\"\"\n    # We coerce to bytes to get consistent concat across\n    # Py2 and Py3. Percent formatting is insufficient since\n    # it includes the b in Py3.\n    content_type = _helpers._to_bytes(response.headers.get(\"content-type\", \"\"))\n\n    faux_message = b\"\".join(\n        [b\"Content-Type: \", content_type, b\"\\nMIME-Version: 1.0\\n\\n\", response.content]\n    )\n\n    if six.PY2:\n        return parser.parsestr(faux_message)\n    else:  # pragma: NO COVER  Python3\n        return parser.parsestr(faux_message.decode(\"utf-8\"))",
        "history": [],
        "output": "Convert response, content -> (multipart) email.message.\n\n    Helper for _unpack_batch_response.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def ctxtReadFile(self, filename, encoding, options):\n        \"\"\"parse an XML file from the filesystem or the network. This\n           reuses the existing @ctxt parser context \"\"\"\n        ret = libxml2mod.xmlCtxtReadFile(self._o, filename, encoding, options)\n        if ret is None:raise treeError('xmlCtxtReadFile() failed')\n        __tmp = xmlDoc(_obj=ret)\n        return __tmp",
        "history": [],
        "output": "parse an XML file from the filesystem or the network. This\n           reuses the existing @ctxt parser context",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _merge_multi_context(outputs, major_axis):\n    \"\"\"Merge outputs that lives on multiple context into one, so that they look\n    like living on one context.\n    \"\"\"\n    rets = []\n    for tensors, axis in zip(outputs, major_axis):\n        if axis >= 0:\n            # pylint: disable=no-member,protected-access\n            if len(tensors) == 1:\n                rets.append(tensors[0])\n            else:\n                # Concatenate if necessary\n                rets.append(nd.concat(*[tensor.as_in_context(tensors[0].context)\n                                        for tensor in tensors],\n                                      dim=axis))\n            # pylint: enable=no-member,protected-access\n        else:\n            # negative axis means the there is no batch_size axis, and all the\n            # results should be the same on each device. We simply take the\n            # first one, without checking they are actually the same\n            rets.append(tensors[0])\n    return rets",
        "history": [],
        "output": "Merge outputs that lives on multiple context into one, so that they look\n    like living on one context.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def urldefragauth(url):\n    \"\"\"\n    Given a url remove the fragment and the authentication part.\n\n    :rtype: str\n    \"\"\"\n    scheme, netloc, path, params, query, fragment = urlparse(url)\n\n    # see func:`prepend_scheme_if_needed`\n    if not netloc:\n        netloc, path = path, netloc\n\n    netloc = netloc.rsplit('@', 1)[-1]\n\n    return urlunparse((scheme, netloc, path, params, query, ''))",
        "history": [],
        "output": "Given a url remove the fragment and the authentication part.\n\n    :rtype: str",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def put_blob(storage_conn=None, **kwargs):\n    '''\n    .. versionadded:: 2015.8.0\n\n    Upload a blob\n    '''\n    if not storage_conn:\n        storage_conn = get_storage_conn(opts=kwargs)\n\n    if 'container' not in kwargs:\n        raise SaltSystemExit(code=42, msg='The blob container name must be specified as \"container\"')\n\n    if 'name' not in kwargs:\n        raise SaltSystemExit(code=42, msg='The blob name must be specified as \"name\"')\n\n    if 'blob_path' not in kwargs and 'blob_content' not in kwargs:\n        raise SaltSystemExit(\n            code=42,\n            msg='Either a path to a file needs to be passed in as \"blob_path\" '\n            'or the contents of a blob as \"blob_content.\"'\n        )\n\n    blob_kwargs = {\n        'container_name': kwargs['container'],\n        'blob_name': kwargs['name'],\n        'cache_control': kwargs.get('cache_control', None),\n        'content_language': kwargs.get('content_language', None),\n        'content_md5': kwargs.get('content_md5', None),\n        'x_ms_blob_content_type': kwargs.get('blob_content_type', None),\n        'x_ms_blob_content_encoding': kwargs.get('blob_content_encoding', None),\n        'x_ms_blob_content_language': kwargs.get('blob_content_language', None),\n        'x_ms_blob_content_md5': kwargs.get('blob_content_md5', None),\n        'x_ms_blob_cache_control': kwargs.get('blob_cache_control', None),\n        'x_ms_meta_name_values': kwargs.get('meta_name_values', None),\n        'x_ms_lease_id': kwargs.get('lease_id', None),\n    }\n    if 'blob_path' in kwargs:\n        data = storage_conn.put_block_blob_from_path(\n            file_path=kwargs['blob_path'],\n            **blob_kwargs\n        )\n    elif 'blob_content' in kwargs:\n        data = storage_conn.put_block_blob_from_bytes(\n            blob=kwargs['blob_content'],\n            **blob_kwargs\n        )\n\n    return data",
        "history": [],
        "output": ".. versionadded:: 2015.8.0\n\n    Upload a blob",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def fetcher_loop_v1(data_queue, data_buffer, pin_memory=False,\n                    pin_device_id=0, data_buffer_lock=None):\n    \"\"\"Fetcher loop for fetching data from queue and put in reorder dict.\"\"\"\n    while True:\n        idx, batch = data_queue.get()\n        if idx is None:\n            break\n        if pin_memory:\n            batch = _as_in_context(batch, context.cpu_pinned(pin_device_id))\n        else:\n            batch = _as_in_context(batch, context.cpu())\n        if data_buffer_lock is not None:\n            with data_buffer_lock:\n                data_buffer[idx] = batch\n        else:\n            data_buffer[idx] = batch",
        "history": [],
        "output": "Fetcher loop for fetching data from queue and put in reorder dict.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _current_state(self):\n        \"\"\"\n        :returns: a gray-scale (h, w) uint8 image\n        \"\"\"\n        ret = self._grab_raw_image()\n        # max-pooled over the last screen\n        ret = np.maximum(ret, self.last_raw_screen)\n        if self.viz:\n            if isinstance(self.viz, float):\n                cv2.imshow(self.windowname, ret)\n                cv2.waitKey(int(self.viz * 1000))\n        ret = ret.astype('float32')\n        # 0.299,0.587.0.114. same as rgb2y in torch/image\n        ret = cv2.cvtColor(ret, cv2.COLOR_RGB2GRAY)[:, :]\n        return ret.astype('uint8')",
        "history": [],
        "output": ":returns: a gray-scale (h, w) uint8 image",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def encoded(self):\n        \"\"\"\n        A zipped, base64 encoded string of profile directory\n        for use with remote WebDriver JSON wire protocol\n        \"\"\"\n        self.update_preferences()\n        fp = BytesIO()\n        zipped = zipfile.ZipFile(fp, 'w', zipfile.ZIP_DEFLATED)\n        path_root = len(self.path) + 1  # account for trailing slash\n        for base, dirs, files in os.walk(self.path):\n            for fyle in files:\n                filename = os.path.join(base, fyle)\n                zipped.write(filename, filename[path_root:])\n        zipped.close()\n        return base64.b64encode(fp.getvalue()).decode('UTF-8')",
        "history": [],
        "output": "A zipped, base64 encoded string of profile directory\n        for use with remote WebDriver JSON wire protocol",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def token(self, adata, load):\n        '''\n        Determine if token auth is valid and yield the adata\n        '''\n        try:\n            token = self.loadauth.get_tok(load['token'])\n        except Exception as exc:\n            log.error('Exception occurred when generating auth token: %s', exc)\n            yield {}\n        if not token:\n            log.warning('Authentication failure of type \"token\" occurred.')\n            yield {}\n        for sub_auth in adata:\n            for sub_adata in adata:\n                if token['eauth'] not in adata:\n                    continue\n            if not ((token['name'] in adata[token['eauth']]) |\n                    ('*' in adata[token['eauth']])):\n                continue\n            yield {'sub_auth': sub_auth, 'token': token}\n        yield {}",
        "history": [],
        "output": "Determine if token auth is valid and yield the adata",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def step(self, metrics):\n        \"\"\" EarlyStopping step on each epoch\n        Arguments:\n            metrics {float} -- metric value\n        \"\"\"\n\n        if self.best is None:\n            self.best = metrics\n            return False\n\n        if np.isnan(metrics):\n            return True\n\n        if self.is_better(metrics, self.best):\n            self.num_bad_epochs = 0\n            self.best = metrics\n        else:\n            self.num_bad_epochs += 1\n\n        if self.num_bad_epochs >= self.patience:\n            return True\n\n        return False",
        "history": [],
        "output": "EarlyStopping step on each epoch\n        Arguments:\n            metrics {float} -- metric value",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _minion_event(self, load):\n        '''\n        Receive an event from the minion and fire it on the master event\n        interface\n        '''\n        if 'id' not in load:\n            return False\n        if 'events' not in load and ('tag' not in load or 'data' not in load):\n            return False\n        if 'events' in load:\n            for event in load['events']:\n                if 'data' in event:\n                    event_data = event['data']\n                else:\n                    event_data = event\n                self.event.fire_event(event_data, event['tag'])  # old dup event\n                if load.get('pretag') is not None:\n                    self.event.fire_event(event_data, salt.utils.event.tagify(event['tag'], base=load['pretag']))\n        else:\n            tag = load['tag']\n            self.event.fire_event(load, tag)\n        return True",
        "history": [],
        "output": "Receive an event from the minion and fire it on the master event\n        interface",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def forward(self, is_train=False):\n        \"\"\"Perform a forward pass on each executor.\"\"\"\n        for texec in self.train_execs:\n            texec.forward(is_train=is_train)",
        "history": [],
        "output": "Perform a forward pass on each executor.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _reverse_problem_hparams(p_hparams):\n  \"\"\"Swap input/output modalities, vocab, and space ids.\"\"\"\n  p = p_hparams\n\n  # Swap modalities.\n  # TODO(trandustin): Note this assumes target modalities have feature name\n  # 'target', and each intended feature to swap has feature name 'input'.\n  # In the future, remove need for this behavior.\n  reversed_modality = {}\n  for feature_name in p.modality:\n    reversed_feature_name = feature_name.replace(\"target\", \"input\")\n    if \"target\" in feature_name and reversed_feature_name in p.modality:\n      reversed_modality[feature_name] = p.modality[reversed_feature_name]\n      reversed_modality[reversed_feature_name] = p.modality[feature_name]\n    else:\n      reversed_modality[feature_name] = p.modality[feature_name]\n\n  p.modality = reversed_modality\n\n  # Swap vocab sizes.\n  reversed_vocab_size = {}\n  for feature_name in p.vocab_size:\n    reversed_feature_name = feature_name.replace(\"target\", \"input\")\n    if \"target\" in feature_name and reversed_feature_name in p.vocab_size:\n      reversed_vocab_size[feature_name] = p.vocab_size[reversed_feature_name]\n      reversed_vocab_size[reversed_feature_name] = p.vocab_size[feature_name]\n    else:\n      reversed_vocab_size[feature_name] = p.vocab_size[feature_name]\n\n  p.vocab_size = reversed_vocab_size\n\n  # Swap vocabularies.\n  input_vocabulary = p.vocabulary.pop(\"inputs\", None)\n  target_vocabulary = p.vocabulary.pop(\"targets\", None)\n  if input_vocabulary is not None:\n    p.vocabulary[\"targets\"] = input_vocabulary\n  if target_vocabulary is not None:\n    p.vocabulary[\"inputs\"] = target_vocabulary\n\n  # Swap input/target space ids.\n  input_space_id = p.input_space_id\n  target_space_id = p.target_space_id\n  if input_space_id is not None:\n    p.target_space_id = input_space_id\n  else:\n    p.target_space_id = SpaceID.GENERIC\n  if target_space_id is not None:\n    p.input_space_id = target_space_id\n  else:\n    p.input_space_id = SpaceID.GENERIC\n\n  # Mark that p was reversed.\n  p.was_reversed = True",
        "history": [],
        "output": "Swap input/output modalities, vocab, and space ids.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def preprocess(self, img):\n        \"\"\"\n        Preprocess a 210x160x3 uint8 frame into a 6400 (80x80) (1 x input_size)\n        float vector.\n        \"\"\"\n        # Crop, down-sample, erase background and set foreground to 1.\n        # See https://gist.github.com/karpathy/a4166c7fe253700972fcbc77e4ea32c5\n        img = img[35:195]\n        img = img[::2, ::2, 0]\n        img[img == 144] = 0\n        img[img == 109] = 0\n        img[img != 0] = 1\n        curr = np.expand_dims(img.astype(np.float).ravel(), axis=0)\n        # Subtract the last preprocessed image.\n        diff = (curr - self.prev if self.prev is not None\n                else np.zeros((1, curr.shape[1])))\n        self.prev = curr\n        return diff",
        "history": [],
        "output": "Preprocess a 210x160x3 uint8 frame into a 6400 (80x80) (1 x input_size)\n        float vector.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def generate_data(self, data_dir, tmp_dir, task_id=-1):\n    \"\"\"The function generating the data.\"\"\"\n    filepath_fns = {\n        problem.DatasetSplit.TRAIN: self.training_filepaths,\n        problem.DatasetSplit.EVAL: self.dev_filepaths,\n        problem.DatasetSplit.TEST: self.test_filepaths,\n    }\n\n    # We set shuffled=True as we don't want to shuffle on disk later.\n    split_paths = [(split[\"split\"], filepath_fns[split[\"split\"]](\n        data_dir, split[\"shards\"], shuffled=True))\n                   for split in self.dataset_splits]\n    all_paths = []\n    for _, paths in split_paths:\n      all_paths.extend(paths)\n\n    if self.is_generate_per_split:\n      for split, paths in split_paths:\n        generator_utils.generate_files(\n            self.generate_encoded_samples(data_dir, tmp_dir, split),\n            paths,\n            cycle_every_n=self.total_number_of_frames // len(paths))\n    else:\n      generator_utils.generate_files(\n          self.generate_encoded_samples(data_dir, tmp_dir,\n                                        problem.DatasetSplit.TRAIN),\n          all_paths,\n          cycle_every_n=self.total_number_of_frames // len(all_paths))",
        "history": [],
        "output": "The function generating the data.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def load_data():\n    '''Load dataset, use boston dataset'''\n    boston = load_boston()\n    X_train, X_test, y_train, y_test = train_test_split(boston.data, boston.target, random_state=99, test_size=0.25)\n    #normalize data\n    ss_X = StandardScaler()\n    ss_y = StandardScaler()\n\n    X_train = ss_X.fit_transform(X_train)\n    X_test = ss_X.transform(X_test)\n    y_train = ss_y.fit_transform(y_train[:, None])[:,0]\n    y_test = ss_y.transform(y_test[:, None])[:,0]\n\n    return X_train, X_test, y_train, y_test",
        "history": [],
        "output": "Load dataset, use boston dataset",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _refresh_and_update(self):\n        \"\"\"Refresh the operation and update the result if needed.\"\"\"\n        # If the currently cached operation is done, no need to make another\n        # RPC as it will not change once done.\n        if not self._operation.done:\n            self._operation = self._refresh()\n            self._set_result_from_operation()",
        "history": [],
        "output": "Refresh the operation and update the result if needed.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_path(self, n):\n        \"\"\" Choose one directory for spill by number n \"\"\"\n        d = self.local_dirs[n % len(self.local_dirs)]\n        if not os.path.exists(d):\n            os.makedirs(d)\n        return os.path.join(d, str(n))",
        "history": [],
        "output": "Choose one directory for spill by number n",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def do_cli(ctx, function_identifier, template, event, no_event, env_vars, debug_port,  # pylint: disable=R0914\n           debug_args, debugger_path, docker_volume_basedir, docker_network, log_file, layer_cache_basedir,\n           skip_pull_image, force_image_build, parameter_overrides):\n    \"\"\"\n    Implementation of the ``cli`` method, just separated out for unit testing purposes\n    \"\"\"\n\n    LOG.debug(\"local invoke command is called\")\n\n    if no_event and event != STDIN_FILE_NAME:\n        # Do not know what the user wants. no_event and event both passed in.\n        raise UserException(\"no_event and event cannot be used together. Please provide only one.\")\n\n    if no_event:\n        event_data = \"{}\"\n    else:\n        event_data = _get_event(event)\n\n    # Pass all inputs to setup necessary context to invoke function locally.\n    # Handler exception raised by the processor for invalid args and print errors\n    try:\n        with InvokeContext(template_file=template,\n                           function_identifier=function_identifier,\n                           env_vars_file=env_vars,\n                           docker_volume_basedir=docker_volume_basedir,\n                           docker_network=docker_network,\n                           log_file=log_file,\n                           skip_pull_image=skip_pull_image,\n                           debug_port=debug_port,\n                           debug_args=debug_args,\n                           debugger_path=debugger_path,\n                           parameter_overrides=parameter_overrides,\n                           layer_cache_basedir=layer_cache_basedir,\n                           force_image_build=force_image_build,\n                           aws_region=ctx.region) as context:\n\n            # Invoke the function\n            context.local_lambda_runner.invoke(context.function_name,\n                                               event=event_data,\n                                               stdout=context.stdout,\n                                               stderr=context.stderr)\n\n    except FunctionNotFound:\n        raise UserException(\"Function {} not found in template\".format(function_identifier))\n    except (InvalidSamDocumentException,\n            OverridesNotWellDefinedError,\n            InvalidLayerReference,\n            DebuggingNotSupported) as ex:\n        raise UserException(str(ex))\n    except DockerImagePullFailedException as ex:\n        raise UserException(str(ex))",
        "history": [],
        "output": "Implementation of the ``cli`` method, just separated out for unit testing purposes",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def open(self, fnames=None):\r\n        \"\"\"Open files with the appropriate application\"\"\"\r\n        if fnames is None:\r\n            fnames = self.get_selected_filenames()\r\n        for fname in fnames:\r\n            if osp.isfile(fname) and encoding.is_text_file(fname):\r\n                self.parent_widget.sig_open_file.emit(fname)\r\n            else:\r\n                self.open_outside_spyder([fname])",
        "history": [],
        "output": "Open files with the appropriate application",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_conn(key=None,\n              keyid=None,\n              profile=None,\n              region=None,\n              **kwargs):\n    '''\n    Create a boto3 client connection to EFS\n    '''\n    client = None\n    if profile:\n        if isinstance(profile, six.string_types):\n            if profile in __pillar__:\n                profile = __pillar__[profile]\n            elif profile in __opts__:\n                profile = __opts__[profile]\n    elif key or keyid or region:\n        profile = {}\n        if key:\n            profile['key'] = key\n        if keyid:\n            profile['keyid'] = keyid\n        if region:\n            profile['region'] = region\n\n    if isinstance(profile, dict):\n        if 'region' in profile:\n            profile['region_name'] = profile['region']\n            profile.pop('region', None)\n        if 'key' in profile:\n            profile['aws_secret_access_key'] = profile['key']\n            profile.pop('key', None)\n        if 'keyid' in profile:\n            profile['aws_access_key_id'] = profile['keyid']\n            profile.pop('keyid', None)\n\n        client = boto3.client('efs', **profile)\n    else:\n        client = boto3.client('efs')\n\n    return client",
        "history": [],
        "output": "Create a boto3 client connection to EFS",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def removeRef(self, attr):\n        \"\"\"Remove the given attribute from the Ref table maintained\n           internally. \"\"\"\n        if attr is None: attr__o = None\n        else: attr__o = attr._o\n        ret = libxml2mod.xmlRemoveRef(self._o, attr__o)\n        return ret",
        "history": [],
        "output": "Remove the given attribute from the Ref table maintained\n           internally.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def element_from_span(span: List[int],\n                      span_type: str) -> Element:\n    \"\"\"\n    Return an Element from span (list of spacy toks)\n    \"\"\"\n    return Element(span_type,\n                   [span[0].idx,\n                    span[-1].idx + len(span[-1])],\n                   ' '.join(map(str, span)))",
        "history": [],
        "output": "Return an Element from span (list of spacy toks)",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def median(self, **kwargs):\n        \"\"\"\n        Compute median of groups, excluding missing values.\n\n        For multiple groupings, the result index will be a MultiIndex\n        \"\"\"\n        try:\n            return self._cython_agg_general('median', **kwargs)\n        except GroupByError:\n            raise\n        except Exception:  # pragma: no cover\n\n            def f(x):\n                if isinstance(x, np.ndarray):\n                    x = Series(x)\n                return x.median(axis=self.axis, **kwargs)\n            with _group_selection_context(self):\n                return self._python_agg_general(f)",
        "history": [],
        "output": "Compute median of groups, excluding missing values.\n\n        For multiple groupings, the result index will be a MultiIndex",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def estimate_density(DATA_PATH, feature_size):\n    \"\"\"sample 10 times of a size of 1000 for estimating the density of the sparse dataset\"\"\"\n    if not os.path.exists(DATA_PATH):\n        raise Exception(\"Data is not there!\")\n    density = []\n    P = 0.01\n    for _ in range(10):\n        num_non_zero = 0\n        num_sample = 0\n        with open(DATA_PATH) as f:\n            for line in f:\n                if (random.random() < P):\n                    num_non_zero += len(line.split(\" \")) - 1\n                    num_sample += 1\n        density.append(num_non_zero * 1.0 / (feature_size * num_sample))\n    return sum(density) / len(density)",
        "history": [],
        "output": "sample 10 times of a size of 1000 for estimating the density of the sparse dataset",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def from_df(cls, ratings:DataFrame, valid_pct:float=0.2, user_name:Optional[str]=None, item_name:Optional[str]=None,\n                rating_name:Optional[str]=None, test:DataFrame=None, seed:int=None, path:PathOrStr='.', bs:int=64, \n                val_bs:int=None, num_workers:int=defaults.cpus, dl_tfms:Optional[Collection[Callable]]=None, \n                device:torch.device=None, collate_fn:Callable=data_collate, no_check:bool=False) -> 'CollabDataBunch':\n        \"Create a `DataBunch` suitable for collaborative filtering from `ratings`.\"\n        user_name   = ifnone(user_name,  ratings.columns[0])\n        item_name   = ifnone(item_name,  ratings.columns[1])\n        rating_name = ifnone(rating_name,ratings.columns[2])\n        cat_names = [user_name,item_name]\n        src = (CollabList.from_df(ratings, cat_names=cat_names, procs=Categorify)\n               .split_by_rand_pct(valid_pct=valid_pct, seed=seed).label_from_df(cols=rating_name))\n        if test is not None: src.add_test(CollabList.from_df(test, cat_names=cat_names))\n        return src.databunch(path=path, bs=bs, val_bs=val_bs, num_workers=num_workers, device=device, \n                             collate_fn=collate_fn, no_check=no_check)",
        "history": [],
        "output": "Create a `DataBunch` suitable for collaborative filtering from `ratings`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def read(cls, f):\n    \"\"\"Read WETRecord from file. Records end with 2 blank lines.\"\"\"\n    header = WETHeader.read(f)\n    if header is None:\n      # EOF\n      return None\n    content = f.read(header.length)\n\n    # Consume empty separators\n    f.readline()\n    f.readline()\n\n    return cls(header.url, content)",
        "history": [],
        "output": "Read WETRecord from file. Records end with 2 blank lines.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def vm_info(name, quiet=False):\n    '''\n    Return the information on the named VM\n    '''\n    data = query(quiet=True)\n    return _find_vm(name, data, quiet)",
        "history": [],
        "output": "Return the information on the named VM",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def __setup_fileserver(self):\n        '''\n        Set the local file objects from the file server interface\n        '''\n        fs_ = salt.fileserver.Fileserver(self.opts)\n        self._serve_file = fs_.serve_file\n        self._file_find = fs_._find_file\n        self._file_hash = fs_.file_hash\n        self._file_list = fs_.file_list\n        self._file_list_emptydirs = fs_.file_list_emptydirs\n        self._dir_list = fs_.dir_list\n        self._symlink_list = fs_.symlink_list\n        self._file_envs = fs_.envs",
        "history": [],
        "output": "Set the local file objects from the file server interface",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def remove_sshkey(host, known_hosts=None):\n    '''\n    Remove a host from the known_hosts file\n    '''\n    if known_hosts is None:\n        if 'HOME' in os.environ:\n            known_hosts = '{0}/.ssh/known_hosts'.format(os.environ['HOME'])\n        else:\n            try:\n                known_hosts = '{0}/.ssh/known_hosts'.format(\n                    pwd.getpwuid(os.getuid()).pwd_dir\n                )\n            except Exception:\n                pass\n\n    if known_hosts is not None:\n        log.debug(\n            'Removing ssh key for %s from known hosts file %s',\n            host, known_hosts\n        )\n    else:\n        log.debug('Removing ssh key for %s from known hosts file', host)\n\n    cmd = 'ssh-keygen -R {0}'.format(host)\n    subprocess.call(cmd, shell=True)",
        "history": [],
        "output": "Remove a host from the known_hosts file",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def __prep_mod_opts(self, opts):\n        '''\n        Strip out of the opts any logger instance\n        '''\n        if '__grains__' not in self.pack:\n            grains = opts.get('grains', {})\n\n            if isinstance(grains, ThreadLocalProxy):\n                grains = ThreadLocalProxy.unproxy(grains)\n\n            self.context_dict['grains'] = grains\n            self.pack['__grains__'] = salt.utils.context.NamespacedDictWrapper(self.context_dict, 'grains')\n\n        if '__pillar__' not in self.pack:\n            pillar = opts.get('pillar', {})\n\n            if isinstance(pillar, ThreadLocalProxy):\n                pillar = ThreadLocalProxy.unproxy(pillar)\n\n            self.context_dict['pillar'] = pillar\n            self.pack['__pillar__'] = salt.utils.context.NamespacedDictWrapper(self.context_dict, 'pillar')\n\n        mod_opts = {}\n        for key, val in list(opts.items()):\n            if key == 'logger':\n                continue\n            mod_opts[key] = val\n        return mod_opts",
        "history": [],
        "output": "Strip out of the opts any logger instance",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def show_instance(name, call=None):\n    '''\n    Show the details from the provider concerning an instance\n    '''\n    if call != 'action':\n        raise SaltCloudSystemExit(\n            'The show_instance action must be called with -a or --action.'\n        )\n\n    nodes = list_nodes_full()\n    # Find under which cloud service the name is listed, if any\n    if name not in nodes:\n        return {}\n    __utils__['cloud.cache_node'](nodes[name], __active_provider_name__, __opts__)\n    return nodes[name]",
        "history": [],
        "output": "Show the details from the provider concerning an instance",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def ret_glob_minions(self):\n        '''\n        Return minions that match via glob\n        '''\n        fnfilter = functools.partial(fnmatch.filter, pat=self.tgt)\n        return self._ret_minions(fnfilter)",
        "history": [],
        "output": "Return minions that match via glob",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def finish(self) -> None:\n        \"\"\"Implements `.HTTPConnection.finish`.\"\"\"\n        if (\n            self._expected_content_remaining is not None\n            and self._expected_content_remaining != 0\n            and not self.stream.closed()\n        ):\n            self.stream.close()\n            raise httputil.HTTPOutputError(\n                \"Tried to write %d bytes less than Content-Length\"\n                % self._expected_content_remaining\n            )\n        if self._chunking_output:\n            if not self.stream.closed():\n                self._pending_write = self.stream.write(b\"0\\r\\n\\r\\n\")\n                self._pending_write.add_done_callback(self._on_write_complete)\n        self._write_finished = True\n        # If the app finished the request while we're still reading,\n        # divert any remaining data away from the delegate and\n        # close the connection when we're done sending our response.\n        # Closing the connection is the only way to avoid reading the\n        # whole input body.\n        if not self._read_finished:\n            self._disconnect_on_finish = True\n        # No more data is coming, so instruct TCP to send any remaining\n        # data immediately instead of waiting for a full packet or ack.\n        self.stream.set_nodelay(True)\n        if self._pending_write is None:\n            self._finish_request(None)\n        else:\n            future_add_done_callback(self._pending_write, self._finish_request)",
        "history": [],
        "output": "Implements `.HTTPConnection.finish`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _find_element(driver, by):\n    \"\"\"Looks up an element. Logs and re-raises ``WebDriverException``\n    if thrown.\"\"\"\n    try:\n        return driver.find_element(*by)\n    except NoSuchElementException as e:\n        raise e\n    except WebDriverException as e:\n        raise e",
        "history": [],
        "output": "Looks up an element. Logs and re-raises ``WebDriverException``\n    if thrown.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _write_to_datastore(self):\n    \"\"\"Writes all submissions to datastore.\"\"\"\n    # Populate datastore\n    roots_and_submissions = zip([ATTACKS_ENTITY_KEY,\n                                 TARGET_ATTACKS_ENTITY_KEY,\n                                 DEFENSES_ENTITY_KEY],\n                                [self._attacks,\n                                 self._targeted_attacks,\n                                 self._defenses])\n    client = self._datastore_client\n    with client.no_transact_batch() as batch:\n      for root_key, submissions in roots_and_submissions:\n        batch.put(client.entity(client.key(*root_key)))\n        for k, v in iteritems(submissions):\n          entity = client.entity(client.key(\n              *(root_key + [KIND_SUBMISSION, k])))\n          entity['submission_path'] = v.path\n          entity.update(participant_from_submission_path(v.path))\n          batch.put(entity)",
        "history": [],
        "output": "Writes all submissions to datastore.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def parse_helper(attrs, attrs_name, alt_value=None):\n    \"\"\"Helper function to parse operator attributes in required format.\"\"\"\n    tuple_re = re.compile('\\([0-9L|,| ]+\\)')\n    if not attrs:\n        return alt_value\n    attrs_str = None if attrs.get(attrs_name) is None else str(attrs.get(attrs_name))\n    if attrs_str is None:\n        return alt_value\n    attrs_match = tuple_re.search(attrs_str)\n    if attrs_match is not None:\n        if attrs_match.span() == (0, len(attrs_str)):\n            dims = eval(attrs_str)\n            return dims\n        else:\n            raise AttributeError(\"Malformed %s dimensions: %s\" % (attrs_name, str(attrs_str)))\n    return alt_value",
        "history": [],
        "output": "Helper function to parse operator attributes in required format.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def reward(self):\n    \"\"\"Returns a tuple of sum of raw and processed rewards.\"\"\"\n    raw_rewards, processed_rewards = 0, 0\n    for ts in self.time_steps:\n      # NOTE: raw_reward and processed_reward are None for the first time-step.\n      if ts.raw_reward is not None:\n        raw_rewards += ts.raw_reward\n      if ts.processed_reward is not None:\n        processed_rewards += ts.processed_reward\n    return raw_rewards, processed_rewards",
        "history": [],
        "output": "Returns a tuple of sum of raw and processed rewards.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def getObjectTypeBit(self, t):\n        '''\n        returns the bit value of the string object type\n        '''\n        if isinstance(t, string_types):\n            t = t.upper()\n            try:\n                return self.objectType[t]\n            except KeyError:\n                raise CommandExecutionError((\n                    'Invalid object type \"{0}\".  It should be one of the following:  {1}'\n                    ).format(t, ', '.join(self.objectType)))\n        else:\n            return t",
        "history": [],
        "output": "returns the bit value of the string object type",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _create_doc(self):\n        '''\n        Create document.\n\n        :return:\n        '''\n        root = etree.Element('image')\n        root.set('schemaversion', '6.3')\n        root.set('name', self.name)\n\n        return root",
        "history": [],
        "output": "Create document.\n\n        :return:",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _is_whitespace(self, char):\n        \"\"\"Checks whether `chars` is a whitespace character.\"\"\"\n        # \\t, \\n, and \\r are technically contorl characters but we treat them\n        # as whitespace since they are generally considered as such.\n        if char in [' ', '\\t', '\\n', '\\r']:\n            return True\n        cat = unicodedata.category(char)\n        if cat == 'Zs':\n            return True\n        return False",
        "history": [],
        "output": "Checks whether `chars` is a whitespace character.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def extract_from_urllib3():\n    \"\"\"\n    Undo monkey-patching by :func:`inject_into_urllib3`.\n    \"\"\"\n    util.ssl_.SSLContext = orig_util_SSLContext\n    util.HAS_SNI = orig_util_HAS_SNI\n    util.ssl_.HAS_SNI = orig_util_HAS_SNI\n    util.IS_SECURETRANSPORT = False\n    util.ssl_.IS_SECURETRANSPORT = False",
        "history": [],
        "output": "Undo monkey-patching by :func:`inject_into_urllib3`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_image_tensors(self)->([Tensor], [Tensor], [Tensor]):\n        \"Gets list of image tensors from lists of Image objects, as a tuple of original, generated and real(target) images.\"\n        orig_images, gen_images, real_images = [], [], []\n        for image_set in self.image_sets:\n            orig_images.append(image_set.orig.px)\n            gen_images.append(image_set.gen.px)\n            real_images.append(image_set.real.px) \n        return orig_images, gen_images, real_images",
        "history": [],
        "output": "Gets list of image tensors from lists of Image objects, as a tuple of original, generated and real(target) images.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_nni_installation_path():\n    ''' Find nni lib from the following locations in order\n    Return nni root directory if it exists\n    '''\n    def try_installation_path_sequentially(*sitepackages):\n        '''Try different installation path sequentially util nni is found.\n        Return None if nothing is found\n        '''\n        def _generate_installation_path(sitepackages_path):\n            python_dir = get_python_dir(sitepackages_path)\n            entry_file = os.path.join(python_dir, 'nni', 'main.js')\n            if os.path.isfile(entry_file):\n                return python_dir\n            return None\n\n        for sitepackage in sitepackages:\n            python_dir = _generate_installation_path(sitepackage)\n            if python_dir:\n                return python_dir\n        return None\n\n    if os.getenv('VIRTUAL_ENV'):\n        # if 'virtualenv' package is used, `site` has not attr getsitepackages, so we will instead use VIRTUAL_ENV\n        # Note that conda venv will not have VIRTUAL_ENV\n        python_dir = os.getenv('VIRTUAL_ENV')\n    else:\n        python_sitepackage = site.getsitepackages()[0]\n        # If system-wide python is used, we will give priority to using `local sitepackage`--\"usersitepackages()\" given that nni exists there\n        if python_sitepackage.startswith('/usr') or python_sitepackage.startswith('/Library'):\n            python_dir = try_installation_path_sequentially(site.getusersitepackages(), site.getsitepackages()[0])\n        else:\n            python_dir = try_installation_path_sequentially(site.getsitepackages()[0], site.getusersitepackages())\n\n    if python_dir:\n        entry_file = os.path.join(python_dir, 'nni', 'main.js')\n        if os.path.isfile(entry_file):\n            return os.path.join(python_dir, 'nni')\n    print_error('Fail to find nni under python library')\n    exit(1)",
        "history": [],
        "output": "Find nni lib from the following locations in order\n    Return nni root directory if it exists",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def make_empty(self, axes=None):\n        \"\"\" return an empty BlockManager with the items axis of len 0 \"\"\"\n        if axes is None:\n            axes = [ensure_index([])] + [ensure_index(a)\n                                         for a in self.axes[1:]]\n\n        # preserve dtype if possible\n        if self.ndim == 1:\n            blocks = np.array([], dtype=self.array_dtype)\n        else:\n            blocks = []\n        return self.__class__(blocks, axes)",
        "history": [],
        "output": "return an empty BlockManager with the items axis of len 0",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def next(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: float\n        \"\"\"\n        self.queue.append(val)\n        return sum(self.queue) / len(self.queue)",
        "history": [],
        "output": ":type val: int\n        :rtype: float",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _FixedSizer(value_size):\n  \"\"\"Like _SimpleSizer except for a fixed-size field.  The input is the size\n  of one value.\"\"\"\n\n  def SpecificSizer(field_number, is_repeated, is_packed):\n    tag_size = _TagSize(field_number)\n    if is_packed:\n      local_VarintSize = _VarintSize\n      def PackedFieldSize(value):\n        result = len(value) * value_size\n        return result + local_VarintSize(result) + tag_size\n      return PackedFieldSize\n    elif is_repeated:\n      element_size = value_size + tag_size\n      def RepeatedFieldSize(value):\n        return len(value) * element_size\n      return RepeatedFieldSize\n    else:\n      field_size = value_size + tag_size\n      def FieldSize(value):\n        return field_size\n      return FieldSize\n\n  return SpecificSizer",
        "history": [],
        "output": "Like _SimpleSizer except for a fixed-size field.  The input is the size\n  of one value.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _value_to_python(value):\n  \"\"\"Converts a google.protobuf.Value to a native Python object.\"\"\"\n\n  assert isinstance(value, struct_pb2.Value)\n  field = value.WhichOneof('kind')\n  if field == 'number_value':\n    return value.number_value\n  elif field == 'string_value':\n    return value.string_value\n  elif field == 'bool_value':\n    return value.bool_value\n  else:\n    raise ValueError('Unknown struct_pb2.Value oneof field set: %s' % field)",
        "history": [],
        "output": "Converts a google.protobuf.Value to a native Python object.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _netstat_route_sunos():\n    '''\n    Return netstat routing information for SunOS\n    '''\n    ret = []\n    cmd = 'netstat -f inet -rn | tail +5'\n    out = __salt__['cmd.run'](cmd, python_shell=True)\n    for line in out.splitlines():\n        comps = line.split()\n        ret.append({\n            'addr_family': 'inet',\n            'destination': comps[0],\n            'gateway': comps[1],\n            'netmask': '',\n            'flags': comps[2],\n            'interface': comps[5] if len(comps) >= 6 else ''})\n    cmd = 'netstat -f inet6 -rn | tail +5'\n    out = __salt__['cmd.run'](cmd, python_shell=True)\n    for line in out.splitlines():\n        comps = line.split()\n        ret.append({\n            'addr_family': 'inet6',\n            'destination': comps[0],\n            'gateway': comps[1],\n            'netmask': '',\n            'flags': comps[2],\n            'interface': comps[5] if len(comps) >= 6 else ''})\n    return ret",
        "history": [],
        "output": "Return netstat routing information for SunOS",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_files(path:PathOrStr, extensions:Collection[str]=None, recurse:bool=False,\n              include:Optional[Collection[str]]=None)->FilePathList:\n    \"Return list of files in `path` that have a suffix in `extensions`; optionally `recurse`.\"\n    if recurse:\n        res = []\n        for i,(p,d,f) in enumerate(os.walk(path)):\n            # skip hidden dirs\n            if include is not None and i==0:  d[:] = [o for o in d if o in include]\n            else:                             d[:] = [o for o in d if not o.startswith('.')]\n            res += _get_files(path, p, f, extensions)\n        return res\n    else:\n        f = [o.name for o in os.scandir(path) if o.is_file()]\n        return _get_files(path, path, f, extensions)",
        "history": [],
        "output": "Return list of files in `path` that have a suffix in `extensions`; optionally `recurse`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def imagetransformerpp_base_8l_8h_big_cond_dr03_dan():\n  \"\"\"big 1d model for conditional image generation.2.99 on cifar10.\"\"\"\n  hparams = imagetransformerpp_sep_channels_8l_8h()\n  hparams.hidden_size = 512\n  hparams.num_heads = 8\n  hparams.filter_size = 2048\n  hparams.batch_size = 4\n  hparams.max_length = 3075\n  hparams.layer_prepostprocess_dropout = 0.3\n  hparams.layer_preprocess_sequence = \"none\"\n  hparams.layer_postprocess_sequence = \"dan\"\n  hparams.summarize_grads = True\n  hparams.learning_rate = 0.01\n  return hparams",
        "history": [],
        "output": "big 1d model for conditional image generation.2.99 on cifar10.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_job_id_from_name(self, job_name):\n        \"\"\"Retrieve the first job ID matching the given name\"\"\"\n        jobs = self._client.list_jobs(jobQueue=self._queue, jobStatus='RUNNING')['jobSummaryList']\n        matching_jobs = [job for job in jobs if job['jobName'] == job_name]\n        if matching_jobs:\n            return matching_jobs[0]['jobId']",
        "history": [],
        "output": "Retrieve the first job ID matching the given name",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def run_example(example_name, environ):\n    \"\"\"\n    Run an example module from zipline.examples.\n    \"\"\"\n    mod = EXAMPLE_MODULES[example_name]\n\n    register_calendar(\"YAHOO\", get_calendar(\"NYSE\"), force=True)\n\n    return run_algorithm(\n        initialize=getattr(mod, 'initialize', None),\n        handle_data=getattr(mod, 'handle_data', None),\n        before_trading_start=getattr(mod, 'before_trading_start', None),\n        analyze=getattr(mod, 'analyze', None),\n        bundle='test',\n        environ=environ,\n        # Provide a default capital base, but allow the test to override.\n        **merge({'capital_base': 1e7}, mod._test_args())\n    )",
        "history": [],
        "output": "Run an example module from zipline.examples.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def is_isomorphic(s, t):\n    \"\"\"\n    :type s: str\n    :type t: str\n    :rtype: bool\n    \"\"\"\n    if len(s) != len(t):\n        return False\n    dict = {}\n    set_value = set()\n    for i in range(len(s)):\n        if s[i] not in dict:\n            if t[i] in set_value:\n                return False\n            dict[s[i]] = t[i]\n            set_value.add(t[i])\n        else:\n            if dict[s[i]] != t[i]:\n                return False\n    return True",
        "history": [],
        "output": ":type s: str\n    :type t: str\n    :rtype: bool",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def write_file(self, blob, dest):\n        '''\n        Using the blob object, write the file to the destination path\n        '''\n        with salt.utils.files.fopen(dest, 'wb+') as fp_:\n            blob.stream_data(fp_)",
        "history": [],
        "output": "Using the blob object, write the file to the destination path",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def decode_base64(data: str) -> bytes:\n    \"\"\"Decode base64, padding being optional.\n\n    :param data: Base64 data as an ASCII byte string\n    :returns: The decoded byte string.\n    \"\"\"\n    missing_padding = len(data) % 4\n    if missing_padding != 0:\n        data += \"=\" * (4 - missing_padding)\n    return base64.decodebytes(data.encode(\"utf-8\"))",
        "history": [],
        "output": "Decode base64, padding being optional.\n\n    :param data: Base64 data as an ASCII byte string\n    :returns: The decoded byte string.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def time_to_str(timestamp: int) -> str:\n    \"\"\"\n    Convert seconds past Epoch to human readable string.\n    \"\"\"\n    datetimestamp = datetime.datetime.fromtimestamp(timestamp)\n    return '{:04d}-{:02d}-{:02d}-{:02d}-{:02d}-{:02d}'.format(\n            datetimestamp.year, datetimestamp.month, datetimestamp.day,\n            datetimestamp.hour, datetimestamp.minute, datetimestamp.second\n    )",
        "history": [],
        "output": "Convert seconds past Epoch to human readable string.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def explained_variance(pred:Tensor, targ:Tensor)->Rank0Tensor:\n    \"Explained variance between `pred` and `targ`.\"\n    pred,targ = flatten_check(pred,targ)\n    var_pct = torch.var(targ - pred) / torch.var(targ)\n    return 1 - var_pct",
        "history": [],
        "output": "Explained variance between `pred` and `targ`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _netstat_route_netbsd():\n    '''\n    Return netstat routing information for NetBSD\n    '''\n    ret = []\n    cmd = 'netstat -f inet -rn | tail -n+5'\n    out = __salt__['cmd.run'](cmd, python_shell=True)\n    for line in out.splitlines():\n        comps = line.split()\n        ret.append({\n            'addr_family': 'inet',\n            'destination': comps[0],\n            'gateway': comps[1],\n            'netmask': '',\n            'flags': comps[3],\n            'interface': comps[6]})\n    cmd = 'netstat -f inet6 -rn | tail -n+5'\n    out = __salt__['cmd.run'](cmd, python_shell=True)\n    for line in out.splitlines():\n        comps = line.split()\n        ret.append({\n            'addr_family': 'inet6',\n            'destination': comps[0],\n            'gateway': comps[1],\n            'netmask': '',\n            'flags': comps[3],\n            'interface': comps[6]})\n    return ret",
        "history": [],
        "output": "Return netstat routing information for NetBSD",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_today_all(output='pd'):\n    \"\"\"today all\n\n    Returns:\n        [type] -- [description]\n    \"\"\"\n\n    data = []\n    today = str(datetime.date.today())\n    codes = QA_fetch_get_stock_list('stock').code.tolist()\n    bestip = select_best_ip()['stock']\n    for code in codes:\n        try:\n            l = QA_fetch_get_stock_day(\n                code, today, today, '00', ip=bestip)\n        except:\n            bestip = select_best_ip()['stock']\n            l = QA_fetch_get_stock_day(\n                code, today, today, '00', ip=bestip)\n        if l is not None:\n            data.append(l)\n\n    res = pd.concat(data)\n    if output in ['pd']:\n        return res\n    elif output in ['QAD']:\n        return QA_DataStruct_Stock_day(res.set_index(['date', 'code'], drop=False))",
        "history": [],
        "output": "today all\n\n    Returns:\n        [type] -- [description]",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def default_subprocess_runner(cmd, cwd=None, extra_environ=None):\n    \"\"\"The default method of calling the wrapper subprocess.\"\"\"\n    env = os.environ.copy()\n    if extra_environ:\n        env.update(extra_environ)\n\n    check_call(cmd, cwd=cwd, env=env)",
        "history": [],
        "output": "The default method of calling the wrapper subprocess.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_history_daily_window(self,\n                                  assets,\n                                  end_dt,\n                                  bar_count,\n                                  field_to_use,\n                                  data_frequency):\n        \"\"\"\n        Internal method that returns a dataframe containing history bars\n        of daily frequency for the given sids.\n        \"\"\"\n        session = self.trading_calendar.minute_to_session_label(end_dt)\n        days_for_window = self._get_days_for_window(session, bar_count)\n\n        if len(assets) == 0:\n            return pd.DataFrame(None,\n                                index=days_for_window,\n                                columns=None)\n\n        data = self._get_history_daily_window_data(\n            assets, days_for_window, end_dt, field_to_use, data_frequency\n        )\n        return pd.DataFrame(\n            data,\n            index=days_for_window,\n            columns=assets\n        )",
        "history": [],
        "output": "Internal method that returns a dataframe containing history bars\n        of daily frequency for the given sids.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def create_async_sns_topic(self, lambda_name, lambda_arn):\n        \"\"\"\n        Create the SNS-based async topic.\n        \"\"\"\n        topic_name = get_topic_name(lambda_name)\n        # Create SNS topic\n        topic_arn = self.sns_client.create_topic(\n            Name=topic_name)['TopicArn']\n        # Create subscription\n        self.sns_client.subscribe(\n            TopicArn=topic_arn,\n            Protocol='lambda',\n            Endpoint=lambda_arn\n        )\n        # Add Lambda permission for SNS to invoke function\n        self.create_event_permission(\n            lambda_name=lambda_name,\n            principal='sns.amazonaws.com',\n            source_arn=topic_arn\n        )\n        # Add rule for SNS topic as a event source\n        add_event_source(\n            event_source={\n                \"arn\": topic_arn,\n                \"events\": [\"sns:Publish\"]\n            },\n            lambda_arn=lambda_arn,\n            target_function=\"zappa.asynchronous.route_task\",\n            boto_session=self.boto_session\n        )\n        return topic_arn",
        "history": [],
        "output": "Create the SNS-based async topic.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def link_mountpoint(self, repo):\n        '''\n        Ensure that the mountpoint is present in the correct location and\n        points at the correct path\n        '''\n        lcachelink = salt.utils.path.join(repo.linkdir, repo._mountpoint)\n        lcachedest = salt.utils.path.join(repo.cachedir, repo.root()).rstrip(os.sep)\n        wipe_linkdir = False\n        create_link = False\n        try:\n            with repo.gen_lock(lock_type='mountpoint', timeout=10):\n                walk_results = list(os.walk(repo.linkdir, followlinks=False))\n                if walk_results != repo.linkdir_walk:\n                    log.debug(\n                        'Results of walking %s differ from expected results',\n                        repo.linkdir\n                    )\n                    log.debug('Walk results: %s', walk_results)\n                    log.debug('Expected results: %s', repo.linkdir_walk)\n                    wipe_linkdir = True\n                else:\n                    if not all(not salt.utils.path.islink(x[0])\n                               and os.path.isdir(x[0])\n                               for x in walk_results[:-1]):\n                        log.debug(\n                            'Linkdir parents of %s are not all directories',\n                            lcachelink\n                        )\n                        wipe_linkdir = True\n                    elif not salt.utils.path.islink(lcachelink):\n                        wipe_linkdir = True\n                    else:\n                        try:\n                            ldest = salt.utils.path.readlink(lcachelink)\n                        except Exception:\n                            log.debug(\n                                'Failed to read destination of %s', lcachelink\n                            )\n                            wipe_linkdir = True\n                        else:\n                            if ldest != lcachedest:\n                                log.debug(\n                                    'Destination of %s (%s) does not match '\n                                    'the expected value (%s)',\n                                    lcachelink, ldest, lcachedest\n                                )\n                                # Since we know that the parent dirs of the\n                                # link are set up properly, all we need to do\n                                # is remove the symlink and let it be created\n                                # below.\n                                try:\n                                    if salt.utils.platform.is_windows() \\\n                                            and not ldest.startswith('\\\\\\\\') \\\n                                            and os.path.isdir(ldest):\n                                        # On Windows, symlinks to directories\n                                        # must be removed as if they were\n                                        # themselves directories.\n                                        shutil.rmtree(lcachelink)\n                                    else:\n                                        os.remove(lcachelink)\n                                except Exception as exc:\n                                    log.exception(\n                                        'Failed to remove existing git_pillar '\n                                        'mountpoint link %s: %s',\n                                        lcachelink, exc.__str__()\n                                    )\n                                wipe_linkdir = False\n                                create_link = True\n\n                if wipe_linkdir:\n                    # Wiping implies that we need to create the link\n                    create_link = True\n                    try:\n                        shutil.rmtree(repo.linkdir)\n                    except OSError:\n                        pass\n                    try:\n                        ldirname = os.path.dirname(lcachelink)\n                        os.makedirs(ldirname)\n                        log.debug('Successfully made linkdir parent %s', ldirname)\n                    except OSError as exc:\n                        log.error(\n                            'Failed to os.makedirs() linkdir parent %s: %s',\n                            ldirname, exc.__str__()\n                        )\n                        return False\n\n                if create_link:\n                    try:\n                        os.symlink(lcachedest, lcachelink)\n                        log.debug(\n                            'Successfully linked %s to cachedir %s',\n                            lcachelink, lcachedest\n                        )\n                        return True\n                    except OSError as exc:\n                        log.error(\n                            'Failed to create symlink to %s at path %s: %s',\n                            lcachedest, lcachelink, exc.__str__()\n                        )\n                        return False\n        except GitLockError:\n            log.error(\n                'Timed out setting mountpoint lock for %s remote \\'%s\\'. If '\n                'this error persists, it may be because an earlier %s '\n                'checkout was interrupted. The lock can be cleared by running '\n                '\\'salt-run cache.clear_git_lock %s type=mountpoint\\', or by '\n                'manually removing %s.',\n                self.role, repo.id, self.role, self.role,\n                repo._get_lock_file(lock_type='mountpoint')\n            )\n            return False\n        return True",
        "history": [],
        "output": "Ensure that the mountpoint is present in the correct location and\n        points at the correct path",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def execute_lines(self, lines):\r\n        \"\"\"Execute lines and give focus to shell\"\"\"\r\n        self.shell.execute_lines(to_text_string(lines))\r\n        self.shell.setFocus()",
        "history": [],
        "output": "Execute lines and give focus to shell",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _attrs_to_tuple(obj, attrs):\n    \"\"\"\n    Create a tuple of all values of *obj*'s *attrs*.\n    \"\"\"\n    return tuple(getattr(obj, a.name) for a in attrs)",
        "history": [],
        "output": "Create a tuple of all values of *obj*'s *attrs*.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def finding_path(cls, organization, source, finding):\n        \"\"\"Return a fully-qualified finding string.\"\"\"\n        return google.api_core.path_template.expand(\n            \"organizations/{organization}/sources/{source}/findings/{finding}\",\n            organization=organization,\n            source=source,\n            finding=finding,\n        )",
        "history": [],
        "output": "Return a fully-qualified finding string.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def imagetransformer_base_12l_8h_big():\n  \"\"\"big 1d model for conditional image generation.\"\"\"\n  hparams = imagetransformer_sep_channels_8l_8h()\n  hparams.filter_size = 1024\n  hparams.num_decoder_layers = 12\n  hparams.batch_size = 1\n  hparams.hidden_size = 512\n  hparams.learning_rate_warmup_steps = 4000\n  hparams.sampling_method = \"random\"\n  hparams.beam_size = 1\n  hparams.block_width = 256\n  return hparams",
        "history": [],
        "output": "big 1d model for conditional image generation.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _resizeColumnsToContents(self, header, data, limit_ms):\r\n        \"\"\"Resize all the colummns to its contents.\"\"\"\r\n        max_col = data.model().columnCount()\r\n        if limit_ms is None:\r\n            max_col_ms = None\r\n        else:\r\n            max_col_ms = limit_ms / max(1, max_col)\r\n        for col in range(max_col):\r\n            self._resizeColumnToContents(header, data, col, max_col_ms)",
        "history": [],
        "output": "Resize all the colummns to its contents.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def train_agent_real_env(env, learner, hparams, epoch):\n  \"\"\"Train the PPO agent in the real environment.\"\"\"\n  base_algo_str = hparams.base_algo\n\n  train_hparams = trainer_lib.create_hparams(hparams.base_algo_params)\n  rl_utils.update_hparams_from_hparams(\n      train_hparams, hparams, \"real_\" + base_algo_str + \"_\"\n  )\n  if hparams.wm_policy_param_sharing:\n    train_hparams.optimizer_zero_grads = True\n\n  env_fn = rl.make_real_env_fn(env)\n  num_env_steps = real_env_step_increment(hparams)\n  learner.train(\n      env_fn,\n      train_hparams,\n      simulated=False,\n      save_continuously=False,\n      epoch=epoch,\n      sampling_temp=hparams.real_sampling_temp,\n      num_env_steps=num_env_steps,\n  )\n  # Save unfinished rollouts to history.\n  env.reset()",
        "history": [],
        "output": "Train the PPO agent in the real environment.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def valid_project(self):\r\n        \"\"\"Handle an invalid active project.\"\"\"\r\n        try:\r\n            path = self.projects.get_active_project_path()\r\n        except AttributeError:\r\n            return\r\n\r\n        if bool(path):\r\n            if not self.projects.is_valid_project(path):\r\n                if path:\r\n                    QMessageBox.critical(\r\n                        self,\r\n                        _('Error'),\r\n                        _(\"<b>{}</b> is no longer a valid Spyder project! \"\r\n                          \"Since it is the current active project, it will \"\r\n                          \"be closed automatically.\").format(path))\r\n                self.projects.close_project()",
        "history": [],
        "output": "Handle an invalid active project.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def set_namespace_view_settings(self):\n        \"\"\"Set the namespace view settings\"\"\"\n        if self.namespacebrowser:\n            settings = to_text_string(\n                self.namespacebrowser.get_view_settings())\n            code =(u\"get_ipython().kernel.namespace_view_settings = %s\" %\n                   settings)\n            self.silent_execute(code)",
        "history": [],
        "output": "Set the namespace view settings",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def setParams(self, minSupport=0.1, maxPatternLength=10, maxLocalProjDBSize=32000000,\n                  sequenceCol=\"sequence\"):\n        \"\"\"\n        setParams(self, minSupport=0.1, maxPatternLength=10, maxLocalProjDBSize=32000000, \\\n                  sequenceCol=\"sequence\")\n        \"\"\"\n        kwargs = self._input_kwargs\n        return self._set(**kwargs)",
        "history": [],
        "output": "setParams(self, minSupport=0.1, maxPatternLength=10, maxLocalProjDBSize=32000000, \\\n                  sequenceCol=\"sequence\")",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def remove(self, future):\n        \"\"\"Remove an object from the linked list.\n\n        Args:\n            future (PlasmaObjectFuture): A PlasmaObjectFuture instance.\n        \"\"\"\n        if self._loop.get_debug():\n            logger.debug(\"Removing %s from the linked list.\", future)\n        if future.prev is None:\n            assert future is self.head\n            self.head = future.next\n            if self.head is None:\n                self.tail = None\n                if not self.cancelled():\n                    self.set_result(None)\n            else:\n                self.head.prev = None\n        elif future.next is None:\n            assert future is self.tail\n            self.tail = future.prev\n            if self.tail is None:\n                self.head = None\n                if not self.cancelled():\n                    self.set_result(None)\n            else:\n                self.tail.prev = None",
        "history": [],
        "output": "Remove an object from the linked list.\n\n        Args:\n            future (PlasmaObjectFuture): A PlasmaObjectFuture instance.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def verify_images(path:PathOrStr, delete:bool=True, max_workers:int=4, max_size:Union[int]=None, recurse:bool=False,\n                  dest:PathOrStr='.', n_channels:int=3, interp=PIL.Image.BILINEAR, ext:str=None, img_format:str=None,\n                  resume:bool=None, **kwargs):\n    \"Check if the images in `path` aren't broken, maybe resize them and copy it in `dest`.\"\n    path = Path(path)\n    if resume is None and dest == '.': resume=False\n    dest = path/Path(dest)\n    os.makedirs(dest, exist_ok=True)\n    files = get_image_files(path, recurse=recurse)\n    func = partial(verify_image, delete=delete, max_size=max_size, dest=dest, n_channels=n_channels, interp=interp,\n                   ext=ext, img_format=img_format, resume=resume, **kwargs)\n    parallel(func, files, max_workers=max_workers)",
        "history": [],
        "output": "Check if the images in `path` aren't broken, maybe resize them and copy it in `dest`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def vserver_exists(v_name, v_ip=None, v_port=None, v_type=None, **connection_args):\n    '''\n    Checks if a vserver exists\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' netscaler.vserver_exists 'vserverName'\n    '''\n    vserver = _vserver_get(v_name, **connection_args)\n    if vserver is None:\n        return False\n    if v_ip is not None and vserver.get_ipv46() != v_ip:\n        return False\n    if v_port is not None and vserver.get_port() != v_port:\n        return False\n    if v_type is not None and vserver.get_servicetype().upper() != v_type.upper():\n        return False\n    return True",
        "history": [],
        "output": "Checks if a vserver exists\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' netscaler.vserver_exists 'vserverName'",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _sanitize_value(x):\n    \"\"\"\n    Performs cleaning steps on the data so various type comparisons can\n    be performed correctly.\n    \"\"\"\n    if isinstance(x, _six.string_types + _six.integer_types + (float,)):\n        return x\n    elif _HAS_SKLEARN and _sp.issparse(x):\n        return x.todense()\n    elif isinstance(x, _np.ndarray):\n        return x\n    elif isinstance(x, tuple):\n        return (_sanitize_value(v) for v in x)\n    elif isinstance(x, list):\n        return [_sanitize_value(v) for v in x]\n    elif isinstance(x, dict):\n        return dict( (_sanitize_value(k), _sanitize_value(v)) for k, v in x.items())\n    else:\n        assert False, str(x)",
        "history": [],
        "output": "Performs cleaning steps on the data so various type comparisons can\n    be performed correctly.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def list_corpus_files(dotted_path):\n    \"\"\"\n    Return a list of file paths to each data file in the specified corpus.\n    \"\"\"\n    corpus_path = get_file_path(dotted_path, extension=CORPUS_EXTENSION)\n    paths = []\n\n    if os.path.isdir(corpus_path):\n        paths = glob.glob(corpus_path + '/**/*.' + CORPUS_EXTENSION, recursive=True)\n    else:\n        paths.append(corpus_path)\n\n    paths.sort()\n    return paths",
        "history": [],
        "output": "Return a list of file paths to each data file in the specified corpus.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _refresh_file_mapping(self):\n        '''\n        refresh the mapping of the FS on disk\n        '''\n        # map of suffix to description for imp\n        if self.opts.get('cython_enable', True) is True:\n            try:\n                global pyximport\n                pyximport = __import__('pyximport')  # pylint: disable=import-error\n                pyximport.install()\n                # add to suffix_map so file_mapping will pick it up\n                self.suffix_map['.pyx'] = tuple()\n            except ImportError:\n                log.info('Cython is enabled in the options but not present '\n                    'in the system path. Skipping Cython modules.')\n        # Allow for zipimport of modules\n        if self.opts.get('enable_zip_modules', True) is True:\n            self.suffix_map['.zip'] = tuple()\n        # allow for module dirs\n        if USE_IMPORTLIB:\n            self.suffix_map[''] = ('', '', MODULE_KIND_PKG_DIRECTORY)\n        else:\n            self.suffix_map[''] = ('', '', imp.PKG_DIRECTORY)\n\n        # create mapping of filename (without suffix) to (path, suffix)\n        # The files are added in order of priority, so order *must* be retained.\n        self.file_mapping = salt.utils.odict.OrderedDict()\n\n        opt_match = []\n\n        def _replace_pre_ext(obj):\n            '''\n            Hack so we can get the optimization level that we replaced (if\n            any) out of the re.sub call below. We use a list here because\n            it is a persistent data structure that we will be able to\n            access after re.sub is called.\n            '''\n            opt_match.append(obj)\n            return ''\n\n        for mod_dir in self.module_dirs:\n            try:\n                # Make sure we have a sorted listdir in order to have\n                # expectable override results\n                files = sorted(\n                    x for x in os.listdir(mod_dir) if x != '__pycache__'\n                )\n            except OSError:\n                continue  # Next mod_dir\n            if six.PY3:\n                try:\n                    pycache_files = [\n                        os.path.join('__pycache__', x) for x in\n                        sorted(os.listdir(os.path.join(mod_dir, '__pycache__')))\n                    ]\n                except OSError:\n                    pass\n                else:\n                    files.extend(pycache_files)\n\n            for filename in files:\n                try:\n                    dirname, basename = os.path.split(filename)\n                    if basename.startswith('_'):\n                        # skip private modules\n                        # log messages omitted for obviousness\n                        continue  # Next filename\n                    f_noext, ext = os.path.splitext(basename)\n                    if six.PY3:\n                        f_noext = PY3_PRE_EXT.sub(_replace_pre_ext, f_noext)\n                        try:\n                            opt_level = int(\n                                opt_match.pop().group(1).rsplit('-', 1)[-1]\n                            )\n                        except (AttributeError, IndexError, ValueError):\n                            # No regex match or no optimization level matched\n                            opt_level = 0\n                        try:\n                            opt_index = self.opts['optimization_order'].index(opt_level)\n                        except KeyError:\n                            log.trace(\n                                'Disallowed optimization level %d for module '\n                                'name \\'%s\\', skipping. Add %d to the '\n                                '\\'optimization_order\\' config option if you '\n                                'do not want to ignore this optimization '\n                                'level.', opt_level, f_noext, opt_level\n                            )\n                            continue\n                    else:\n                        # Optimization level not reflected in filename on PY2\n                        opt_index = 0\n\n                    # make sure it is a suffix we support\n                    if ext not in self.suffix_map:\n                        continue  # Next filename\n                    if f_noext in self.disabled:\n                        log.trace(\n                            'Skipping %s, it is disabled by configuration',\n                            filename\n                        )\n                        continue  # Next filename\n                    fpath = os.path.join(mod_dir, filename)\n                    # if its a directory, lets allow us to load that\n                    if ext == '':\n                        # is there something __init__?\n                        subfiles = os.listdir(fpath)\n                        for suffix in self.suffix_order:\n                            if '' == suffix:\n                                continue  # Next suffix (__init__ must have a suffix)\n                            init_file = '__init__{0}'.format(suffix)\n                            if init_file in subfiles:\n                                break\n                        else:\n                            continue  # Next filename\n\n                    try:\n                        curr_ext = self.file_mapping[f_noext][1]\n                        curr_opt_index = self.file_mapping[f_noext][2]\n                    except KeyError:\n                        pass\n                    else:\n                        if '' in (curr_ext, ext) and curr_ext != ext:\n                            log.error(\n                                'Module/package collision: \\'%s\\' and \\'%s\\'',\n                                fpath,\n                                self.file_mapping[f_noext][0]\n                            )\n\n                        if six.PY3 and ext == '.pyc' and curr_ext == '.pyc':\n                            # Check the optimization level\n                            if opt_index >= curr_opt_index:\n                                # Module name match, but a higher-priority\n                                # optimization level was already matched, skipping.\n                                continue\n                        elif not curr_ext or self.suffix_order.index(ext) >= self.suffix_order.index(curr_ext):\n                            # Match found but a higher-priorty match already\n                            # exists, so skip this.\n                            continue\n\n                    if six.PY3 and not dirname and ext == '.pyc':\n                        # On Python 3, we should only load .pyc files from the\n                        # __pycache__ subdirectory (i.e. when dirname is not an\n                        # empty string).\n                        continue\n\n                    # Made it this far - add it\n                    self.file_mapping[f_noext] = (fpath, ext, opt_index)\n\n                except OSError:\n                    continue\n        for smod in self.static_modules:\n            f_noext = smod.split('.')[-1]\n            self.file_mapping[f_noext] = (smod, '.o', 0)",
        "history": [],
        "output": "refresh the mapping of the FS on disk",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def __get_job_status(self):\n        \"\"\"Return the Kubernetes job status\"\"\"\n        # Figure out status and return it\n        job = self.__get_job()\n\n        if \"succeeded\" in job.obj[\"status\"] and job.obj[\"status\"][\"succeeded\"] > 0:\n            job.scale(replicas=0)\n            if self.print_pod_logs_on_exit:\n                self.__print_pod_logs()\n            if self.delete_on_success:\n                self.__delete_job_cascade(job)\n            return \"SUCCEEDED\"\n\n        if \"failed\" in job.obj[\"status\"]:\n            failed_cnt = job.obj[\"status\"][\"failed\"]\n            self.__logger.debug(\"Kubernetes job \" + self.uu_name\n                                + \" status.failed: \" + str(failed_cnt))\n            if self.print_pod_logs_on_exit:\n                self.__print_pod_logs()\n            if failed_cnt > self.max_retrials:\n                job.scale(replicas=0)  # avoid more retrials\n                return \"FAILED\"\n        return \"RUNNING\"",
        "history": [],
        "output": "Return the Kubernetes job status",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _is_path_match(req_path: str, cookie_path: str) -> bool:\n        \"\"\"Implements path matching adhering to RFC 6265.\"\"\"\n        if not req_path.startswith(\"/\"):\n            req_path = \"/\"\n\n        if req_path == cookie_path:\n            return True\n\n        if not req_path.startswith(cookie_path):\n            return False\n\n        if cookie_path.endswith(\"/\"):\n            return True\n\n        non_matching = req_path[len(cookie_path):]\n\n        return non_matching.startswith(\"/\")",
        "history": [],
        "output": "Implements path matching adhering to RFC 6265.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def xpointerNewRange(self, startindex, end, endindex):\n        \"\"\"Create a new xmlXPathObjectPtr of type range \"\"\"\n        if end is None: end__o = None\n        else: end__o = end._o\n        ret = libxml2mod.xmlXPtrNewRange(self._o, startindex, end__o, endindex)\n        if ret is None:raise treeError('xmlXPtrNewRange() failed')\n        return xpathObjectRet(ret)",
        "history": [],
        "output": "Create a new xmlXPathObjectPtr of type range",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _maybe_clear_deque(self):\n    '''Clears the deque if certain parts of the config have changed.'''\n\n    for config_item in ['values', 'mode', 'show_all']:\n      if self.config[config_item] != self.old_config[config_item]:\n        self.sections_over_time.clear()\n        break\n\n    self.old_config = self.config\n\n    window_size = self.config['window_size']\n    if window_size != self.sections_over_time.maxlen:\n      self.sections_over_time = deque(self.sections_over_time, window_size)",
        "history": [],
        "output": "Clears the deque if certain parts of the config have changed.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def subsets(self):\n    \"\"\"Subsets that make up each split of the dataset for the language pair.\"\"\"\n    source, target = self.builder_config.language_pair\n    filtered_subsets = {}\n    for split, ss_names in self._subsets.items():\n      filtered_subsets[split] = []\n      for ss_name in ss_names:\n        ds = DATASET_MAP[ss_name]\n        if ds.target != target or source not in ds.sources:\n          logging.info(\n              \"Skipping sub-dataset that does not include language pair: %s\",\n              ss_name)\n        else:\n          filtered_subsets[split].append(ss_name)\n    logging.info(\"Using sub-datasets: %s\", filtered_subsets)\n    return filtered_subsets",
        "history": [],
        "output": "Subsets that make up each split of the dataset for the language pair.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _train_and_eval_dataset_v1(problem_name, data_dir):\n  \"\"\"Return train and evaluation datasets, feature info and supervised keys.\"\"\"\n  problem = problems.problem(problem_name)\n  train_dataset = problem.dataset(tf.estimator.ModeKeys.TRAIN, data_dir)\n  train_dataset = train_dataset.map(_select_features)\n  eval_dataset = problem.dataset(tf.estimator.ModeKeys.EVAL, data_dir)\n  eval_dataset = eval_dataset.map(_select_features)\n  supervised_keys = ([\"inputs\"], [\"targets\"])\n  hparams = problem.get_hparams()\n  # We take a few training examples to guess the shapes.\n  input_shapes, target_shapes = [], []\n  for example in train_dataset.take(3):\n    input_shapes.append(example[\"inputs\"].shape.as_list())\n    target_shapes.append(example[\"targets\"].shape.as_list())\n  input_vocab_size = hparams.vocab_size[\"inputs\"]\n  target_vocab_size = hparams.vocab_size[\"targets\"]\n  input_info = _make_info(input_shapes, input_vocab_size)\n  target_info = _make_info(target_shapes, target_vocab_size)\n  info = {\"inputs\": input_info, \"targets\": target_info}\n  return train_dataset, eval_dataset, info, supervised_keys",
        "history": [],
        "output": "Return train and evaluation datasets, feature info and supervised keys.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def prepare_defenses(self):\n    \"\"\"Prepares all data needed for evaluation of defenses.\"\"\"\n    print_header('PREPARING DEFENSE DATA')\n    # verify that defense data not written yet\n    if not self.ask_when_work_is_populated(self.defense_work):\n      return\n    self.defense_work = eval_lib.DefenseWorkPieces(\n        datastore_client=self.datastore_client)\n    # load results of attacks\n    self.submissions.init_from_datastore()\n    self.dataset_batches.init_from_datastore()\n    self.adv_batches.init_from_datastore()\n    self.attack_work.read_all_from_datastore()\n    # populate classification results\n    print_header('Initializing classification batches')\n    self.class_batches.init_from_adversarial_batches_write_to_datastore(\n        self.submissions, self.adv_batches)\n    if self.verbose:\n      print(self.class_batches)\n    # populate work pieces\n    print_header('Preparing defense work pieces')\n    self.defense_work.init_from_class_batches(\n        self.class_batches.data, num_shards=self.num_defense_shards)\n    self.defense_work.write_all_to_datastore()\n    if self.verbose:\n      print(self.defense_work)",
        "history": [],
        "output": "Prepares all data needed for evaluation of defenses.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def update_if_absent(self, **kwargs):\n        \"\"\"Update the settings when the target fields are None.\n\n        Args:\n            kwargs: The keyword arguments to set corresponding fields.\n        \"\"\"\n        for arg in kwargs:\n            if hasattr(self, arg):\n                if getattr(self, arg) is None:\n                    setattr(self, arg, kwargs[arg])\n            else:\n                raise ValueError(\"Invalid RayParams parameter in\"\n                                 \" update_if_absent: %s\" % arg)\n\n        self._check_usage()",
        "history": [],
        "output": "Update the settings when the target fields are None.\n\n        Args:\n            kwargs: The keyword arguments to set corresponding fields.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "async def write(self, data):\n        \"\"\"Writes a chunk of data to the streaming response.\n\n        :param data: bytes-ish data to be written.\n        \"\"\"\n        if type(data) != bytes:\n            data = self._encode_body(data)\n\n        self.protocol.push_data(b\"%x\\r\\n%b\\r\\n\" % (len(data), data))\n        await self.protocol.drain()",
        "history": [],
        "output": "Writes a chunk of data to the streaming response.\n\n        :param data: bytes-ish data to be written.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def add_trial(self, name, specification):\n        \"\"\"Adds a trial by name and specification (dict).\"\"\"\n        payload = {\"name\": name, \"spec\": specification}\n        response = requests.post(urljoin(self._path, \"trials\"), json=payload)\n        return self._deserialize(response)",
        "history": [],
        "output": "Adds a trial by name and specification (dict).",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _has_ipv6(host):\n    \"\"\" Returns True if the system can bind an IPv6 address. \"\"\"\n    sock = None\n    has_ipv6 = False\n\n    # App Engine doesn't support IPV6 sockets and actually has a quota on the\n    # number of sockets that can be used, so just early out here instead of\n    # creating a socket needlessly.\n    # See https://github.com/urllib3/urllib3/issues/1446\n    if _appengine_environ.is_appengine_sandbox():\n        return False\n\n    if socket.has_ipv6:\n        # has_ipv6 returns true if cPython was compiled with IPv6 support.\n        # It does not tell us if the system has IPv6 support enabled. To\n        # determine that we must bind to an IPv6 address.\n        # https://github.com/shazow/urllib3/pull/611\n        # https://bugs.python.org/issue658327\n        try:\n            sock = socket.socket(socket.AF_INET6)\n            sock.bind((host, 0))\n            has_ipv6 = True\n        except Exception:\n            pass\n\n    if sock:\n        sock.close()\n    return has_ipv6",
        "history": [],
        "output": "Returns True if the system can bind an IPv6 address.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def generate(self, **kwargs: Any) -> bytes:\n        \"\"\"Generate this template with the given arguments.\"\"\"\n        namespace = {\n            \"escape\": escape.xhtml_escape,\n            \"xhtml_escape\": escape.xhtml_escape,\n            \"url_escape\": escape.url_escape,\n            \"json_encode\": escape.json_encode,\n            \"squeeze\": escape.squeeze,\n            \"linkify\": escape.linkify,\n            \"datetime\": datetime,\n            \"_tt_utf8\": escape.utf8,  # for internal use\n            \"_tt_string_types\": (unicode_type, bytes),\n            # __name__ and __loader__ allow the traceback mechanism to find\n            # the generated source code.\n            \"__name__\": self.name.replace(\".\", \"_\"),\n            \"__loader__\": ObjectDict(get_source=lambda name: self.code),\n        }\n        namespace.update(self.namespace)\n        namespace.update(kwargs)\n        exec_in(self.compiled, namespace)\n        execute = typing.cast(Callable[[], bytes], namespace[\"_tt_execute\"])\n        # Clear the traceback module's cache of source data now that\n        # we've generated a new template (mainly for this module's\n        # unittests, where different tests reuse the same name).\n        linecache.clearcache()\n        return execute()",
        "history": [],
        "output": "Generate this template with the given arguments.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def set_todo_results(self, filename, todo_results):\r\n        \"\"\"Synchronize todo results between editorstacks\"\"\"\r\n        index = self.has_filename(filename)\r\n        if index is None:\r\n            return\r\n        self.data[index].set_todo_results(todo_results)",
        "history": [],
        "output": "Synchronize todo results between editorstacks",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def load(path):\n        \"\"\"Loads analytics report from json file specified by path.\n\n        Args:\n            path (str): path to json file with analytics report.\n        \"\"\"\n        with open(path, \"r\") as fobj:\n            analytics = Analytics(info=json.load(fobj))\n        os.unlink(path)\n        return analytics",
        "history": [],
        "output": "Loads analytics report from json file specified by path.\n\n        Args:\n            path (str): path to json file with analytics report.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def watchdog(sleep_interval):\n    \"\"\"Watch project files, restart worker process if a change happened.\n\n    :param sleep_interval: interval in second.\n    :return: Nothing\n    \"\"\"\n    mtimes = {}\n    worker_process = restart_with_reloader()\n    signal.signal(\n        signal.SIGTERM, lambda *args: kill_program_completly(worker_process)\n    )\n    signal.signal(\n        signal.SIGINT, lambda *args: kill_program_completly(worker_process)\n    )\n    while True:\n        for filename in _iter_module_files():\n            try:\n                mtime = os.stat(filename).st_mtime\n            except OSError:\n                continue\n\n            old_time = mtimes.get(filename)\n            if old_time is None:\n                mtimes[filename] = mtime\n                continue\n            elif mtime > old_time:\n                kill_process_children(worker_process.pid)\n                worker_process.terminate()\n                worker_process = restart_with_reloader()\n                mtimes[filename] = mtime\n                break\n\n        sleep(sleep_interval)",
        "history": [],
        "output": "Watch project files, restart worker process if a change happened.\n\n    :param sleep_interval: interval in second.\n    :return: Nothing",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def fire(self, tag, msg):\n        '''\n        This replaces a function in main called 'fire'\n\n        It fires an event into the salt bus.\n        '''\n        if __opts__.get('__role') == 'master':\n            fire_master = salt.utils.event.get_master_event(\n                __opts__,\n                __opts__['sock_dir']).fire_master\n        else:\n            fire_master = None\n\n        if fire_master:\n            fire_master(msg, tag)\n        else:\n            __salt__['event.send'](tag, msg)",
        "history": [],
        "output": "This replaces a function in main called 'fire'\n\n        It fires an event into the salt bus.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def xpathNewValueTree(self):\n        \"\"\"Create a new xmlXPathObjectPtr of type Value Tree (XSLT)\n           and initialize it with the tree root @val \"\"\"\n        ret = libxml2mod.xmlXPathNewValueTree(self._o)\n        if ret is None:raise xpathError('xmlXPathNewValueTree() failed')\n        return xpathObjectRet(ret)",
        "history": [],
        "output": "Create a new xmlXPathObjectPtr of type Value Tree (XSLT)\n           and initialize it with the tree root @val",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def delete_ipsecpolicy(self, ipseecpolicy):\n        '''\n        Deletes the specified IPsecPolicy\n        '''\n        ipseecpolicy_id = self._find_ipsecpolicy_id(ipseecpolicy)\n        ret = self.network_conn.delete_ipsecpolicy(ipseecpolicy_id)\n        return ret if ret else True",
        "history": [],
        "output": "Deletes the specified IPsecPolicy",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def map_arg(**maps):\n    \"\"\"\n    Apply a mapping on certain argument before calling the original function.\n\n    Args:\n        maps (dict): {argument_name: map_func}\n    \"\"\"\n    def deco(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            if six.PY2:\n                argmap = inspect.getcallargs(func, *args, **kwargs)\n            else:\n                # getcallargs was deprecated since 3.5\n                sig = inspect.signature(func)\n                argmap = sig.bind_partial(*args, **kwargs).arguments\n            for k, map_func in six.iteritems(maps):\n                if k in argmap:\n                    argmap[k] = map_func(argmap[k])\n            return func(**argmap)\n        return wrapper\n    return deco",
        "history": [],
        "output": "Apply a mapping on certain argument before calling the original function.\n\n    Args:\n        maps (dict): {argument_name: map_func}",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def has_pair(ip, alias):\n    '''\n    Return true if the alias is set\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' hosts.has_pair <ip> <alias>\n    '''\n    hosts = _list_hosts()\n    try:\n        return alias in hosts[ip]\n    except KeyError:\n        return False",
        "history": [],
        "output": "Return true if the alias is set\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' hosts.has_pair <ip> <alias>",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def to_api_repr(self):\n        \"\"\"API repr (JSON format) for entry.\n        \"\"\"\n        info = super(ProtobufEntry, self).to_api_repr()\n        info[\"protoPayload\"] = MessageToDict(self.payload)\n        return info",
        "history": [],
        "output": "API repr (JSON format) for entry.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def Setup(self, input, URL, encoding, options):\n        \"\"\"Setup an XML reader with new options \"\"\"\n        if input is None: input__o = None\n        else: input__o = input._o\n        ret = libxml2mod.xmlTextReaderSetup(self._o, input__o, URL, encoding, options)\n        return ret",
        "history": [],
        "output": "Setup an XML reader with new options",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def save_metadata(hparams):\n  \"\"\"Saves FLAGS and hparams to output_dir.\"\"\"\n  output_dir = os.path.expanduser(FLAGS.output_dir)\n  if not tf.gfile.Exists(output_dir):\n    tf.gfile.MakeDirs(output_dir)\n\n  # Save FLAGS in txt file\n  if hasattr(FLAGS, \"flags_into_string\"):\n    flags_str = FLAGS.flags_into_string()\n    t2t_flags_str = \"\\n\".join([\n        \"--%s=%s\" % (f.name, f.value)\n        for f in FLAGS.flags_by_module_dict()[\"tensor2tensor.utils.flags\"]\n    ])\n  else:\n    flags_dict = FLAGS.__dict__[\"__flags\"]\n    flags_str = \"\\n\".join(\n        [\"--%s=%s\" % (name, str(f)) for (name, f) in flags_dict.items()])\n    t2t_flags_str = None\n\n  flags_txt = os.path.join(output_dir, \"flags.txt\")\n  with tf.gfile.Open(flags_txt, \"w\") as f:\n    f.write(flags_str)\n\n  if t2t_flags_str:\n    t2t_flags_txt = os.path.join(output_dir, \"flags_t2t.txt\")\n    with tf.gfile.Open(t2t_flags_txt, \"w\") as f:\n      f.write(t2t_flags_str)\n\n  # Save hparams as hparams.json\n  new_hparams = hparams_lib.copy_hparams(hparams)\n  # Modality class is not JSON serializable so remove.\n  new_hparams.del_hparam(\"modality\")\n\n  hparams_fname = os.path.join(output_dir, \"hparams.json\")\n  with tf.gfile.Open(hparams_fname, \"w\") as f:\n    f.write(new_hparams.to_json(indent=0, sort_keys=True))",
        "history": [],
        "output": "Saves FLAGS and hparams to output_dir.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def enforce_git_config(self):\n        '''\n        For the config options which need to be maintained in the git config,\n        ensure that the git config file is configured as desired.\n        '''\n        git_config = os.path.join(self.gitdir, 'config')\n        conf = salt.utils.configparser.GitConfigParser()\n        if not conf.read(git_config):\n            log.error('Failed to read from git config file %s', git_config)\n        else:\n            # We are currently enforcing the following git config items:\n            # 1. Fetch URL\n            # 2. refspecs used in fetch\n            # 3. http.sslVerify\n            conf_changed = False\n            remote_section = 'remote \"origin\"'\n\n            # 1. URL\n            try:\n                url = conf.get(remote_section, 'url')\n            except salt.utils.configparser.NoSectionError:\n                # First time we've init'ed this repo, we need to add the\n                # section for the remote to the git config\n                conf.add_section(remote_section)\n                conf_changed = True\n                url = None\n            log.debug(\n                'Current fetch URL for %s remote \\'%s\\': %s (desired: %s)',\n                self.role, self.id, url, self.url\n            )\n            if url != self.url:\n                conf.set(remote_section, 'url', self.url)\n                log.debug(\n                    'Fetch URL for %s remote \\'%s\\' set to %s',\n                    self.role, self.id, self.url\n                )\n                conf_changed = True\n\n            # 2. refspecs\n            try:\n                refspecs = sorted(\n                    conf.get(remote_section, 'fetch', as_list=True))\n            except salt.utils.configparser.NoOptionError:\n                # No 'fetch' option present in the remote section. Should never\n                # happen, but if it does for some reason, don't let it cause a\n                # traceback.\n                refspecs = []\n            desired_refspecs = sorted(self.refspecs)\n            log.debug(\n                'Current refspecs for %s remote \\'%s\\': %s (desired: %s)',\n                self.role, self.id, refspecs, desired_refspecs\n            )\n            if refspecs != desired_refspecs:\n                conf.set_multivar(remote_section, 'fetch', self.refspecs)\n                log.debug(\n                    'Refspecs for %s remote \\'%s\\' set to %s',\n                    self.role, self.id, desired_refspecs\n                )\n                conf_changed = True\n\n            # 3. http.sslVerify\n            try:\n                ssl_verify = conf.get('http', 'sslVerify')\n            except salt.utils.configparser.NoSectionError:\n                conf.add_section('http')\n                ssl_verify = None\n            except salt.utils.configparser.NoOptionError:\n                ssl_verify = None\n            desired_ssl_verify = six.text_type(self.ssl_verify).lower()\n            log.debug(\n                'Current http.sslVerify for %s remote \\'%s\\': %s (desired: %s)',\n                self.role, self.id, ssl_verify, desired_ssl_verify\n            )\n            if ssl_verify != desired_ssl_verify:\n                conf.set('http', 'sslVerify', desired_ssl_verify)\n                log.debug(\n                    'http.sslVerify for %s remote \\'%s\\' set to %s',\n                    self.role, self.id, desired_ssl_verify\n                )\n                conf_changed = True\n\n            # Write changes, if necessary\n            if conf_changed:\n                with salt.utils.files.fopen(git_config, 'w') as fp_:\n                    conf.write(fp_)\n                    log.debug(\n                        'Config updates for %s remote \\'%s\\' written to %s',\n                        self.role, self.id, git_config\n                    )",
        "history": [],
        "output": "For the config options which need to be maintained in the git config,\n        ensure that the git config file is configured as desired.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _all(self, *args, **kwargs):\n        '''\n        Return all the summary of the particular system.\n        '''\n        data = dict()\n        data['software'] = self._software(**kwargs)\n        data['system'] = self._system(**kwargs)\n        data['services'] = self._services(**kwargs)\n        try:\n            data['configuration'] = self._configuration(**kwargs)\n        except InspectorQueryException as ex:\n            data['configuration'] = 'N/A'\n            log.error(ex)\n        data['payload'] = self._payload(**kwargs) or 'N/A'\n\n        return data",
        "history": [],
        "output": "Return all the summary of the particular system.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def render_tile(cells, ti, tj, render, params, metadata, layout, summary):\n  \"\"\"\n    Render each cell in the tile and stitch it into a single image\n  \"\"\"\n  image_size = params[\"cell_size\"] * params[\"n_tile\"]\n  tile = Image.new(\"RGB\", (image_size, image_size), (255,255,255))\n  keys = cells.keys()\n  for i,key in enumerate(keys):\n    print(\"cell\", i+1, \"/\", len(keys), end='\\r')\n    cell_image = render(cells[key], params, metadata, layout, summary)\n    # stitch this rendering into the tile image\n    ci = key[0] % params[\"n_tile\"]\n    cj = key[1] % params[\"n_tile\"]\n    xmin = ci*params[\"cell_size\"]\n    ymin = cj*params[\"cell_size\"]\n    xmax = (ci+1)*params[\"cell_size\"]\n    ymax = (cj+1)*params[\"cell_size\"]\n\n    if params.get(\"scale_density\", False):\n      density = len(cells[key][\"gi\"])\n      # scale = density/summary[\"max_density\"]\n      scale = math.log(density)/(math.log(summary[\"max_density\"]) or 1)\n      owidth = xmax - xmin\n      width = int(round(owidth * scale))\n      if(width < 1):\n        width = 1\n      offsetL = int(round((owidth - width)/2))\n      offsetR = owidth - width - offsetL # handle odd numbers\n      # print(\"\\n\")\n      # print(\"width\", width, offsetL, offsetR)\n      box = [xmin + offsetL, ymin + offsetL, xmax - offsetR, ymax - offsetR]\n      resample = params.get(\"scale_type\", Image.NEAREST)\n      cell_image = cell_image.resize(size=(width,width), resample=resample)\n      # print(cell_image)\n    else:\n      box = [xmin, ymin, xmax, ymax]\n\n    # print(\"box\", box)\n    tile.paste(cell_image, box)\n  print(\"\\n\")\n  return tile",
        "history": [],
        "output": "Render each cell in the tile and stitch it into a single image",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_cibpath():\n    '''\n    Get the path to the directory on the minion where CIB's are saved\n    '''\n    cibpath = os.path.join(__opts__['cachedir'], 'pcs', __env__)\n    log.trace('cibpath: %s', cibpath)\n    return cibpath",
        "history": [],
        "output": "Get the path to the directory on the minion where CIB's are saved",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def to_pandas(self):\n        \"\"\"Converts Modin DataFrame to Pandas DataFrame.\n\n        Returns:\n            Pandas DataFrame of the DataManager.\n        \"\"\"\n        df = self.data.to_pandas(is_transposed=self._is_transposed)\n        if df.empty:\n            if len(self.columns) != 0:\n                df = pandas.DataFrame(columns=self.columns).astype(self.dtypes)\n            else:\n                df = pandas.DataFrame(columns=self.columns, index=self.index)\n        else:\n            ErrorMessage.catch_bugs_and_request_email(\n                len(df.index) != len(self.index) or len(df.columns) != len(self.columns)\n            )\n            df.index = self.index\n            df.columns = self.columns\n        return df",
        "history": [],
        "output": "Converts Modin DataFrame to Pandas DataFrame.\n\n        Returns:\n            Pandas DataFrame of the DataManager.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _parse_tensor_info_proto(tensor_info):\n  \"\"\"Returns a ParsedTensorInfo instance from a TensorInfo proto.\"\"\"\n  encoding = tensor_info.WhichOneof(\"encoding\")\n  dtype = tf.DType(tensor_info.dtype)\n  shape = tf.TensorShape(tensor_info.tensor_shape)\n  if encoding == \"name\":\n    return ParsedTensorInfo(dtype=dtype, shape=shape, is_sparse=False)\n  elif encoding == \"coo_sparse\":\n    return ParsedTensorInfo(dtype=dtype, shape=shape, is_sparse=True)\n  else:\n    raise ValueError(\"Unsupported TensorInfo encoding %r\" % encoding)",
        "history": [],
        "output": "Returns a ParsedTensorInfo instance from a TensorInfo proto.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def img2img_transformer_b3():\n  \"\"\"Current best hparams for local 1d.\"\"\"\n  hparams = img2img_transformer_base()\n  hparams.batch_size = 2\n  hparams.layer_preprocess_sequence = \"none\"\n  hparams.layer_postprocess_sequence = \"dan\"\n  hparams.block_length = 128\n  hparams.sampling_temp = 0.9\n  return hparams",
        "history": [],
        "output": "Current best hparams for local 1d.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _jit_predict_fun(model_predict, num_devices):\n  \"\"\"Use jit on model_predict if required.\"\"\"\n  def predict(x, params=(), rng=None):\n    \"\"\"Predict function jited and parallelized as requested.\"\"\"\n    # On one device, jit and run.\n    if num_devices == 1:\n      return backend.jit(model_predict)(x, params, rng=rng)\n\n    # Multi-devices, pmap and run.\n    @functools.partial(backend.pmap, axis_name=\"batch\")\n    def mapped_predict(x, params, rng):\n      return model_predict(x, params, rng=rng)\n    pred = mapped_predict(\n        reshape_by_device(x, num_devices),\n        params,\n        jax_random.split(rng, num_devices))\n    # Need to reduce the [device, per-device-batch, ...] tensors back to\n    # a [batch, ...] tensor. The tensors may be nested.\n    if not isinstance(x, (list, tuple)):  # Not nested.\n      batch_size = x.shape[0]\n      return np.reshape(pred, [batch_size] + list(pred.shape[2:]))\n    batch_size = x[0].shape[0]\n    return [np.reshape(p, [batch_size] + list(p.shape[2:])) for p in pred]\n\n  return predict",
        "history": [],
        "output": "Use jit on model_predict if required.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _AddFieldPaths(node, prefix, field_mask):\n  \"\"\"Adds the field paths descended from node to field_mask.\"\"\"\n  if not node:\n    field_mask.paths.append(prefix)\n    return\n  for name in sorted(node):\n    if prefix:\n      child_path = prefix + '.' + name\n    else:\n      child_path = name\n    _AddFieldPaths(node[name], child_path, field_mask)",
        "history": [],
        "output": "Adds the field paths descended from node to field_mask.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def concat_same_type(self, to_concat, placement=None):\n        \"\"\"\n        Concatenate list of single blocks of the same type.\n        \"\"\"\n        values = self._holder._concat_same_type(\n            [blk.values for blk in to_concat])\n        placement = placement or slice(0, len(values), 1)\n        return self.make_block_same_class(values, ndim=self.ndim,\n                                          placement=placement)",
        "history": [],
        "output": "Concatenate list of single blocks of the same type.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def to_data(b:ItemsList):\n    \"Recursively map lists of items in `b ` to their wrapped data.\"\n    if is_listy(b): return [to_data(o) for o in b]\n    return b.data if isinstance(b,ItemBase) else b",
        "history": [],
        "output": "Recursively map lists of items in `b ` to their wrapped data.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _reduce_mean_ignore_inf(x, axis):\n    \"\"\"Same as tf.reduce_mean() but ignores -inf values.\"\"\"\n    mask = tf.not_equal(x, tf.float32.min)\n    x_zeroed = tf.where(mask, x, tf.zeros_like(x))\n    return (tf.reduce_sum(x_zeroed, axis) / tf.reduce_sum(\n        tf.cast(mask, tf.float32), axis))",
        "history": [],
        "output": "Same as tf.reduce_mean() but ignores -inf values.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def reraise(additional_msg):\n  \"\"\"Reraise an exception with an additional message.\"\"\"\n  exc_type, exc_value, exc_traceback = sys.exc_info()\n  msg = str(exc_value) + \"\\n\" + additional_msg\n  six.reraise(exc_type, exc_type(msg), exc_traceback)",
        "history": [],
        "output": "Reraise an exception with an additional message.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def run_python_script_in_terminal(fname, wdir, args, interact,\r\n                                  debug, python_args, executable=None):\r\n    \"\"\"\r\n    Run Python script in an external system terminal.\r\n\r\n    :str wdir: working directory, may be empty.\r\n    \"\"\"\r\n    if executable is None:\r\n        executable = get_python_executable()\r\n\r\n    # If fname or python_exe contains spaces, it can't be ran on Windows, so we\r\n    # have to enclose them in quotes. Also wdir can come with / as os.sep, so\r\n    # we need to take care of it.\r\n    if os.name == 'nt':\r\n        fname = '\"' + fname + '\"'\r\n        wdir = wdir.replace('/', '\\\\')\r\n        executable = '\"' + executable + '\"'\r\n\r\n    p_args = [executable]\r\n    p_args += get_python_args(fname, python_args, interact, debug, args)\r\n\r\n    if os.name == 'nt':\r\n        cmd = 'start cmd.exe /c \"cd %s && ' % wdir + ' '.join(p_args) + '\"'\r\n        # Command line and cwd have to be converted to the filesystem\r\n        # encoding before passing them to subprocess, but only for\r\n        # Python 2.\r\n        # See https://bugs.python.org/issue1759845#msg74142 and Issue 1856\r\n        if PY2:\r\n            cmd = encoding.to_fs_from_unicode(cmd)\r\n            wdir = encoding.to_fs_from_unicode(wdir)\r\n        try:\r\n            run_shell_command(cmd, cwd=wdir)\r\n        except WindowsError:\r\n            from qtpy.QtWidgets import QMessageBox\r\n            from spyder.config.base import _\r\n            QMessageBox.critical(None, _('Run'),\r\n                                 _(\"It was not possible to run this file in \"\r\n                                   \"an external terminal\"),\r\n                                 QMessageBox.Ok)\r\n    elif os.name == 'posix':\r\n        programs = [{'cmd': 'gnome-terminal',\r\n                     'wdir-option': '--working-directory',\r\n                     'execute-option': '-x'},\r\n                    {'cmd': 'konsole',\r\n                     'wdir-option': '--workdir',\r\n                     'execute-option': '-e'},\r\n                    {'cmd': 'xfce4-terminal',\r\n                     'wdir-option': '--working-directory',\r\n                     'execute-option': '-x'},\r\n                    {'cmd': 'xterm',\r\n                     'wdir-option': None,\r\n                     'execute-option': '-e'},]\r\n        for program in programs:\r\n            if is_program_installed(program['cmd']):\r\n                arglist = []\r\n                if program['wdir-option'] and wdir:\r\n                    arglist += [program['wdir-option'], wdir]\r\n                arglist.append(program['execute-option'])\r\n                arglist += p_args\r\n                if wdir:\r\n                    run_program(program['cmd'], arglist, cwd=wdir)\r\n                else:\r\n                    run_program(program['cmd'], arglist)\r\n                return\r\n        # TODO: Add a fallback to OSX\r\n    else:\r\n        raise NotImplementedError",
        "history": [],
        "output": "Run Python script in an external system terminal.\r\n\r\n    :str wdir: working directory, may be empty.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def lib(names, sources=[], requirements=[], default_build=[], usage_requirements=[]):\n    \"\"\"The implementation of the 'lib' rule. Beyond standard syntax that rule allows\n    simplified: 'lib a b c ;'.\"\"\"\n    assert is_iterable_typed(names, basestring)\n    assert is_iterable_typed(sources, basestring)\n    assert is_iterable_typed(requirements, basestring)\n    assert is_iterable_typed(default_build, basestring)\n    assert is_iterable_typed(usage_requirements, basestring)\n    if len(names) > 1:\n        if any(r.startswith('<name>') for r in requirements):\n            get_manager().errors()(\"When several names are given to the 'lib' rule\\n\" +\n                                   \"it is not allowed to specify the <name> feature.\")\n\n        if sources:\n            get_manager().errors()(\"When several names are given to the 'lib' rule\\n\" +\n                                   \"it is not allowed to specify sources.\")\n\n    project = get_manager().projects().current()\n    result = []\n\n    for name in names:\n        r = requirements[:]\n\n        # Support \" lib a ; \" and \" lib a b c ; \" syntax.\n        if not sources and not any(r.startswith(\"<name>\") for r in requirements) \\\n           and not any(r.startswith(\"<file\") for r in requirements):\n            r.append(\"<name>\" + name)\n\n        result.append(targets.create_typed_metatarget(name, \"LIB\", sources,\n                                                      r,\n                                                      default_build,\n                                                      usage_requirements))\n    return result",
        "history": [],
        "output": "The implementation of the 'lib' rule. Beyond standard syntax that rule allows\n    simplified: 'lib a b c ;'.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def create_or_update(cluster_config_file, min_workers, max_workers, no_restart,\n                     restart_only, yes, cluster_name):\n    \"\"\"Create or update a Ray cluster.\"\"\"\n    if restart_only or no_restart:\n        assert restart_only != no_restart, \"Cannot set both 'restart_only' \" \\\n            \"and 'no_restart' at the same time!\"\n    create_or_update_cluster(cluster_config_file, min_workers, max_workers,\n                             no_restart, restart_only, yes, cluster_name)",
        "history": [],
        "output": "Create or update a Ray cluster.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def convert_examples_to_features(examples, label_list, max_seq_length,\n                                 tokenizer, output_mode):\n    \"\"\"Loads a data file into a list of `InputBatch`s.\"\"\"\n\n    label_map = {label : i for i, label in enumerate(label_list)}\n\n    features = []\n    for (ex_index, example) in enumerate(examples):\n        if ex_index % 10000 == 0:\n            logger.info(\"Writing example %d of %d\" % (ex_index, len(examples)))\n\n        tokens_a = tokenizer.tokenize(example.text_a)\n\n        tokens_b = None\n        if example.text_b:\n            tokens_b = tokenizer.tokenize(example.text_b)\n            # Modifies `tokens_a` and `tokens_b` in place so that the total\n            # length is less than the specified length.\n            # Account for [CLS], [SEP], [SEP] with \"- 3\"\n            _truncate_seq_pair(tokens_a, tokens_b, max_seq_length - 3)\n        else:\n            # Account for [CLS] and [SEP] with \"- 2\"\n            if len(tokens_a) > max_seq_length - 2:\n                tokens_a = tokens_a[:(max_seq_length - 2)]\n\n        # The convention in BERT is:\n        # (a) For sequence pairs:\n        #  tokens:   [CLS] is this jack ##son ##ville ? [SEP] no it is not . [SEP]\n        #  type_ids: 0   0  0    0    0     0       0 0    1  1  1  1   1 1\n        # (b) For single sequences:\n        #  tokens:   [CLS] the dog is hairy . [SEP]\n        #  type_ids: 0   0   0   0  0     0 0\n        #\n        # Where \"type_ids\" are used to indicate whether this is the first\n        # sequence or the second sequence. The embedding vectors for `type=0` and\n        # `type=1` were learned during pre-training and are added to the wordpiece\n        # embedding vector (and position vector). This is not *strictly* necessary\n        # since the [SEP] token unambiguously separates the sequences, but it makes\n        # it easier for the model to learn the concept of sequences.\n        #\n        # For classification tasks, the first vector (corresponding to [CLS]) is\n        # used as as the \"sentence vector\". Note that this only makes sense because\n        # the entire model is fine-tuned.\n        tokens = [\"[CLS]\"] + tokens_a + [\"[SEP]\"]\n        segment_ids = [0] * len(tokens)\n\n        if tokens_b:\n            tokens += tokens_b + [\"[SEP]\"]\n            segment_ids += [1] * (len(tokens_b) + 1)\n\n        input_ids = tokenizer.convert_tokens_to_ids(tokens)\n\n        # The mask has 1 for real tokens and 0 for padding tokens. Only real\n        # tokens are attended to.\n        input_mask = [1] * len(input_ids)\n\n        # Zero-pad up to the sequence length.\n        padding = [0] * (max_seq_length - len(input_ids))\n        input_ids += padding\n        input_mask += padding\n        segment_ids += padding\n\n        assert len(input_ids) == max_seq_length\n        assert len(input_mask) == max_seq_length\n        assert len(segment_ids) == max_seq_length\n\n        if output_mode == \"classification\":\n            label_id = label_map[example.label]\n        elif output_mode == \"regression\":\n            label_id = float(example.label)\n        else:\n            raise KeyError(output_mode)\n\n        if ex_index < 5:\n            logger.info(\"*** Example ***\")\n            logger.info(\"guid: %s\" % (example.guid))\n            logger.info(\"tokens: %s\" % \" \".join(\n                    [str(x) for x in tokens]))\n            logger.info(\"input_ids: %s\" % \" \".join([str(x) for x in input_ids]))\n            logger.info(\"input_mask: %s\" % \" \".join([str(x) for x in input_mask]))\n            logger.info(\n                    \"segment_ids: %s\" % \" \".join([str(x) for x in segment_ids]))\n            logger.info(\"label: %s (id = %d)\" % (example.label, label_id))\n\n        features.append(\n                InputFeatures(input_ids=input_ids,\n                              input_mask=input_mask,\n                              segment_ids=segment_ids,\n                              label_id=label_id))\n    return features",
        "history": [],
        "output": "Loads a data file into a list of `InputBatch`s.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _create_indexer(cls, name, indexer):\n        \"\"\"Create an indexer like _name in the class.\"\"\"\n        if getattr(cls, name, None) is None:\n            _indexer = functools.partial(indexer, name)\n            setattr(cls, name, property(_indexer, doc=indexer.__doc__))",
        "history": [],
        "output": "Create an indexer like _name in the class.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def next_monday(dt):\n    \"\"\"\n    If holiday falls on Saturday, use following Monday instead;\n    if holiday falls on Sunday, use Monday instead\n    \"\"\"\n    if dt.weekday() == 5:\n        return dt + timedelta(2)\n    elif dt.weekday() == 6:\n        return dt + timedelta(1)\n    return dt",
        "history": [],
        "output": "If holiday falls on Saturday, use following Monday instead;\n    if holiday falls on Sunday, use Monday instead",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _lock(self, lock_type='update', failhard=False):\n        '''\n        Place a lock file if (and only if) it does not already exist.\n        '''\n        try:\n            fh_ = os.open(self._get_lock_file(lock_type),\n                          os.O_CREAT | os.O_EXCL | os.O_WRONLY)\n            with os.fdopen(fh_, 'wb'):\n                # Write the lock file and close the filehandle\n                os.write(fh_, salt.utils.stringutils.to_bytes(six.text_type(os.getpid())))\n        except (OSError, IOError) as exc:\n            if exc.errno == errno.EEXIST:\n                with salt.utils.files.fopen(self._get_lock_file(lock_type), 'r') as fd_:\n                    try:\n                        pid = int(salt.utils.stringutils.to_unicode(fd_.readline()).rstrip())\n                    except ValueError:\n                        # Lock file is empty, set pid to 0 so it evaluates as\n                        # False.\n                        pid = 0\n                global_lock_key = self.role + '_global_lock'\n                lock_file = self._get_lock_file(lock_type=lock_type)\n                if self.opts[global_lock_key]:\n                    msg = (\n                        '{0} is enabled and {1} lockfile {2} is present for '\n                        '{3} remote \\'{4}\\'.'.format(\n                            global_lock_key,\n                            lock_type,\n                            lock_file,\n                            self.role,\n                            self.id,\n                        )\n                    )\n                    if pid:\n                        msg += ' Process {0} obtained the lock'.format(pid)\n                        if not pid_exists(pid):\n                            msg += (' but this process is not running. The '\n                                    'update may have been interrupted. If '\n                                    'using multi-master with shared gitfs '\n                                    'cache, the lock may have been obtained '\n                                    'by another master.')\n                    log.warning(msg)\n                    if failhard:\n                        raise exc\n                    return\n                elif pid and pid_exists(pid):\n                    log.warning('Process %d has a %s %s lock (%s)',\n                                pid, self.role, lock_type, lock_file)\n                    if failhard:\n                        raise\n                    return\n                else:\n                    if pid:\n                        log.warning(\n                            'Process %d has a %s %s lock (%s), but this '\n                            'process is not running. Cleaning up lock file.',\n                            pid, self.role, lock_type, lock_file\n                        )\n                    success, fail = self.clear_lock()\n                    if success:\n                        return self._lock(lock_type='update',\n                                          failhard=failhard)\n                    elif failhard:\n                        raise\n                    return\n            else:\n                msg = 'Unable to set {0} lock for {1} ({2}): {3} '.format(\n                    lock_type,\n                    self.id,\n                    self._get_lock_file(lock_type),\n                    exc\n                )\n                log.error(msg, exc_info=True)\n                raise GitLockError(exc.errno, msg)\n        msg = 'Set {0} lock for {1} remote \\'{2}\\''.format(\n            lock_type,\n            self.role,\n            self.id\n        )\n        log.debug(msg)\n        return msg",
        "history": [],
        "output": "Place a lock file if (and only if) it does not already exist.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_metrics_record(xapi, rectype, record):\n    '''\n    Internal, returns metrics record for a rectype\n    '''\n    metrics_id = record['metrics']\n    return getattr(xapi, '{0}_metrics'.format(rectype)).get_record(metrics_id)",
        "history": [],
        "output": "Internal, returns metrics record for a rectype",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def export_serving(model_path):\n    \"\"\"Export trained model to use it in TensorFlow Serving or cloudML. \"\"\"\n    pred_config = PredictConfig(\n        session_init=get_model_loader(model_path),\n        model=InferenceOnlyModel(),\n        input_names=['input_img_bytes'],\n        output_names=['prediction_img_bytes'])\n    ModelExporter(pred_config).export_serving('/tmp/exported')",
        "history": [],
        "output": "Export trained model to use it in TensorFlow Serving or cloudML.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def remove(self, key):\n        \"\"\"Remove a vertex from the graph, disconnecting all edges from/to it.\n        \"\"\"\n        self._vertices.remove(key)\n        for f in self._forwards.pop(key):\n            self._backwards[f].remove(key)\n        for t in self._backwards.pop(key):\n            self._forwards[t].remove(key)",
        "history": [],
        "output": "Remove a vertex from the graph, disconnecting all edges from/to it.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def create_pygments_dict(color_scheme_name):\n    \"\"\"\n    Create a dictionary that saves the given color scheme as a\n    Pygments style.\n    \"\"\"\n\n    def give_font_weight(is_bold):\n        if is_bold:\n            return 'bold'\n        else:\n            return ''\n\n    def give_font_style(is_italic):\n        if is_italic:\n            return 'italic'\n        else:\n            return ''\n\n    color_scheme = get_color_scheme(color_scheme_name)\n\n    fon_c, fon_fw, fon_fs = color_scheme['normal']\n    font_color =  fon_c\n    font_font_weight = give_font_weight(fon_fw)\n    font_font_style = give_font_style(fon_fs)\n    key_c, key_fw, key_fs = color_scheme['keyword']\n    keyword_color =  key_c\n    keyword_font_weight = give_font_weight(key_fw)\n    keyword_font_style = give_font_style(key_fs)\n    bui_c, bui_fw, bui_fs = color_scheme['builtin']\n    builtin_color =  bui_c\n    builtin_font_weight = give_font_weight(bui_fw)\n    builtin_font_style = give_font_style(bui_fs)\n    str_c, str_fw, str_fs = color_scheme['string']\n    string_color =  str_c\n    string_font_weight = give_font_weight(str_fw)\n    string_font_style = give_font_style(str_fs)\n    num_c, num_fw, num_fs = color_scheme['number']\n    number_color =  num_c\n    number_font_weight = give_font_weight(num_fw)\n    number_font_style = give_font_style(num_fs)\n    com_c, com_fw, com_fs = color_scheme['comment']\n    comment_color =  com_c\n    comment_font_weight = give_font_weight(com_fw)\n    comment_font_style = give_font_style(com_fs)\n    def_c, def_fw, def_fs = color_scheme['definition']\n    definition_color =  def_c\n    definition_font_weight = give_font_weight(def_fw)\n    definition_font_style = give_font_style(def_fs)\n    ins_c, ins_fw, ins_fs = color_scheme['instance']\n    instance_color =  ins_c\n    instance_font_weight = give_font_weight(ins_fw)\n    instance_font_style = give_font_style(ins_fs)\n\n    font_token = font_font_style + ' ' + font_font_weight + ' ' + font_color\n    definition_token = (definition_font_style + ' ' + definition_font_weight +\n                        ' ' + definition_color)\n    builtin_token = (builtin_font_style + ' ' + builtin_font_weight + ' ' +\n                     builtin_color)\n    instance_token = (instance_font_style + ' ' + instance_font_weight + ' ' +\n                      instance_color)\n    keyword_token = (keyword_font_style + ' ' + keyword_font_weight + ' ' +\n                     keyword_color)\n    comment_token = (comment_font_style + ' ' + comment_font_weight + ' ' +\n                     comment_color)\n    string_token = (string_font_style + ' ' + string_font_weight + ' ' +\n                    string_color)\n    number_token = (number_font_style + ' ' + number_font_weight + ' ' +\n                    number_color)\n\n    syntax_style_dic = {Name: font_token.strip(),\n                        Name.Class: definition_token.strip(),\n                        Name.Function: definition_token.strip(),\n                        Name.Builtin: builtin_token.strip(),\n                        Name.Builtin.Pseudo: instance_token.strip(),\n                        Keyword: keyword_token.strip(),\n                        Keyword.Type: builtin_token.strip(),\n                        Comment: comment_token.strip(),\n                        String: string_token.strip(),\n                        Number: number_token.strip(),\n                        Punctuation: font_token.strip(),\n                        Operator.Word: keyword_token.strip()}\n\n    return syntax_style_dic",
        "history": [],
        "output": "Create a dictionary that saves the given color scheme as a\n    Pygments style.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def resizeColumnsToContents(self):\r\n        \"\"\"Resize the columns to its contents.\"\"\"\r\n        self._autosized_cols = set()\r\n        self._resizeColumnsToContents(self.table_level,\r\n                                      self.table_index, self._max_autosize_ms)\r\n        self._update_layout()",
        "history": [],
        "output": "Resize the columns to its contents.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def logit_(x:Tensor)->Tensor:\n    \"Inplace logit of `x`, clamped to avoid inf\"\n    x.clamp_(1e-7, 1-1e-7)\n    return (x.reciprocal_().sub_(1)).log_().neg_()",
        "history": [],
        "output": "Inplace logit of `x`, clamped to avoid inf",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _read_config(conf_file=None):\n    '''\n    Reads the config file using configparser\n    '''\n    if conf_file is None:\n        paths = ('/etc/supervisor/supervisord.conf', '/etc/supervisord.conf')\n        for path in paths:\n            if os.path.exists(path):\n                conf_file = path\n                break\n    if conf_file is None:\n        raise CommandExecutionError('No suitable config file found')\n    config = configparser.ConfigParser()\n    try:\n        config.read(conf_file)\n    except (IOError, OSError) as exc:\n        raise CommandExecutionError(\n            'Unable to read from {0}: {1}'.format(conf_file, exc)\n        )\n    return config",
        "history": [],
        "output": "Reads the config file using configparser",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _format_info(data):\n    '''\n    Return formatted information in a pretty way.\n    '''\n    return {'name': data.gr_name,\n            'gid': data.gr_gid,\n            'passwd': data.gr_passwd,\n            'members': data.gr_mem}",
        "history": [],
        "output": "Return formatted information in a pretty way.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def cleanup_attacks_with_zero_images(self):\n    \"\"\"Cleans up data about attacks which generated zero images.\"\"\"\n    print_header('Cleaning up attacks which generated 0 images.')\n    # find out attack work to cleanup\n    self.adv_batches.init_from_datastore()\n    self.attack_work.read_all_from_datastore()\n    new_attack_work = {}\n    affected_adversarial_batches = set()\n    for work_id, work in iteritems(self.attack_work.work):\n      adv_batch_id = work['output_adversarial_batch_id']\n      img_count_adv_batch = len(self.adv_batches.data[adv_batch_id]['images'])\n      if (img_count_adv_batch < 100) and (work['elapsed_time'] < 500):\n        affected_adversarial_batches.add(adv_batch_id)\n        new_attack_work[work_id] = dict(work)\n        new_attack_work[work_id].update(\n            {\n                'claimed_worker_id': None,\n                'claimed_worker_start_time': None,\n                'is_completed': False,\n                'error': None,\n                'elapsed_time': None,\n            })\n    self.attack_work.replace_work(new_attack_work)\n    print_header('Changes in attack works:')\n    print(self.attack_work)\n    # build list of classification batches\n    self.class_batches.init_from_datastore()\n    affected_class_batches = set()\n    for k, v in iteritems(self.class_batches.data):\n      if v['adversarial_batch_id'] in affected_adversarial_batches:\n        affected_class_batches.add(k)\n    # cleanup defense work on affected batches\n    self.defense_work.read_all_from_datastore()\n    new_defense_work = {}\n    for k, v in iteritems(self.defense_work.work):\n      if v['output_classification_batch_id'] in affected_class_batches:\n        new_defense_work[k] = dict(v)\n        new_defense_work[k].update(\n            {\n                'claimed_worker_id': None,\n                'claimed_worker_start_time': None,\n                'is_completed': False,\n                'error': None,\n                'elapsed_time': None,\n                'stat_correct': None,\n                'stat_error': None,\n                'stat_target_class': None,\n                'stat_num_images': None,\n            })\n    self.defense_work.replace_work(new_defense_work)\n    print_header('Changes in defense works:')\n    print(self.defense_work)\n    print('')\n    print('Total number of affected attack work: ', len(self.attack_work))\n    print('Total number of affected defense work: ', len(self.defense_work))\n    inp = input_str('Are you sure? (type \"yes\" without quotes to confirm): ')\n    if inp != 'yes':\n      return\n    print('Writing attacks work')\n    self.attack_work.write_all_to_datastore()\n    print('Writing defenses work')\n    self.defense_work.write_all_to_datastore()\n    print('Done!')",
        "history": [],
        "output": "Cleans up data about attacks which generated zero images.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_empty_ids(self):\n        \"\"\"\n        Get documents id with missing targeted field\n        \"\"\"\n        cursor = self.get_collection().find(\n            {\n                '_id': {'$in': self._document_ids},\n                self._field: {'$exists': True}\n            },\n            {'_id': True}\n        )\n\n        return set(self._document_ids) - {doc['_id'] for doc in cursor}",
        "history": [],
        "output": "Get documents id with missing targeted field",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def apply_network_settings(**settings):\n    '''\n    Apply global network configuration.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' ip.apply_network_settings\n    '''\n    if __grains__['lsb_distrib_id'] == 'nilrt':\n        raise salt.exceptions.CommandExecutionError('Not supported in this version.')\n    if 'require_reboot' not in settings:\n        settings['require_reboot'] = False\n\n    if 'apply_hostname' not in settings:\n        settings['apply_hostname'] = False\n\n    hostname_res = True\n    if settings['apply_hostname'] in _CONFIG_TRUE:\n        if 'hostname' in settings:\n            hostname_res = __salt__['network.mod_hostname'](settings['hostname'])\n        else:\n            log.warning(\n                'The network state sls is trying to apply hostname '\n                'changes but no hostname is defined.'\n            )\n            hostname_res = False\n\n    res = True\n    if settings['require_reboot'] in _CONFIG_TRUE:\n        log.warning(\n            'The network state sls is requiring a reboot of the system to '\n            'properly apply network configuration.'\n        )\n        res = True\n    else:\n        stop = __salt__['service.stop']('connman')\n        time.sleep(2)\n        res = stop and __salt__['service.start']('connman')\n\n    return hostname_res and res",
        "history": [],
        "output": "Apply global network configuration.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' ip.apply_network_settings",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def query(action=None, command=None, args=None, method='GET', data=None):\n    '''\n    Make a web call to a Parallels provider\n    '''\n    path = config.get_cloud_config_value(\n        'url', get_configured_provider(), __opts__, search_global=False\n    )\n    auth_handler = _HTTPBasicAuthHandler()\n    auth_handler.add_password(\n        realm='Parallels Instance Manager',\n        uri=path,\n        user=config.get_cloud_config_value(\n            'user', get_configured_provider(), __opts__, search_global=False\n        ),\n        passwd=config.get_cloud_config_value(\n            'password', get_configured_provider(), __opts__,\n            search_global=False\n        )\n    )\n    opener = _build_opener(auth_handler)\n    _install_opener(opener)\n\n    if action:\n        path += action\n\n    if command:\n        path += '/{0}'.format(command)\n\n    if not type(args, dict):\n        args = {}\n\n    kwargs = {'data': data}\n    if isinstance(data, six.string_types) and '<?xml' in data:\n        kwargs['headers'] = {\n            'Content-type': 'application/xml',\n        }\n\n    if args:\n        params = _urlencode(args)\n        req = _Request(url='{0}?{1}'.format(path, params), **kwargs)\n    else:\n        req = _Request(url=path, **kwargs)\n\n    req.get_method = lambda: method\n\n    log.debug('%s %s', method, req.get_full_url())\n    if data:\n        log.debug(data)\n\n    try:\n        result = _urlopen(req)\n        log.debug('PARALLELS Response Status Code: %s', result.getcode())\n\n        if 'content-length' in result.headers:\n            content = result.read()\n            result.close()\n            items = ET.fromstring(content)\n            return items\n\n        return {}\n    except URLError as exc:\n        log.error('PARALLELS Response Status Code: %s %s', exc.code, exc.msg)\n        root = ET.fromstring(exc.read())\n        log.error(root)\n        return {'error': root}",
        "history": [],
        "output": "Make a web call to a Parallels provider",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def validate(config):\n    '''\n    Validate the beacon configuration\n    '''\n\n    VALID_ITEMS = [\n        'type', 'bytes_sent', 'bytes_recv', 'packets_sent',\n        'packets_recv', 'errin', 'errout', 'dropin',\n        'dropout'\n    ]\n\n    # Configuration for load beacon should be a list of dicts\n    if not isinstance(config, list):\n        return False, ('Configuration for network_info beacon must be a list.')\n    else:\n\n        _config = {}\n        list(map(_config.update, config))\n\n        for item in _config.get('interfaces', {}):\n            if not isinstance(_config['interfaces'][item], dict):\n                return False, ('Configuration for network_info beacon must '\n                               'be a list of dictionaries.')\n            else:\n                if not any(j in VALID_ITEMS for j in _config['interfaces'][item]):\n                    return False, ('Invalid configuration item in '\n                                   'Beacon configuration.')\n    return True, 'Valid beacon configuration'",
        "history": [],
        "output": "Validate the beacon configuration",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_default_annual_spacing(nyears):\n    \"\"\"\n    Returns a default spacing between consecutive ticks for annual data.\n    \"\"\"\n    if nyears < 11:\n        (min_spacing, maj_spacing) = (1, 1)\n    elif nyears < 20:\n        (min_spacing, maj_spacing) = (1, 2)\n    elif nyears < 50:\n        (min_spacing, maj_spacing) = (1, 5)\n    elif nyears < 100:\n        (min_spacing, maj_spacing) = (5, 10)\n    elif nyears < 200:\n        (min_spacing, maj_spacing) = (5, 25)\n    elif nyears < 600:\n        (min_spacing, maj_spacing) = (10, 50)\n    else:\n        factor = nyears // 1000 + 1\n        (min_spacing, maj_spacing) = (factor * 20, factor * 100)\n    return (min_spacing, maj_spacing)",
        "history": [],
        "output": "Returns a default spacing between consecutive ticks for annual data.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def detect_console_encoding():\n    \"\"\"\n    Try to find the most capable encoding supported by the console.\n    slightly modified from the way IPython handles the same issue.\n    \"\"\"\n    global _initial_defencoding\n\n    encoding = None\n    try:\n        encoding = sys.stdout.encoding or sys.stdin.encoding\n    except (AttributeError, IOError):\n        pass\n\n    # try again for something better\n    if not encoding or 'ascii' in encoding.lower():\n        try:\n            encoding = locale.getpreferredencoding()\n        except Exception:\n            pass\n\n    # when all else fails. this will usually be \"ascii\"\n    if not encoding or 'ascii' in encoding.lower():\n        encoding = sys.getdefaultencoding()\n\n    # GH#3360, save the reported defencoding at import time\n    # MPL backends may change it. Make available for debugging.\n    if not _initial_defencoding:\n        _initial_defencoding = sys.getdefaultencoding()\n\n    return encoding",
        "history": [],
        "output": "Try to find the most capable encoding supported by the console.\n    slightly modified from the way IPython handles the same issue.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def list_():\n    '''\n    Returns the machine's bridges list\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' bridge.list\n    '''\n    brs = _os_dispatch('brshow')\n    if not brs:\n        return None\n    brlist = []\n    for br in brs:\n        brlist.append(br)\n\n    return brlist",
        "history": [],
        "output": "Returns the machine's bridges list\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' bridge.list",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _determine_scheduled_actions(scheduled_actions, scheduled_actions_from_pillar):\n    '''\n    helper method for present,  ensure scheduled actions are setup\n    '''\n    tmp = copy.deepcopy(\n        __salt__['config.option'](scheduled_actions_from_pillar, {})\n    )\n    # merge with data from state\n    if scheduled_actions:\n        tmp = dictupdate.update(tmp, scheduled_actions)\n    return tmp",
        "history": [],
        "output": "helper method for present,  ensure scheduled actions are setup",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_progress(opts, out, progress):\n    '''\n    Get the progress bar from the given outputter\n    '''\n    return salt.loader.raw_mod(opts,\n                                out,\n                                'rawmodule',\n                                mod='output')['{0}.progress_iter'.format(out)](progress)",
        "history": [],
        "output": "Get the progress bar from the given outputter",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def connected():\n    '''\n    List all connected minions on a salt-master\n    '''\n    opts = salt.config.master_config(__opts__['conf_file'])\n\n    if opts.get('con_cache'):\n        cache_cli = CacheCli(opts)\n        minions = cache_cli.get_cached()\n    else:\n        minions = list(salt.utils.minions.CkMinions(opts).connected_ids())\n    return minions",
        "history": [],
        "output": "List all connected minions on a salt-master",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_hash(path, form='sha1', chunk_size=4096):\n    '''\n    Generate a hash digest string for a file.\n    '''\n    try:\n        hash_type = getattr(hashlib, form)\n    except AttributeError:\n        raise ValueError('Invalid hash type: {0}'.format(form))\n    with open(path, 'rb') as ifile:\n        hash_obj = hash_type()\n        # read the file in in chunks, not the entire file\n        for chunk in iter(lambda: ifile.read(chunk_size), b''):\n            hash_obj.update(chunk)\n        return hash_obj.hexdigest()",
        "history": [],
        "output": "Generate a hash digest string for a file.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def delete_user(name, runas=None):\n    '''\n    Deletes a user via rabbitmqctl delete_user.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rabbitmq.delete_user rabbit_user\n    '''\n    if runas is None and not salt.utils.platform.is_windows():\n        runas = salt.utils.user.get_user()\n    res = __salt__['cmd.run_all'](\n        [RABBITMQCTL, 'delete_user', name],\n        reset_system_locale=False,\n        python_shell=False,\n        runas=runas)\n    msg = 'Deleted'\n\n    return _format_response(res, msg)",
        "history": [],
        "output": "Deletes a user via rabbitmqctl delete_user.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' rabbitmq.delete_user rabbit_user",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def activate(name):\n    '''\n    Install and activate the given product key\n\n    name\n        The 5x5 product key given to you by Microsoft\n\n    '''\n    ret = {'name': name,\n           'result': True,\n           'comment': '',\n           'changes': {}}\n\n    product_key = name\n\n    license_info = __salt__['license.info']()\n    licensed = False\n    key_match = False\n    if license_info is not None:\n        licensed = license_info['licensed']\n        key_match = license_info['partial_key'] in product_key\n\n    if not key_match:\n        out = __salt__['license.install'](product_key)\n        licensed = False\n        if 'successfully' not in out:\n            ret['result'] = False\n            ret['comment'] += 'Unable to install the given product key is it valid?'\n            return ret\n    if not licensed:\n        out = __salt__['license.activate']()\n        if 'successfully' not in out:\n            ret['result'] = False\n            ret['comment'] += 'Unable to activate the given product key.'\n            return ret\n        ret['comment'] += 'Windows is now activated.'\n    else:\n        ret['comment'] += 'Windows is already activated.'\n    return ret",
        "history": [],
        "output": "Install and activate the given product key\n\n    name\n        The 5x5 product key given to you by Microsoft",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def check_query(query):\n    \"\"\" Check query sanity\n\n    Args:\n        query: query string\n\n    Returns:\n        None\n    \"\"\"\n    q = query.lower()\n    if \"select \" not in q:\n        raise InvalidQuery(\"SELECT word not found in the query: {0}\".format(query))\n    if \" from \" not in q:\n        raise InvalidQuery(\"FROM word not found in the query: {0}\".format(query))",
        "history": [],
        "output": "Check query sanity\n\n    Args:\n        query: query string\n\n    Returns:\n        None",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def setVisible(self, value):\n        \"\"\"Override Qt method to stops timers if widget is not visible.\"\"\"\n        if self.timer is not None:\n            if value:\n                self.timer.start(self._interval)\n            else:\n                self.timer.stop()\n        super(BaseTimerStatus, self).setVisible(value)",
        "history": [],
        "output": "Override Qt method to stops timers if widget is not visible.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def policy_and_value_net(rng_key,\n                         batch_observations_shape,\n                         num_actions,\n                         bottom_layers=None):\n  \"\"\"A policy and value net function.\"\"\"\n\n  # Layers.\n  cur_layers = []\n  if bottom_layers is not None:\n    cur_layers.extend(bottom_layers)\n\n  # Now, with the current logits, one head computes action probabilities and the\n  # other computes the value function.\n  # NOTE: The LogSoftmax instead of the Softmax because of numerical stability.\n  cur_layers.extend([layers.Branch(), layers.Parallel(\n      layers.Serial(layers.Dense(num_actions), layers.LogSoftmax()),\n      layers.Dense(1)\n  )])\n  net = layers.Serial(*cur_layers)\n  return net.initialize(batch_observations_shape, rng_key), net",
        "history": [],
        "output": "A policy and value net function.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def create_client_from_path(self, path):\r\n        \"\"\"Create a client with its cwd pointing to path.\"\"\"\r\n        self.create_new_client()\r\n        sw = self.get_current_shellwidget()\r\n        sw.set_cwd(path)",
        "history": [],
        "output": "Create a client with its cwd pointing to path.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def estimator_spec_eval(\n      self, features, logits, labels, loss, restore_hook, use_tpu):\n    \"\"\"Construct EstimatorSpec for EVAL mode.\"\"\"\n    hparams = self.hparams\n    problem = hparams.problem\n    if logits.get_shape().ndims == 3:\n      logits = tf.expand_dims(tf.expand_dims(logits, 2), 3)\n\n    # Support for multiproblem\n    task_list = [problem]\n    if hasattr(problem, \"task_list\"):\n      task_list = problem.task_list\n\n    eval_metrics_fns = metrics.create_evaluation_metrics(task_list, hparams)\n\n    if use_tpu:\n      def metric_fn(tf_logits, labels):\n        with tf.device(\"cpu:0\"), mtf.utils.outside_all_rewrites():\n          eval_metrics = {}\n          for metric_name, metric_fn in six.iteritems(eval_metrics_fns):\n            if metric_name.split(\"/\")[-1] not in t2t_model.TPU_METRIC_BLACKLIST:\n              eval_metrics[metric_name] = metric_fn(\n                  tf_logits, None, tf.identity(labels))\n          return eval_metrics\n      return tpu_estimator.TPUEstimatorSpec(\n          tf.estimator.ModeKeys.EVAL,\n          evaluation_hooks=[restore_hook],\n          loss=loss,\n          eval_metrics=(metric_fn, [logits, labels]))\n    else:\n      eval_metrics = {}\n      predictions = {\"predictions\": logits}\n      for metric_name, metric_fn in six.iteritems(eval_metrics_fns):\n        eval_metrics[metric_name] = metric_fn(logits, features,\n                                              features[\"targets\"])\n\n      return tf.estimator.EstimatorSpec(\n          tf.estimator.ModeKeys.EVAL,\n          predictions=predictions,\n          eval_metric_ops=eval_metrics,\n          evaluation_hooks=[restore_hook],\n          loss=loss)",
        "history": [],
        "output": "Construct EstimatorSpec for EVAL mode.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def mode_number(self, rows: List[Row], column: NumberColumn) -> Number:\n        \"\"\"\n        Takes a list of rows and a column and returns the most frequent value under\n        that column in those rows.\n        \"\"\"\n        most_frequent_list = self._get_most_frequent_values(rows, column)\n        if not most_frequent_list:\n            return 0.0  # type: ignore\n        most_frequent_value = most_frequent_list[0]\n        if not isinstance(most_frequent_value, Number):\n            raise ExecutionError(f\"Invalid valus for mode_number: {most_frequent_value}\")\n        return most_frequent_value",
        "history": [],
        "output": "Takes a list of rows and a column and returns the most frequent value under\n        that column in those rows.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def is_ner(tag):\n    \"\"\"\n    Check the 10th column of the first token to determine if the file contains\n    NER tags\n    \"\"\"\n    tag_match = re.match(\"([A-Z_]+)-([A-Z_]+)\", tag)\n    if tag_match:\n        return True\n    elif tag == \"O\":\n        return True\n    else:\n        return False",
        "history": [],
        "output": "Check the 10th column of the first token to determine if the file contains\n    NER tags",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def post_copy(self, cursor):\n        \"\"\"\n        Performs post-copy sql - such as cleansing data, inserting into production table (if copied to temp table), etc.\n        \"\"\"\n        logger.info('Executing post copy queries')\n        for query in self.queries:\n            cursor.execute(query)",
        "history": [],
        "output": "Performs post-copy sql - such as cleansing data, inserting into production table (if copied to temp table), etc.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_stage_variables(stage_variables):\n    '''\n    Helper function to retrieve stage variables from pillars/options, if the\n    input is a string\n    '''\n    ret = dict()\n    if stage_variables is None:\n        return ret\n\n    if isinstance(stage_variables, six.string_types):\n        if stage_variables in __opts__:\n            ret = __opts__[stage_variables]\n        master_opts = __pillar__.get('master', {})\n        if stage_variables in master_opts:\n            ret = master_opts[stage_variables]\n        if stage_variables in __pillar__:\n            ret = __pillar__[stage_variables]\n    elif isinstance(stage_variables, dict):\n        ret = stage_variables\n\n    if not isinstance(ret, dict):\n        ret = dict()\n\n    return ret",
        "history": [],
        "output": "Helper function to retrieve stage variables from pillars/options, if the\n    input is a string",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def imagetransformer_sep_channels_8l_tpu():\n  \"\"\"Hparams for training imagetransformer on tpu.\"\"\"\n  hparams = imagetransformer_sep_channels_8l()\n  update_hparams_for_tpu(hparams)\n  hparams.batch_size = 4\n  hparams.num_heads = 4   # heads are expensive on tpu\n  hparams.shared_embedding_and_softmax_weights = False\n  return hparams",
        "history": [],
        "output": "Hparams for training imagetransformer on tpu.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def contains_extra(marker):\n    \"\"\"Check whehter a marker contains an \"extra == ...\" operand.\n    \"\"\"\n    if not marker:\n        return False\n    marker = Marker(str(marker))\n    return _markers_contains_extra(marker._markers)",
        "history": [],
        "output": "Check whehter a marker contains an \"extra == ...\" operand.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_block_indentation(self, block_nb):\r\n        \"\"\"Return line indentation (character number)\"\"\"\r\n        text = to_text_string(self.document().findBlockByNumber(block_nb).text())\r\n        text = text.replace(\"\\t\", \" \"*self.tab_stop_width_spaces)\r\n        return len(text)-len(text.lstrip())",
        "history": [],
        "output": "Return line indentation (character number)",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def adjust_cells(self):\n        \"\"\"Adjust column size based on contents.\"\"\"\n        self.resizeColumnsToContents()\n        fm = self.horizontalHeader().fontMetrics()\n        names = [fm.width(s.cmd) for s in self.source_model.servers]\n        if names:\n            self.setColumnWidth(CMD, max(names))\n        self.horizontalHeader().setStretchLastSection(True)",
        "history": [],
        "output": "Adjust column size based on contents.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def prompt_restart_required(self):\r\n        \"\"\"Prompt the user with a request to restart.\"\"\"\r\n        restart_opts = self.restart_options\r\n        changed_opts = self.changed_options\r\n        options = [restart_opts[o] for o in changed_opts if o in restart_opts]\r\n\r\n        if len(options) == 1:\r\n            msg_start = _(\"Spyder needs to restart to change the following \"\r\n                          \"setting:\")\r\n        else:\r\n            msg_start = _(\"Spyder needs to restart to change the following \"\r\n                          \"settings:\")\r\n        msg_end = _(\"Do you wish to restart now?\")\r\n\r\n        msg_options = u\"\"\r\n        for option in options:\r\n            msg_options += u\"<li>{0}</li>\".format(option)\r\n\r\n        msg_title = _(\"Information\")\r\n        msg = u\"{0}<ul>{1}</ul><br>{2}\".format(msg_start, msg_options, msg_end)\r\n        answer = QMessageBox.information(self, msg_title, msg,\r\n                                         QMessageBox.Yes | QMessageBox.No)\r\n        if answer == QMessageBox.Yes:\r\n            self.restart()",
        "history": [],
        "output": "Prompt the user with a request to restart.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _construct_axes_dict_for_slice(self, axes=None, **kwargs):\n        \"\"\"Return an axes dictionary for myself.\"\"\"\n        d = {self._AXIS_SLICEMAP[a]: self._get_axis(a)\n             for a in (axes or self._AXIS_ORDERS)}\n        d.update(kwargs)\n        return d",
        "history": [],
        "output": "Return an axes dictionary for myself.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def parse_def(self, text):\r\n        \"\"\"Parse the function definition text.\"\"\"\r\n        self.__init__()\r\n\r\n        if not is_start_of_function(text):\r\n            return\r\n\r\n        self.func_indent = get_indent(text)\r\n\r\n        text = text.strip()\r\n        text = text.replace('\\r\\n', '')\r\n        text = text.replace('\\n', '')\r\n\r\n        return_type_re = re.search(r'->[ ]*([a-zA-Z0-9_,()\\[\\] ]*):$', text)\r\n        if return_type_re:\r\n            self.return_type_annotated = return_type_re.group(1)\r\n            text_end = text.rfind(return_type_re.group(0))\r\n        else:\r\n            self.return_type_annotated = None\r\n            text_end = len(text)\r\n\r\n        pos_args_start = text.find('(') + 1\r\n        pos_args_end = text.rfind(')', pos_args_start, text_end)\r\n\r\n        self.args_text = text[pos_args_start:pos_args_end]\r\n\r\n        args_list = self.split_args_text_to_list(self.args_text)\r\n        if args_list is not None:\r\n            self.has_info = True\r\n            self.split_arg_to_name_type_value(args_list)",
        "history": [],
        "output": "Parse the function definition text.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def preprocess_example_common(example, mode, hparams):\n  \"\"\"Preprocessing steps common to all models.\"\"\"\n  if \"inputs\" in example and hparams.max_input_seq_length > 0:\n    example[\"inputs\"] = example[\"inputs\"][:hparams.max_input_seq_length]\n  if hparams.prepend_mode != \"none\":\n    if mode == tf.estimator.ModeKeys.PREDICT:\n      example[\"partial_targets\"] = tf.concat([example[\"inputs\"], [0]], 0)\n    else:\n      example[\"targets\"] = tf.concat(\n          [example[\"inputs\"], [0], example[\"targets\"]], 0)\n  if \"targets\" in example and hparams.max_target_seq_length > 0:\n    example[\"targets\"] = example[\"targets\"][:hparams.max_target_seq_length]\n  if hparams.split_to_length:\n    new_example = {}\n    for k, v in six.iteritems(example):\n      if k == \"targets\" or k == \"inputs\":\n        new_example[k] = tf.reshape(v, [-1, hparams.split_to_length, 1, 1])\n      else:\n        tf.logging.warning(\"Dropping feature %s\" % k)\n    return tf.data.Dataset.from_tensor_slices(new_example)\n  return example",
        "history": [],
        "output": "Preprocessing steps common to all models.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def start_head_processes(self):\n        \"\"\"Start head processes on the node.\"\"\"\n        logger.info(\n            \"Process STDOUT and STDERR is being redirected to {}.\".format(\n                self._logs_dir))\n        assert self._redis_address is None\n        # If this is the head node, start the relevant head node processes.\n        self.start_redis()\n        self.start_monitor()\n        self.start_raylet_monitor()\n        # The dashboard is Python3.x only.\n        if PY3 and self._ray_params.include_webui:\n            self.start_dashboard()",
        "history": [],
        "output": "Start head processes on the node.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def plot_confusion_matrix(self, normalize:bool=False, title:str='Confusion matrix', cmap:Any=\"Blues\", slice_size:int=1,\n                              norm_dec:int=2, plot_txt:bool=True, return_fig:bool=None, **kwargs)->Optional[plt.Figure]:\n        \"Plot the confusion matrix, with `title` and using `cmap`.\"\n        # This function is mainly copied from the sklearn docs\n        cm = self.confusion_matrix(slice_size=slice_size)\n        if normalize: cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]\n        fig = plt.figure(**kwargs)\n        plt.imshow(cm, interpolation='nearest', cmap=cmap)\n        plt.title(title)\n        tick_marks = np.arange(self.data.c)\n        plt.xticks(tick_marks, self.data.y.classes, rotation=90)\n        plt.yticks(tick_marks, self.data.y.classes, rotation=0)\n\n        if plot_txt:\n            thresh = cm.max() / 2.\n            for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n                coeff = f'{cm[i, j]:.{norm_dec}f}' if normalize else f'{cm[i, j]}'\n                plt.text(j, i, coeff, horizontalalignment=\"center\", verticalalignment=\"center\", color=\"white\" if cm[i, j] > thresh else \"black\")\n\n        plt.tight_layout()\n        plt.ylabel('Actual')\n        plt.xlabel('Predicted')\n        plt.grid(False)\n        if ifnone(return_fig, defaults.return_fig): return fig",
        "history": [],
        "output": "Plot the confusion matrix, with `title` and using `cmap`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def utf8(string):\n    \"\"\"\n    Make sure string is utf8 encoded bytes.\n\n    If parameter is a object, object.__str__ will been called before encode as bytes\n    \"\"\"\n    if isinstance(string, six.text_type):\n        return string.encode('utf8')\n    elif isinstance(string, six.binary_type):\n        return string\n    else:\n        return six.text_type(string).encode('utf8')",
        "history": [],
        "output": "Make sure string is utf8 encoded bytes.\n\n    If parameter is a object, object.__str__ will been called before encode as bytes",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def ensure_proper_casing(self):\n        \"\"\"Ensures proper casing of Pipfile packages\"\"\"\n        pfile = self.parsed_pipfile\n        casing_changed = self.proper_case_section(pfile.get(\"packages\", {}))\n        casing_changed |= self.proper_case_section(pfile.get(\"dev-packages\", {}))\n        return casing_changed",
        "history": [],
        "output": "Ensures proper casing of Pipfile packages",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_custom_models(models):\n    \"\"\"Returns CustomModels for models with a custom `__implementation__`\"\"\"\n    if models is None:\n        models = Model.model_class_reverse_map.values()\n\n    custom_models = OrderedDict()\n    for cls in models:\n        impl = getattr(cls, \"__implementation__\", None)\n\n        if impl is not None:\n            model = CustomModel(cls)\n            custom_models[model.full_name] = model\n\n    if not custom_models:\n        return None\n    return custom_models",
        "history": [],
        "output": "Returns CustomModels for models with a custom `__implementation__`",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def key_from_ireq(ireq):\n    \"\"\"Get a standardized key for an InstallRequirement.\"\"\"\n    if ireq.req is None and ireq.link is not None:\n        return str(ireq.link)\n    else:\n        return key_from_req(ireq.req)",
        "history": [],
        "output": "Get a standardized key for an InstallRequirement.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def dump(self, f):\n        \"\"\"Dump an XML document to an open FILE. \"\"\"\n        ret = libxml2mod.xmlDocDump(f, self._o)\n        return ret",
        "history": [],
        "output": "Dump an XML document to an open FILE.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def reset_time(path='.', amt=None):\n    '''\n    Reset atime/mtime on all files to prevent systemd swipes only part of the files in the /tmp.\n    '''\n    if not amt:\n        amt = int(time.time())\n    for fname in os.listdir(path):\n        fname = os.path.join(path, fname)\n        if os.path.isdir(fname):\n            reset_time(fname, amt=amt)\n        os.utime(fname, (amt, amt,))",
        "history": [],
        "output": "Reset atime/mtime on all files to prevent systemd swipes only part of the files in the /tmp.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _round_robin_write(writers, generator):\n  \"\"\"Write records from generator round-robin across writers.\"\"\"\n  for i, example in enumerate(utils.tqdm(\n      generator, unit=\" examples\", leave=False)):\n    writers[i % len(writers)].write(example)",
        "history": [],
        "output": "Write records from generator round-robin across writers.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def on_train_begin(self, **kwargs: Any) -> None:\n        \"Prepare MLflow experiment and log params\"\n        self.client = mlflow.tracking.MlflowClient(self.uri)\n        exp = self.client.get_experiment_by_name(self.exp_name)\n        self.exp_id = self.client.create_experiment(self.exp_name) if exp is None else exp.experiment_id\n        run = self.client.create_run(experiment_id=self.exp_id)\n        self.run = run.info.run_uuid\n        for k,v in self.params.items():\n            self.client.log_param(run_id=self.run, key=k, value=v)",
        "history": [],
        "output": "Prepare MLflow experiment and log params",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def sync(to_install, to_uninstall, verbose=False, dry_run=False, install_flags=None):\n    \"\"\"\n    Install and uninstalls the given sets of modules.\n    \"\"\"\n    if not to_uninstall and not to_install:\n        click.echo(\"Everything up-to-date\")\n\n    pip_flags = []\n    if not verbose:\n        pip_flags += ['-q']\n\n    if to_uninstall:\n        if dry_run:\n            click.echo(\"Would uninstall:\")\n            for pkg in to_uninstall:\n                click.echo(\"  {}\".format(pkg))\n        else:\n            check_call([sys.executable, '-m', 'pip', 'uninstall', '-y'] + pip_flags + sorted(to_uninstall))\n\n    if to_install:\n        if install_flags is None:\n            install_flags = []\n        if dry_run:\n            click.echo(\"Would install:\")\n            for ireq in to_install:\n                click.echo(\"  {}\".format(format_requirement(ireq)))\n        else:\n            # prepare requirement lines\n            req_lines = []\n            for ireq in sorted(to_install, key=key_from_ireq):\n                ireq_hashes = get_hashes_from_ireq(ireq)\n                req_lines.append(format_requirement(ireq, hashes=ireq_hashes))\n\n            # save requirement lines to a temporary file\n            tmp_req_file = tempfile.NamedTemporaryFile(mode='wt', delete=False)\n            tmp_req_file.write('\\n'.join(req_lines))\n            tmp_req_file.close()\n\n            try:\n                check_call(\n                    [sys.executable, '-m', 'pip', 'install', '-r', tmp_req_file.name] + pip_flags + install_flags\n                )\n            finally:\n                os.unlink(tmp_req_file.name)\n\n    return 0",
        "history": [],
        "output": "Install and uninstalls the given sets of modules.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def split_vcs_method_from_uri(uri):\n    # type: (AnyStr) -> Tuple[Optional[STRING_TYPE], STRING_TYPE]\n    \"\"\"Split a vcs+uri formatted uri into (vcs, uri)\"\"\"\n    vcs_start = \"{0}+\"\n    vcs = None  # type: Optional[STRING_TYPE]\n    vcs = first([vcs for vcs in VCS_LIST if uri.startswith(vcs_start.format(vcs))])\n    if vcs:\n        vcs, uri = uri.split(\"+\", 1)\n    return vcs, uri",
        "history": [],
        "output": "Split a vcs+uri formatted uri into (vcs, uri)",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def on_epoch_end(self, pbar, epoch, last_metrics, **kwargs):\n        \"Put the various losses in the recorder and show a sample image.\"\n        if not hasattr(self, 'last_gen') or not self.show_img: return\n        data = self.learn.data\n        img = self.last_gen[0]\n        norm = getattr(data,'norm',False)\n        if norm and norm.keywords.get('do_y',False): img = data.denorm(img)\n        img = data.train_ds.y.reconstruct(img)\n        self.imgs.append(img)\n        self.titles.append(f'Epoch {epoch}')\n        pbar.show_imgs(self.imgs, self.titles)\n        return add_metrics(last_metrics, [getattr(self.smoothenerG,'smooth',None),getattr(self.smoothenerC,'smooth',None)])",
        "history": [],
        "output": "Put the various losses in the recorder and show a sample image.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_config(self):\n        \"\"\"Return configurations of MaxBoltzmannQPolicy\n\n        # Returns\n            Dict of config\n        \"\"\"\n        config = super(MaxBoltzmannQPolicy, self).get_config()\n        config['eps'] = self.eps\n        config['tau'] = self.tau\n        config['clip'] = self.clip\n        return config",
        "history": [],
        "output": "Return configurations of MaxBoltzmannQPolicy\n\n        # Returns\n            Dict of config",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def has_method(obj, method_name):\n    '''\n    Find if the provided object has a specific method\n    '''\n    if method_name in dir(obj):\n        return True\n\n    log.error('Method \\'%s\\' not yet supported!', method_name)\n    return False",
        "history": [],
        "output": "Find if the provided object has a specific method",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_routes(iface):\n    '''\n    Return the contents of the interface routes script.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' ip.get_routes eth0\n    '''\n    path = os.path.join(_RH_NETWORK_SCRIPT_DIR, 'route-{0}'.format(iface))\n    path6 = os.path.join(_RH_NETWORK_SCRIPT_DIR, 'route6-{0}'.format(iface))\n    routes = _read_file(path)\n    routes.extend(_read_file(path6))\n    return routes",
        "history": [],
        "output": "Return the contents of the interface routes script.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' ip.get_routes eth0",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def run_all_evals(models, treebanks, out_file, check_parse, print_freq_tasks):\n    \"\"\"\" Run an evaluation for each language with its specified models and treebanks \"\"\"\n    print_header = True\n\n    for tb_lang, treebank_list in treebanks.items():\n        print()\n        print(\"Language\", tb_lang)\n        for text_path in treebank_list:\n            print(\" Evaluating on\", text_path)\n\n            gold_path = text_path.parent / (text_path.stem + '.conllu')\n            print(\"  Gold data from \", gold_path)\n\n            # nested try blocks to ensure the code can continue with the next iteration after a failure\n            try:\n                with gold_path.open(mode='r', encoding='utf-8') as gold_file:\n                    gold_ud = conll17_ud_eval.load_conllu(gold_file)\n\n                for nlp, nlp_loading_time, nlp_name in models[tb_lang]:\n                    try:\n                        print(\"   Benchmarking\", nlp_name)\n                        tmp_output_path = text_path.parent / str('tmp_' + nlp_name + '.conllu')\n                        run_single_eval(nlp, nlp_loading_time, nlp_name, text_path, gold_ud, tmp_output_path, out_file,\n                                        print_header, check_parse, print_freq_tasks)\n                        print_header = False\n                    except Exception as e:\n                        print(\"    Ran into trouble: \", str(e))\n            except Exception as e:\n                print(\"   Ran into trouble: \", str(e))",
        "history": [],
        "output": "Run an evaluation for each language with its specified models and treebanks",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def generator(self, z, is_training, out_shape):\n    \"\"\"Generator outputting image in [0, 1].\"\"\"\n    hparams = self.hparams\n    height, width, c_dim = out_shape\n    batch_size = hparams.batch_size\n    with tf.variable_scope(\n        \"generator\",\n        initializer=tf.random_normal_initializer(stddev=0.02)):\n      net = tf.layers.dense(z, 1024, name=\"g_fc1\")\n      net = tf.layers.batch_normalization(net, training=is_training,\n                                          momentum=0.999, name=\"g_bn1\")\n      net = lrelu(net)\n      net = tf.layers.dense(net, 128 * (height // 4) * (width // 4),\n                            name=\"g_fc2\")\n      net = tf.layers.batch_normalization(net, training=is_training,\n                                          momentum=0.999, name=\"g_bn2\")\n      net = lrelu(net)\n      net = tf.reshape(net, [batch_size, height // 4, width // 4, 128])\n      net = deconv2d(net, [batch_size, height // 2, width // 2, 64],\n                     4, 4, 2, 2, name=\"g_dc3\")\n      net = tf.layers.batch_normalization(net, training=is_training,\n                                          momentum=0.999, name=\"g_bn3\")\n      net = lrelu(net)\n      net = deconv2d(net, [batch_size, height, width, c_dim],\n                     4, 4, 2, 2, name=\"g_dc4\")\n      out = tf.nn.sigmoid(net)\n      return common_layers.convert_real_to_rgb(out)",
        "history": [],
        "output": "Generator outputting image in [0, 1].",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def on_batch_begin(self, last_input, last_target, train, **kwargs):\n        \"Applies mixup to `last_input` and `last_target` if `train`.\"\n        if not train: return\n        lambd = np.random.beta(self.alpha, self.alpha, last_target.size(0))\n        lambd = np.concatenate([lambd[:,None], 1-lambd[:,None]], 1).max(1)\n        lambd = last_input.new(lambd)\n        shuffle = torch.randperm(last_target.size(0)).to(last_input.device)\n        x1, y1 = last_input[shuffle], last_target[shuffle]\n        if self.stack_x:\n            new_input = [last_input, last_input[shuffle], lambd]\n        else: \n            new_input = (last_input * lambd.view(lambd.size(0),1,1,1) + x1 * (1-lambd).view(lambd.size(0),1,1,1))\n        if self.stack_y:\n            new_target = torch.cat([last_target[:,None].float(), y1[:,None].float(), lambd[:,None].float()], 1)\n        else:\n            if len(last_target.shape) == 2:\n                lambd = lambd.unsqueeze(1).float()\n            new_target = last_target.float() * lambd + y1.float() * (1-lambd)\n        return {'last_input': new_input, 'last_target': new_target}",
        "history": [],
        "output": "Applies mixup to `last_input` and `last_target` if `train`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def refresh_save_all_action(self):\r\n        \"\"\"Enable 'Save All' if there are files to be saved\"\"\"\r\n        editorstack = self.get_current_editorstack()\r\n        if editorstack:\r\n            state = any(finfo.editor.document().isModified() or finfo.newly_created\r\n                        for finfo in editorstack.data)\r\n            self.save_all_action.setEnabled(state)",
        "history": [],
        "output": "Enable 'Save All' if there are files to be saved",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def show_run():\n    '''\n    Shortcut to run `show run` on switch\n\n    .. code-block:: bash\n\n        salt '*' onyx.cmd show_run\n    '''\n    try:\n        enable()\n        configure_terminal()\n        ret = sendline('show running-config')\n        configure_terminal_exit()\n        disable()\n    except TerminalException as e:\n        log.error(e)\n        return 'Failed to show running-config on switch'\n    return ret",
        "history": [],
        "output": "Shortcut to run `show run` on switch\n\n    .. code-block:: bash\n\n        salt '*' onyx.cmd show_run",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _find_file_meta(metadata, bucket_name, saltenv, path):\n    '''\n    Looks for a file's metadata in the S3 bucket cache file\n    '''\n    env_meta = metadata[saltenv] if saltenv in metadata else {}\n    bucket_meta = {}\n    for bucket in env_meta:\n        if bucket_name in bucket:\n            bucket_meta = bucket[bucket_name]\n    files_meta = list(list(filter((lambda k: 'Key' in k), bucket_meta)))\n\n    for item_meta in files_meta:\n        if 'Key' in item_meta and item_meta['Key'] == path:\n            try:\n                # Get rid of quotes surrounding md5\n                item_meta['ETag'] = item_meta['ETag'].strip('\"')\n            except KeyError:\n                pass\n            return item_meta",
        "history": [],
        "output": "Looks for a file's metadata in the S3 bucket cache file",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def set_cert(self, key_file=None, cert_file=None,\n                 cert_reqs=None, ca_certs=None,\n                 assert_hostname=None, assert_fingerprint=None,\n                 ca_cert_dir=None):\n        \"\"\"\n        This method should only be called once, before the connection is used.\n        \"\"\"\n        # If cert_reqs is not provided, we can try to guess. If the user gave\n        # us a cert database, we assume they want to use it: otherwise, if\n        # they gave us an SSL Context object we should use whatever is set for\n        # it.\n        if cert_reqs is None:\n            if ca_certs or ca_cert_dir:\n                cert_reqs = 'CERT_REQUIRED'\n            elif self.ssl_context is not None:\n                cert_reqs = self.ssl_context.verify_mode\n\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.cert_reqs = cert_reqs\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n        self.ca_certs = ca_certs and os.path.expanduser(ca_certs)\n        self.ca_cert_dir = ca_cert_dir and os.path.expanduser(ca_cert_dir)",
        "history": [],
        "output": "This method should only be called once, before the connection is used.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def walk_commands(self):\n        \"\"\"An iterator that recursively walks through all commands and subcommands.\"\"\"\n        for command in tuple(self.all_commands.values()):\n            yield command\n            if isinstance(command, GroupMixin):\n                yield from command.walk_commands()",
        "history": [],
        "output": "An iterator that recursively walks through all commands and subcommands.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def gen_rst(results):\n    \"\"\" creates restructured text documents to display tests \"\"\"\n\n    # make sure the destination directory exists\n    try:\n        os.mkdir(DOCPATH)\n    except OSError as e:\n        if e.args[0] != errno.EEXIST and e.args[0] != errno.EISDIR:\n            raise\n\n    toctree = []\n    class_ = []\n    for output in results:\n        section = output.class_.split(',')\n        for i in range(len(section)):\n            section[i] = section[i].rstrip()\n            if section[i] in CLASSMAP:\n                section[i] = CLASSMAP[section[i]]\n            if i >= len(class_) or section[i] != class_[i]:\n                if i == 0:\n                    filename = section[i].replace(' ', '_').lower()\n                    rst = open(DOCPATH + filename + '.rst', 'w')\n                    rst.write(HEADER)\n                    rst.write(section[i] + '\\n')\n                    rst.write(RSTCHARS[0] * len(section[i]))\n                    rst.write(time.strftime(\"\\nGenerated %a %d %b %Y %X UTC\\n\\n\", time.gmtime()))\n                    toctree.append(filename)\n                else:\n                    rst.write(section[i] + '\\n')\n                    rst.write(RSTCHARS[min(i, len(RSTCHARS)-1)] * len(section[i]))\n                    rst.write('\\n\\n')\n        class_ = section\n        rst.write('.. _cpydiff_%s:\\n\\n' % output.name.rsplit('.', 1)[0])\n        rst.write(output.desc + '\\n')\n        rst.write('~' * len(output.desc) + '\\n\\n')\n        if output.cause != 'Unknown':\n            rst.write('**Cause:** ' + output.cause + '\\n\\n')\n        if output.workaround != 'Unknown':\n            rst.write('**Workaround:** ' + output.workaround + '\\n\\n')\n\n        rst.write('Sample code::\\n\\n' + indent(output.code, TAB) + '\\n')\n        output_cpy = indent(''.join(output.output_cpy[0:2]), TAB).rstrip()\n        output_cpy = ('::\\n\\n' if output_cpy != '' else '') + output_cpy\n        output_upy = indent(''.join(output.output_upy[0:2]), TAB).rstrip()\n        output_upy = ('::\\n\\n' if output_upy != '' else '') + output_upy\n        table = gen_table([['CPy output:', output_cpy], ['uPy output:', output_upy]])\n        rst.write(table)\n\n    template = open(INDEXTEMPLATE, 'r')\n    index = open(DOCPATH + INDEX, 'w')\n    index.write(HEADER)\n    index.write(template.read())\n    for section in INDEXPRIORITY:\n        if section in toctree:\n            index.write(indent(section + '.rst', TAB))\n            toctree.remove(section)\n    for section in toctree:\n        index.write(indent(section + '.rst', TAB))",
        "history": [],
        "output": "creates restructured text documents to display tests",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def debug(self, value):\n        \"\"\"\n        Turn on debug logging if necessary.\n\n        :param value: Value of debug flag\n        \"\"\"\n        self._debug = value\n\n        if self._debug:\n            # Turn on debug logging\n            logging.getLogger().setLevel(logging.DEBUG)",
        "history": [],
        "output": "Turn on debug logging if necessary.\n\n        :param value: Value of debug flag",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _netbsd_interfaces_ifconfig(out):\n    '''\n    Uses ifconfig to return a dictionary of interfaces with various information\n    about each (up/down state, ip address, netmask, and hwaddr)\n    '''\n    ret = dict()\n\n    piface = re.compile(r'^([^\\s:]+)')\n    pmac = re.compile('.*?address: ([0-9a-f:]+)')\n\n    pip = re.compile(r'.*?inet [^\\d]*(.*?)/([\\d]*)\\s')\n    pip6 = re.compile(r'.*?inet6 ([0-9a-f:]+)%([a-zA-Z0-9]*)/([\\d]*)\\s')\n\n    pupdown = re.compile('UP')\n    pbcast = re.compile(r'.*?broadcast ([\\d\\.]+)')\n\n    groups = re.compile('\\r?\\n(?=\\\\S)').split(out)\n    for group in groups:\n        data = dict()\n        iface = ''\n        updown = False\n        for line in group.splitlines():\n            miface = piface.match(line)\n            mmac = pmac.match(line)\n            mip = pip.match(line)\n            mip6 = pip6.match(line)\n            mupdown = pupdown.search(line)\n            if miface:\n                iface = miface.group(1)\n            if mmac:\n                data['hwaddr'] = mmac.group(1)\n            if mip:\n                if 'inet' not in data:\n                    data['inet'] = list()\n                addr_obj = dict()\n                addr_obj['address'] = mip.group(1)\n                mmask = mip.group(2)\n                if mip.group(2):\n                    addr_obj['netmask'] = cidr_to_ipv4_netmask(mip.group(2))\n                mbcast = pbcast.match(line)\n                if mbcast:\n                    addr_obj['broadcast'] = mbcast.group(1)\n                data['inet'].append(addr_obj)\n            if mupdown:\n                updown = True\n            if mip6:\n                if 'inet6' not in data:\n                    data['inet6'] = list()\n                addr_obj = dict()\n                addr_obj['address'] = mip6.group(1)\n                mmask6 = mip6.group(3)\n                addr_obj['scope'] = mip6.group(2)\n                addr_obj['prefixlen'] = mip6.group(3)\n                data['inet6'].append(addr_obj)\n        data['up'] = updown\n        ret[iface] = data\n        del data\n    return ret",
        "history": [],
        "output": "Uses ifconfig to return a dictionary of interfaces with various information\n    about each (up/down state, ip address, netmask, and hwaddr)",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def clear_lock(self, remote=None, lock_type='update'):\n        '''\n        Clear update.lk for all remotes\n        '''\n        cleared = []\n        errors = []\n        for repo in self.remotes:\n            if remote:\n                # Specific remote URL/pattern was passed, ensure that the URL\n                # matches or else skip this one\n                try:\n                    if not fnmatch.fnmatch(repo.url, remote):\n                        continue\n                except TypeError:\n                    # remote was non-string, try again\n                    if not fnmatch.fnmatch(repo.url, six.text_type(remote)):\n                        continue\n            success, failed = repo.clear_lock(lock_type=lock_type)\n            cleared.extend(success)\n            errors.extend(failed)\n        return cleared, errors",
        "history": [],
        "output": "Clear update.lk for all remotes",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def mk_token(self, load):\n        '''\n        Run time_auth and create a token. Return False or the token\n        '''\n        if not self.authenticate_eauth(load):\n            return {}\n\n        if self._allow_custom_expire(load):\n            token_expire = load.pop('token_expire', self.opts['token_expire'])\n        else:\n            _ = load.pop('token_expire', None)\n            token_expire = self.opts['token_expire']\n\n        tdata = {'start': time.time(),\n                 'expire': time.time() + token_expire,\n                 'name': self.load_name(load),\n                 'eauth': load['eauth']}\n\n        if self.opts['keep_acl_in_token']:\n            acl_ret = self.__get_acl(load)\n            tdata['auth_list'] = acl_ret\n\n        groups = self.get_groups(load)\n        if groups:\n            tdata['groups'] = groups\n\n        return self.tokens[\"{0}.mk_token\".format(self.opts['eauth_tokens'])](self.opts, tdata)",
        "history": [],
        "output": "Run time_auth and create a token. Return False or the token",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def log_path(cls, project, log):\n        \"\"\"Return a fully-qualified log string.\"\"\"\n        return google.api_core.path_template.expand(\n            \"projects/{project}/logs/{log}\", project=project, log=log\n        )",
        "history": [],
        "output": "Return a fully-qualified log string.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _check_list_minions(self, expr, greedy, ignore_missing=False):  # pylint: disable=unused-argument\n        '''\n        Return the minions found by looking via a list\n        '''\n        if isinstance(expr, six.string_types):\n            expr = [m for m in expr.split(',') if m]\n        minions = self._pki_minions()\n        return {'minions': [x for x in expr if x in minions],\n                'missing': [] if ignore_missing else [x for x in expr if x not in minions]}",
        "history": [],
        "output": "Return the minions found by looking via a list",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def michalewicz_function(config, reporter):\n    \"\"\"f(x) = -sum{sin(xi) * [sin(i*xi^2 / pi)]^(2m)}\"\"\"\n    import numpy as np\n    x = np.array(\n        [config[\"x1\"], config[\"x2\"], config[\"x3\"], config[\"x4\"], config[\"x5\"]])\n    sin_x = np.sin(x)\n    z = (np.arange(1, 6) / np.pi * (x * x))\n    sin_z = np.power(np.sin(z), 20)  # let m = 20\n    y = np.dot(sin_x, sin_z)\n\n    # Negate y since we want to minimize y value\n    reporter(timesteps_total=1, neg_mean_loss=-y)",
        "history": [],
        "output": "f(x) = -sum{sin(xi) * [sin(i*xi^2 / pi)]^(2m)}",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_global_config_dir():\n        \"\"\"Returns global config location. E.g. ~/.config/dvc/config.\n\n        Returns:\n            str: path to the global config directory.\n        \"\"\"\n        from appdirs import user_config_dir\n\n        return user_config_dir(\n            appname=Config.APPNAME, appauthor=Config.APPAUTHOR\n        )",
        "history": [],
        "output": "Returns global config location. E.g. ~/.config/dvc/config.\n\n        Returns:\n            str: path to the global config directory.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def __pred_for_np2d(self, mat, num_iteration, predict_type):\n        \"\"\"Predict for a 2-D numpy matrix.\"\"\"\n        if len(mat.shape) != 2:\n            raise ValueError('Input numpy.ndarray or list must be 2 dimensional')\n\n        def inner_predict(mat, num_iteration, predict_type, preds=None):\n            if mat.dtype == np.float32 or mat.dtype == np.float64:\n                data = np.array(mat.reshape(mat.size), dtype=mat.dtype, copy=False)\n            else:\n                \"\"\"change non-float data to float data, need to copy\"\"\"\n                data = np.array(mat.reshape(mat.size), dtype=np.float32)\n            ptr_data, type_ptr_data, _ = c_float_array(data)\n            n_preds = self.__get_num_preds(num_iteration, mat.shape[0], predict_type)\n            if preds is None:\n                preds = np.zeros(n_preds, dtype=np.float64)\n            elif len(preds.shape) != 1 or len(preds) != n_preds:\n                raise ValueError(\"Wrong length of pre-allocated predict array\")\n            out_num_preds = ctypes.c_int64(0)\n            _safe_call(_LIB.LGBM_BoosterPredictForMat(\n                self.handle,\n                ptr_data,\n                ctypes.c_int(type_ptr_data),\n                ctypes.c_int(mat.shape[0]),\n                ctypes.c_int(mat.shape[1]),\n                ctypes.c_int(C_API_IS_ROW_MAJOR),\n                ctypes.c_int(predict_type),\n                ctypes.c_int(num_iteration),\n                c_str(self.pred_parameter),\n                ctypes.byref(out_num_preds),\n                preds.ctypes.data_as(ctypes.POINTER(ctypes.c_double))))\n            if n_preds != out_num_preds.value:\n                raise ValueError(\"Wrong length for predict results\")\n            return preds, mat.shape[0]\n\n        nrow = mat.shape[0]\n        if nrow > MAX_INT32:\n            sections = np.arange(start=MAX_INT32, stop=nrow, step=MAX_INT32)\n            # __get_num_preds() cannot work with nrow > MAX_INT32, so calculate overall number of predictions piecemeal\n            n_preds = [self.__get_num_preds(num_iteration, i, predict_type) for i in np.diff([0] + list(sections) + [nrow])]\n            n_preds_sections = np.array([0] + n_preds, dtype=np.intp).cumsum()\n            preds = np.zeros(sum(n_preds), dtype=np.float64)\n            for chunk, (start_idx_pred, end_idx_pred) in zip_(np.array_split(mat, sections),\n                                                              zip_(n_preds_sections, n_preds_sections[1:])):\n                # avoid memory consumption by arrays concatenation operations\n                inner_predict(chunk, num_iteration, predict_type, preds[start_idx_pred:end_idx_pred])\n            return preds, nrow\n        else:\n            return inner_predict(mat, num_iteration, predict_type)",
        "history": [],
        "output": "Predict for a 2-D numpy matrix.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_vsan_cluster_config_system(service_instance):\n    '''\n    Returns a vim.cluster.VsanVcClusterConfigSystem object\n\n    service_instance\n        Service instance to the host or vCenter\n    '''\n\n    #TODO Replace when better connection mechanism is available\n\n    #For python 2.7.9 and later, the defaul SSL conext has more strict\n    #connection handshaking rule. We may need turn of the hostname checking\n    #and client side cert verification\n    context = None\n    if sys.version_info[:3] > (2, 7, 8):\n        context = ssl.create_default_context()\n        context.check_hostname = False\n        context.verify_mode = ssl.CERT_NONE\n\n    stub = service_instance._stub\n    vc_mos = vsanapiutils.GetVsanVcMos(stub, context=context)\n    return vc_mos['vsan-cluster-config-system']",
        "history": [],
        "output": "Returns a vim.cluster.VsanVcClusterConfigSystem object\n\n    service_instance\n        Service instance to the host or vCenter",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_view_menus(self, permission_name):\n        \"\"\"Returns the details of view_menus for a perm name\"\"\"\n        vm = set()\n        for perm_name, vm_name in self.get_all_permissions():\n            if perm_name == permission_name:\n                vm.add(vm_name)\n        return vm",
        "history": [],
        "output": "Returns the details of view_menus for a perm name",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def init(self, args=None):\n        \"\"\"Fills `settings` with values from `settings.py` and env.\"\"\"\n        from .logs import exception\n\n        self._setup_user_dir()\n        self._init_settings_file()\n\n        try:\n            self.update(self._settings_from_file())\n        except Exception:\n            exception(\"Can't load settings from file\", sys.exc_info())\n\n        try:\n            self.update(self._settings_from_env())\n        except Exception:\n            exception(\"Can't load settings from env\", sys.exc_info())\n\n        self.update(self._settings_from_args(args))",
        "history": [],
        "output": "Fills `settings` with values from `settings.py` and env.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def user_remove(username, **kwargs):\n    '''\n    Removes an user.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt minion mssql.user_remove USERNAME database=DBNAME\n    '''\n    # 'database' argument is mandatory\n    if 'database' not in kwargs:\n        return False\n    try:\n        conn = _get_connection(**kwargs)\n        conn.autocommit(True)\n        cur = conn.cursor()\n        cur.execute(\"DROP USER {0}\".format(username))\n        conn.autocommit(False)\n        conn.close()\n        return True\n    except Exception as e:\n        return 'Could not create the user: {0}'.format(e)",
        "history": [],
        "output": "Removes an user.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt minion mssql.user_remove USERNAME database=DBNAME",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def load_data_and_labels():\n    \"\"\"Loads MR polarity data from files, splits the data into words and generates labels.\n    Returns split sentences and labels.\n    \"\"\"\n    # download dataset\n    get_chinese_text()\n\n    # Load data from files\n    positive_examples = list(codecs.open(\"./data/pos.txt\", \"r\", \"utf-8\").readlines())\n    positive_examples = [s.strip() for s in positive_examples]\n    positive_examples = [pe for pe in positive_examples if len(pe) < 100]\n    negative_examples = list(codecs.open(\"./data/neg.txt\", \"r\", \"utf-8\").readlines())\n    negative_examples = [s.strip() for s in negative_examples]\n    negative_examples = [ne for ne in negative_examples if len(ne) < 100]\n    # Split by words\n    x_text = positive_examples + negative_examples\n    # x_text = [clean_str(sent) for sent in x_text]\n    x_text = [list(s) for s in x_text]\n\n    # Generate labels\n    positive_labels = [[0, 1] for _ in positive_examples]\n    negative_labels = [[1, 0] for _ in negative_examples]\n    y = np.concatenate([positive_labels, negative_labels], 0)\n    return [x_text, y]",
        "history": [],
        "output": "Loads MR polarity data from files, splits the data into words and generates labels.\n    Returns split sentences and labels.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def compile(self, optimizer, loss, metrics=None):\n        \"\"\"\n        Args:\n            optimizer (tf.train.Optimizer):\n            loss, metrics: string or list of strings\n        \"\"\"\n        if isinstance(loss, six.string_types):\n            loss = [loss]\n        if metrics is None:\n            metrics = []\n        if isinstance(metrics, six.string_types):\n            metrics = [metrics]\n\n        self._stats_to_inference = loss + metrics + [TOTAL_LOSS_NAME]\n        setup_keras_trainer(\n            self.trainer, get_model=self.get_model,\n            input_signature=self.input_signature,\n            target_signature=self.target_signature,\n            input=self.input,\n            optimizer=optimizer,\n            loss=loss,\n            metrics=metrics)",
        "history": [],
        "output": "Args:\n            optimizer (tf.train.Optimizer):\n            loss, metrics: string or list of strings",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _pad_bytes_new(name, length):\n    \"\"\"\n    Takes a bytes instance and pads it with null bytes until it's length chars.\n    \"\"\"\n    if isinstance(name, str):\n        name = bytes(name, 'utf-8')\n    return name + b'\\x00' * (length - len(name))",
        "history": [],
        "output": "Takes a bytes instance and pads it with null bytes until it's length chars.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def split_seq(sam_num, n_tile):\n    \"\"\"\n    Split the number(sam_num) into numbers by n_tile\n    \"\"\"\n    import math\n    print(sam_num)\n    print(n_tile)\n    start_num = sam_num[0::int(math.ceil(len(sam_num) / (n_tile)))]\n    end_num = start_num[1::]\n    end_num.append(len(sam_num))\n    return [[i, j] for i, j in zip(start_num, end_num)]",
        "history": [],
        "output": "Split the number(sam_num) into numbers by n_tile",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def attack_batch(self, imgs, labs):\n    \"\"\"\n    Run the attack on a batch of instance and labels.\n    \"\"\"\n\n    def compare(x, y):\n      if not isinstance(x, (float, int, np.int64)):\n        x = np.copy(x)\n        if self.TARGETED:\n          x[y] -= self.CONFIDENCE\n        else:\n          x[y] += self.CONFIDENCE\n        x = np.argmax(x)\n      if self.TARGETED:\n        return x == y\n      else:\n        return x != y\n\n    batch_size = self.batch_size\n\n    oimgs = np.clip(imgs, self.clip_min, self.clip_max)\n\n    # re-scale instances to be within range [0, 1]\n    imgs = (imgs - self.clip_min) / (self.clip_max - self.clip_min)\n    imgs = np.clip(imgs, 0, 1)\n    # now convert to [-1, 1]\n    imgs = (imgs * 2) - 1\n    # convert to tanh-space\n    imgs = np.arctanh(imgs * .999999)\n\n    # set the lower and upper bounds accordingly\n    lower_bound = np.zeros(batch_size)\n    CONST = np.ones(batch_size) * self.initial_const\n    upper_bound = np.ones(batch_size) * 1e10\n\n    # placeholders for the best l2, score, and instance attack found so far\n    o_bestl2 = [1e10] * batch_size\n    o_bestscore = [-1] * batch_size\n    o_bestattack = np.copy(oimgs)\n\n    for outer_step in range(self.BINARY_SEARCH_STEPS):\n      # completely reset adam's internal state.\n      self.sess.run(self.init)\n      batch = imgs[:batch_size]\n      batchlab = labs[:batch_size]\n\n      bestl2 = [1e10] * batch_size\n      bestscore = [-1] * batch_size\n      _logger.debug(\"  Binary search step %s of %s\",\n                    outer_step, self.BINARY_SEARCH_STEPS)\n\n      # The last iteration (if we run many steps) repeat the search once.\n      if self.repeat and outer_step == self.BINARY_SEARCH_STEPS - 1:\n        CONST = upper_bound\n\n      # set the variables so that we don't have to send them over again\n      self.sess.run(\n          self.setup, {\n              self.assign_timg: batch,\n              self.assign_tlab: batchlab,\n              self.assign_const: CONST\n          })\n\n      prev = 1e6\n      for iteration in range(self.MAX_ITERATIONS):\n        # perform the attack\n        _, l, l2s, scores, nimg = self.sess.run([\n            self.train, self.loss, self.l2dist, self.output,\n            self.newimg\n        ])\n\n        if iteration % ((self.MAX_ITERATIONS // 10) or 1) == 0:\n          _logger.debug((\"    Iteration {} of {}: loss={:.3g} \" +\n                         \"l2={:.3g} f={:.3g}\").format(\n                             iteration, self.MAX_ITERATIONS, l,\n                             np.mean(l2s), np.mean(scores)))\n\n        # check if we should abort search if we're getting nowhere.\n        if self.ABORT_EARLY and \\\n           iteration % ((self.MAX_ITERATIONS // 10) or 1) == 0:\n          if l > prev * .9999:\n            msg = \"    Failed to make progress; stop early\"\n            _logger.debug(msg)\n            break\n          prev = l\n\n        # adjust the best result found so far\n        for e, (l2, sc, ii) in enumerate(zip(l2s, scores, nimg)):\n          lab = np.argmax(batchlab[e])\n          if l2 < bestl2[e] and compare(sc, lab):\n            bestl2[e] = l2\n            bestscore[e] = np.argmax(sc)\n          if l2 < o_bestl2[e] and compare(sc, lab):\n            o_bestl2[e] = l2\n            o_bestscore[e] = np.argmax(sc)\n            o_bestattack[e] = ii\n\n      # adjust the constant as needed\n      for e in range(batch_size):\n        if compare(bestscore[e], np.argmax(batchlab[e])) and \\\n           bestscore[e] != -1:\n          # success, divide const by two\n          upper_bound[e] = min(upper_bound[e], CONST[e])\n          if upper_bound[e] < 1e9:\n            CONST[e] = (lower_bound[e] + upper_bound[e]) / 2\n        else:\n          # failure, either multiply by 10 if no solution found yet\n          #          or do binary search with the known upper bound\n          lower_bound[e] = max(lower_bound[e], CONST[e])\n          if upper_bound[e] < 1e9:\n            CONST[e] = (lower_bound[e] + upper_bound[e]) / 2\n          else:\n            CONST[e] *= 10\n      _logger.debug(\"  Successfully generated adversarial examples \" +\n                    \"on {} of {} instances.\".format(\n                        sum(upper_bound < 1e9), batch_size))\n      o_bestl2 = np.array(o_bestl2)\n      mean = np.mean(np.sqrt(o_bestl2[o_bestl2 < 1e9]))\n      _logger.debug(\"   Mean successful distortion: {:.4g}\".format(mean))\n\n    # return the best solution found\n    o_bestl2 = np.array(o_bestl2)\n    return o_bestattack",
        "history": [],
        "output": "Run the attack on a batch of instance and labels.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def add_param(self, param_name, layer_index, blob_index):\n        \"\"\"Add a param to the .params file\"\"\"\n        blobs = self.layers[layer_index].blobs\n        self.dict_param[param_name] = mx.nd.array(caffe.io.blobproto_to_array(blobs[blob_index]))",
        "history": [],
        "output": "Add a param to the .params file",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def start_client(self, language):\n        \"\"\"Start an LSP client for a given language.\"\"\"\n        started = False\n        if language in self.clients:\n            language_client = self.clients[language]\n            queue = self.register_queue[language]\n\n            # Don't start LSP services when testing unless we demand\n            # them.\n            if running_under_pytest():\n                if not os.environ.get('SPY_TEST_USE_INTROSPECTION'):\n                    return started\n\n            # Start client\n            started = language_client['status'] == self.RUNNING\n            if language_client['status'] == self.STOPPED:\n                config = language_client['config']\n\n                if not config['external']:\n                    port = select_port(default_port=config['port'])\n                    config['port'] = port\n\n                language_client['instance'] = LSPClient(\n                    parent=self,\n                    server_settings=config,\n                    folder=self.get_root_path(language),\n                    language=language\n                )\n\n                # Connect signals emitted by the client to the methods that\n                # can handle them\n                if self.main and self.main.editor:\n                    language_client['instance'].sig_initialize.connect(\n                        self.main.editor.register_lsp_server_settings)\n\n                logger.info(\"Starting LSP client for {}...\".format(language))\n                language_client['instance'].start()\n                language_client['status'] = self.RUNNING\n                for entry in queue:\n                    language_client.register_file(*entry)\n                self.register_queue[language] = []\n        return started",
        "history": [],
        "output": "Start an LSP client for a given language.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def examples(directory):\n    \"\"\"\n    Generate example strategies to target folder\n    \"\"\"\n    source_dir = os.path.join(os.path.dirname(os.path.realpath(__file__)), \"examples\")\n\n    try:\n        shutil.copytree(source_dir, os.path.join(directory, \"examples\"))\n    except OSError as e:\n        if e.errno == errno.EEXIST:\n            six.print_(\"Folder examples is exists.\")",
        "history": [],
        "output": "Generate example strategies to target folder",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def __merge_json_values(current, previous):\n    \"\"\"Merges the values between the current and previous run of the script.\"\"\"\n    for value in current:\n        name = value['name']\n\n        # Find the previous value\n        previous_value = __find_and_remove_value(previous, value)\n\n        if previous_value is not None:\n            flags = value['flags']\n            previous_flags = previous_value['flags']\n\n            if flags != previous_flags:\n                logging.warning(\n                    'Flags for %s are different. Using previous value.', name)\n\n                value['flags'] = previous_flags\n        else:\n            logging.warning('Value %s is a new value', name)\n\n    for value in previous:\n        name = value['name']\n        logging.warning(\n            'Value %s not present in current run. Appending value.', name)\n\n        current.append(value)",
        "history": [],
        "output": "Merges the values between the current and previous run of the script.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def run(self, fct, input_):\n    \"\"\"Execute the given TensorFlow function.\"\"\"\n    # TF 2.0\n    if tf.executing_eagerly():\n      return fct(input_).numpy()\n    # TF 1.0\n    else:\n      # Should compile the function if this is the first time encountered\n      if not isinstance(input_, np.ndarray):\n        input_ = np.array(input_)\n      run_args = RunArgs(fct=fct, input=input_)\n      signature = self._build_signature(run_args)\n      if signature not in self._graph_run_cache:\n        graph_run = self._build_graph_run(run_args)\n        self._graph_run_cache[signature] = graph_run\n      else:\n        graph_run = self._graph_run_cache[signature]\n\n      # Then execute the cached graph\n      return graph_run.session.run(\n          graph_run.output,\n          feed_dict={graph_run.placeholder: input_},\n      )",
        "history": [],
        "output": "Execute the given TensorFlow function.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def measure_cost(repeat, scipy_trans_lhs, scipy_dns_lhs, func_name, *args, **kwargs):\n    \"\"\"Measure time cost of running a function\n    \"\"\"\n    mx.nd.waitall()\n    args_list = []\n    for arg in args:\n        args_list.append(arg)\n    start = time.time()\n    if scipy_trans_lhs:\n        args_list[0] = np.transpose(args_list[0]) if scipy_dns_lhs else sp.spmatrix.transpose(args_list[0])\n    for _ in range(repeat):\n        func_name(*args_list, **kwargs)\n    mx.nd.waitall()\n    end = time.time()\n    diff = end - start\n    return diff / repeat",
        "history": [],
        "output": "Measure time cost of running a function",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def add_status_code(code):\n    \"\"\"\n    Decorator used for adding exceptions to :class:`SanicException`.\n    \"\"\"\n\n    def class_decorator(cls):\n        cls.status_code = code\n        _sanic_exceptions[code] = cls\n        return cls\n\n    return class_decorator",
        "history": [],
        "output": "Decorator used for adding exceptions to :class:`SanicException`.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def url_for(self, *args: str, **kwargs: str) -> URL:\n        \"\"\"Construct url for route with additional params.\"\"\"\n        return self._resource.url_for(*args, **kwargs)",
        "history": [],
        "output": "Construct url for route with additional params.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def init(**kwargs):\n    '''\n    Initialize the directories for the files\n    '''\n    formula_path = __opts__['formula_path']\n    pillar_path = __opts__['pillar_path']\n    reactor_path = __opts__['reactor_path']\n    for dir_ in (formula_path, pillar_path, reactor_path):\n        if not os.path.exists(dir_):\n            os.makedirs(dir_)\n    return {\n        'formula_path': formula_path,\n        'pillar_path': pillar_path,\n        'reactor_path': reactor_path,\n    }",
        "history": [],
        "output": "Initialize the directories for the files",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def cleanup_failed_attacks(self):\n    \"\"\"Cleans up data of failed attacks.\"\"\"\n    print_header('Cleaning up failed attacks')\n    attacks_to_replace = {}\n    self.attack_work.read_all_from_datastore()\n    failed_submissions = set()\n    error_msg = set()\n    for k, v in iteritems(self.attack_work.work):\n      if v['error'] is not None:\n        attacks_to_replace[k] = dict(v)\n        failed_submissions.add(v['submission_id'])\n        error_msg.add(v['error'])\n        attacks_to_replace[k].update(\n            {\n                'claimed_worker_id': None,\n                'claimed_worker_start_time': None,\n                'is_completed': False,\n                'error': None,\n                'elapsed_time': None,\n            })\n    self.attack_work.replace_work(attacks_to_replace)\n    print('Affected submissions:')\n    print(' '.join(sorted(failed_submissions)))\n    print('Error messages:')\n    print(' '.join(sorted(error_msg)))\n    print('')\n    inp = input_str('Are you sure? (type \"yes\" without quotes to confirm): ')\n    if inp != 'yes':\n      return\n    self.attack_work.write_all_to_datastore()\n    print('Work cleaned up')",
        "history": [],
        "output": "Cleans up data of failed attacks.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_clean_conf_dir():\r\n    \"\"\"\r\n    Return the path to a temp clean configuration dir, for tests and safe mode.\r\n    \"\"\"\r\n    if sys.platform.startswith(\"win\"):\r\n        current_user = ''\r\n    else:\r\n        current_user = '-' + str(getpass.getuser())\r\n\r\n    conf_dir = osp.join(str(tempfile.gettempdir()),\r\n                        'pytest-spyder{0!s}'.format(current_user),\r\n                        SUBFOLDER)\r\n    return conf_dir",
        "history": [],
        "output": "Return the path to a temp clean configuration dir, for tests and safe mode.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def get_profiles(config):\n    '''\n    Get available profiles.\n\n    :return:\n    '''\n    profiles = []\n    for profile_name in os.listdir(os.path.join(os.path.dirname(__file__), 'profiles')):\n        if profile_name.endswith('.yml'):\n            profiles.append(profile_name.split('.')[0])\n\n    return sorted(profiles)",
        "history": [],
        "output": "Get available profiles.\n\n    :return:",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def notify_systemd():\n    '''\n    Notify systemd that this process has started\n    '''\n    try:\n        import systemd.daemon\n    except ImportError:\n        if salt.utils.path.which('systemd-notify') \\\n                and systemd_notify_call('--booted'):\n            # Notify systemd synchronously\n            notify_socket = os.getenv('NOTIFY_SOCKET')\n            if notify_socket:\n                # Handle abstract namespace socket\n                if notify_socket.startswith('@'):\n                    notify_socket = '\\0{0}'.format(notify_socket[1:])\n                try:\n                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)\n                    sock.connect(notify_socket)\n                    sock.sendall('READY=1'.encode())\n                    sock.close()\n                except socket.error:\n                    return systemd_notify_call('--ready')\n                return True\n        return False\n\n    if systemd.daemon.booted():\n        try:\n            return systemd.daemon.notify('READY=1')\n        except SystemError:\n            # Daemon was not started by systemd\n            pass",
        "history": [],
        "output": "Notify systemd that this process has started",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def _get_str(task_dict, extra_indent):\n    \"\"\"\n    This returns a string for each status\n    \"\"\"\n    summary_length = execution_summary().summary_length\n\n    lines = []\n    task_names = sorted(task_dict.keys())\n    for task_family in task_names:\n        tasks = task_dict[task_family]\n        tasks = sorted(tasks, key=lambda x: str(x))\n        prefix_size = 8 if extra_indent else 4\n        prefix = ' ' * prefix_size\n\n        line = None\n\n        if summary_length > 0 and len(lines) >= summary_length:\n            line = prefix + \"...\"\n            lines.append(line)\n            break\n        if len(tasks[0].get_params()) == 0:\n            line = prefix + '- {0} {1}()'.format(len(tasks), str(task_family))\n        elif _get_len_of_params(tasks[0]) > 60 or len(str(tasks[0])) > 200 or \\\n                (len(tasks) == 2 and len(tasks[0].get_params()) > 1 and (_get_len_of_params(tasks[0]) > 40 or len(str(tasks[0])) > 100)):\n            \"\"\"\n            This is to make sure that there is no really long task in the output\n            \"\"\"\n            line = prefix + '- {0} {1}(...)'.format(len(tasks), task_family)\n        elif len((tasks[0].get_params())) == 1:\n            attributes = {getattr(task, tasks[0].get_params()[0][0]) for task in tasks}\n            param_class = tasks[0].get_params()[0][1]\n            first, last = _ranging_attributes(attributes, param_class)\n            if first is not None and last is not None and len(attributes) > 3:\n                param_str = '{0}...{1}'.format(param_class.serialize(first), param_class.serialize(last))\n            else:\n                param_str = '{0}'.format(_get_str_one_parameter(tasks))\n            line = prefix + '- {0} {1}({2}={3})'.format(len(tasks), task_family, tasks[0].get_params()[0][0], param_str)\n        else:\n            ranging = False\n            params = _get_set_of_params(tasks)\n            unique_param_keys = list(_get_unique_param_keys(params))\n            if len(unique_param_keys) == 1:\n                unique_param, = unique_param_keys\n                attributes = params[unique_param]\n                param_class = unique_param[1]\n                first, last = _ranging_attributes(attributes, param_class)\n                if first is not None and last is not None and len(attributes) > 2:\n                    ranging = True\n                    line = prefix + '- {0} {1}({2}'.format(len(tasks), task_family, _get_str_ranging_multiple_parameters(first, last, tasks, unique_param))\n            if not ranging:\n                if len(tasks) == 1:\n                    line = prefix + '- {0} {1}'.format(len(tasks), tasks[0])\n                if len(tasks) == 2:\n                    line = prefix + '- {0} {1} and {2}'.format(len(tasks), tasks[0], tasks[1])\n                if len(tasks) > 2:\n                    line = prefix + '- {0} {1} ...'.format(len(tasks), tasks[0])\n        lines.append(line)\n    return '\\n'.join(lines)",
        "history": [],
        "output": "This returns a string for each status",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def prepend_path_variable_command(variable, paths):\n    \"\"\"\n        Returns a command that prepends the given paths to the named path variable on\n        the current platform.\n    \"\"\"\n    assert isinstance(variable, basestring)\n    assert is_iterable_typed(paths, basestring)\n    return path_variable_setting_command(\n        variable, paths + [expand_variable(variable)])",
        "history": [],
        "output": "Returns a command that prepends the given paths to the named path variable on\n        the current platform.",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    },
    {
        "input": "def run_winpdb(self):\r\n        \"\"\"Run winpdb to debug current file\"\"\"\r\n        if self.save():\r\n            fname = self.get_current_filename()\r\n            runconf = get_run_configuration(fname)\r\n            if runconf is None:\r\n                args = []\r\n                wdir = None\r\n            else:\r\n                args = runconf.get_arguments().split()\r\n                wdir = runconf.get_working_directory()\r\n            # Handle the case where wdir comes back as an empty string\r\n            # when the working directory dialog checkbox is unchecked.\r\n            # (subprocess \"cwd\" default is None, so empty str\r\n            # must be changed to None in this case.)\r\n            programs.run_program(WINPDB_PATH, [fname] + args, cwd=wdir or None)",
        "history": [],
        "output": "Run winpdb to debug current file",
        "instruction": "You are a programmer skilled at writing concise comments for code functions or code snippets. I will provide you with a code snippet or function, and your task is to deeply understand its meaning and generate a brief, clear English comment explaining its purpose and functionality."
    }
]